=== 参加人员 ===

时昌彬  郭思  黄佳欣  兰杰  陈渊  何刚  刘思  徐杰  李腾飞  陈欢欢  梁运  共计11人


=== 第14章 组织直线型代码=== 

====14.1 必须有明确顺序的语句      （陈渊）====
14.1 必须有明确的语句顺序心得:
那么有明确语句顺序的代码好处在哪呢，下面通过一个有明确顺序的代码和没有明确顺序代码的实例，我们会一目了然的发现有明确顺序的代码的优点。<br>
<pre>
例1（有明确顺序）
date = ReadData();
results = =CalculateResultsFromData(date );
PrintResults(results );
</pre>
<pre>
例2（没有明确顺序）
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
</pre>

从上面的两个例子可以很好地看出例的优势，通俗易懂，而且逻辑方面也层层相扣，大大提高了代码的正确性，可读性和可维护性。

那我我们所要做的就是讲自己写的代码有意识的携程有顺序条理清晰的的代码现在，通过一个例子的展现如何改进写的代码的可读性。<br>
<pre>
InitializeExpenseData
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary
</pre>

*加注释对不清晰的依赖关系进行说明<br>
<pre>
InitializeExpenseData//计算Expense数据
ComputeMarketingExpense//四个子程序访问了ExpenseData数据成员
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary//调用了四个子程序访问了ExpenseData数据成员后的数据
</pre>

*'''加参数明确显示依赖关系（推荐）'''<br>
<pre>
expenData = InitializeExpenseData（expenData）;
marketingExpenData = ComputeMarketingExpense（expenData）;
salesExpenData = ComputeSalesExpense（expenData）;
travelExpenseData = ComputeTravelExpense（expenData）;
personnelExpenseData = ComputePersonnelExpense（expenData）;
DispalyExpenseSummary（marketingExpenData,salesExpenData,travelExpenseData,personnelExpenseData）;
</pre>

*用断言或者错误处理代码来检查依赖关系<br>
就是可以再在类的成员变量里将isExpenseDataInitialized设为false,然后再InitializeExpenseData（）中将isExpenseDataInitialized设为true,在下面四个函数对expenData进行操作之前，看看isExpenseDataInitialized是否为true,但是我觉得因为引入新的变量、新的初始化，就变得复杂也不是很好理解，还会增加错误，所以不是很推荐。


====要必须有明确顺序的语句（工号C6632 梁运）====
*有明确语句顺序的代码好处：我们可以通过一个有明确顺序的代码和没有明确顺序代码的对比，一目了然的发现有明确顺序的代码的优点。
**有明确顺序的代码如下：

'''好代码'''
<pre>
date = ReadData();
results = =CalculateResultsFromData(date );
PrintResults(results );
</pre>
*这是一个由前后依赖关系的语句，它潜在的根本概念与依赖性有关。第三条语句依赖于第二条，第二条语句依赖于第一条。在这个代码里，前后语句之间的依赖关系可以很明显的从子程序名中看出来。除非这段代码里发生了不可思议的事情，否则这些语句必须按照所显示的顺序依次执行。
**下面看一个依赖关系没有那么明显的代码
'''坏代码'''
<pre>
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
</pre>
*这个例子中，我们用常识来考虑，应该是先计算季度的收入，才能计算年收入，但是我们仅通过阅读代码是不太能看得出来的。
*通过对比我们清晰的认识到，如果语句之间存在依赖关系，并且这些关系要求你把语句按照一定的顺序加以排列，那么，请设法使这些依赖关系变得明显。


====利用子程序参数明确显示依赖关系（工号C6632 梁运）====
*我们通过对比意识到了把依赖关系变得明确的重要性，那么就要学会如何才能把依赖关系变得明确。
**我们首先看一个被隐藏了语句前后依赖关系的例子如下：
'''坏代码'''
<pre>
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary
</pre>
*假定ComputeMarketingExpense（）会初始化类的成员变量，以便其他所有的子程序能把它的数据放进去，在这种情况下，它需要在其他子程序之前被调用。但是由于这段子程序调用都不带任何参数，因此我们会猜测这里的每一个子程序都会访问类数据，但是我们都不能在代码中明确的看出来。
*在这些子程序之间没有传递任何数据，因此我们不知道有哪些子程序使用了相同的数据。
'''好代码'''
<pre>
InitializeExpenseData（expenData）
ComputeMarketingExpense（expenData）
ComputeSalesExpense（expenData）
ComputeTravelExpense（expenData）
ComputePersonnelExpense（expenData）
DispalyExpenseSummary（expenData）
</pre>
*通过重写代码，让数据在子程序之间传递，就可以暗示执行顺序是很重要的。
*由于子程序都使用了expenData，我们就可以清晰的看出，它们操作了相同的数据。


====加注释对不清晰的依赖关系进行说明（工号C6632 梁运）====
*如果还是担心有些依赖关系不够清楚，那么就用文档说明它。一方面是对不清楚的依赖关系进行进一步的说明，另一方面就是这样做可以编写出可维护、易修改的代码。

'''好代码'''
<pre>
InitializeExpenseData//计算Expense数据
ComputeMarketingExpense//四个子程序访问了ExpenseData数据成员
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary//调用了四个子程序访问了ExpenseData数据成员后的数据
</pre>
*这个代码没有使用那些让顺序依赖关系变得明显的技巧，完全就是单纯的加上注释，这个肯定不如那些好的编写技术，只有在维护一些要求特别严格的代码时，或者由于一些原因，没办法改进代码本身了，那么再使用这个方法来弥补不足吧。
**可以参照一种更好的方法如下：
'''好代码'''
<pre>
expenData = InitializeExpenseData（expenData）;
marketingExpenData = ComputeMarketingExpense（expenData）;
salesExpenData = ComputeSalesExpense（expenData）;
travelExpenseData = ComputeTravelExpense（expenData）;
personnelExpenseData = ComputePersonnelExpense（expenData）;
DispalyExpenseSummary
</pre>
*这是把这些子程序转变成输入expenData，并把更新过的expenData作为输出加以返回的函数，这样代码中包含的顺序依赖关系就更明显了。

====14.2 顺序无关的语句           （陈渊）====

14.2 顺序无关的语句心得
=====是代码易于自上而下地阅读=====
其中最最重要的一点就是：要把相关的操作都放在一起。要让别人轻松的读懂你的代码，就要让你的程序易于自上而下的阅读，不能让读者去大量的代码中去搜寻他想要的信息，举一个例子:<br>
<pre>
MarketingData marketingData;
SalesData salesData;
TravelData travelData;

travelData.computeQuarterly();
salesData.computeQuarterly();
marketingData.computeQuarterly();

marketingData.computeAnnual();
salesData.computeAnnual();
travelData.computeAnnual();

salesData.Print();
travelData.Print();
marketingData.Print();
</pre>

上面的代码跳来跳去的让人看了很不舒服，如果放在一大堆的代码里，读者估计得花很长时间去搜寻他想要的信息如果想知道travelData是怎么来的，那他就得全局去搜，而且还会想，用到的地方是不是就仅仅只有这几个呢，给阅读带来了很大的不便，要是我们能做到把相关的操作放一起，那效果就不一样了。<br>
<pre>
MarketingData marketingData;
marketingData.computeQuarterly();
marketingData.computeAnnual();
marketingData.Print();

SalesData salesData;
salesData.computeQuarterly();
salesData.computeAnnual();
salesData.Print();

TravelData travelData;
travelData.computeQuarterly();
travelData.computeAnnual();
travelData.Print();
</pre>

如过我们改成了上面的代码，把相关的的语句组织到一起，放在一起，那么对代码的可读性、可维护性有了大大的提升

=====把相关的语句组织到一起=====
把相关的语句放一起。让一些处理相同的数据、执行相似的任务，或具有某种执行顺序上的依赖关系的语句放在一起，能够很好地提高代码的可读性。

=== 第15章 使用条件语句===

====15.1 if语句                  （何刚）====
*'''写if语句时，首先写正常代码路径；再处理不常见情况'''
    在编写代码时，要使的正常情况的执行路径在代码中是清晰的。要确保那些不常见的情况不会遮掩正常的执行路径。这对可读性和代码性能来说都很重要。
*'''把最常见的情况放在最前面'''
    把最常见的情况放在前面，可以让阅读的人为找出正常情况的处理代码而必须要读的非常见情况的代码边的最少。同时，由于把在执行最常见情况代码之前所需的判断减到最少，代码效率也得到了提高，就像下面一样：
<pre>
If ( IsLetter( inputCharacter ) ) {                //最为常见的情况会先在这里得到处理
  CharacterType = CharacterType_Letter;
}
else if ( IsPunctuation( inputCharacter ) ) {
  CharacterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
  CharacterType = CharacterType_Digit;
}
else if ( IsCotrolCharacter( inputCharacter ) ) {      //最不常见的情况则是放在最后来解决
  CharacterType = CharacterType_CotrolCharacter;
}
</pre>

*'''把正常情况的处理放在if后面而不要放在else后面'''
    把认为会正常出现的情况放在前面处理，这符合把决策的结果代码放在尽可能靠近决策位置的一般原则。
*'''''坏代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Error ) Then 
  errorType = FileOpenError            //出错情况
Else 
  ReadFile ( inputFile, fileData, status )    //正常情况
  If ( status = Status_Success ) Then    
    SummarizeFileData ( fileData, summaryData, status )    //正常情况
    If ( status = Status_Error ) Then 
      errorType = ErrorType_DataSummaryError          //出错情况
    Else 
      PrintSummary( summaryData )                   //正常情况
      SaveSummaryData( summaryData, status )
      If ( status = Status_Error ) Then
        errorType = ErrorType_SummarySavaError        //出错情况
      Else 
        UpdateALLAccounts ( )                        //正常情况
        EraseUndoFile ( )
        errorType = ErrorType_None
      End If
    End If
  Else 
  errorType = ErrorType_FileReadError
  End if
End If
</pre>
    这段代码很难理解，因为它把正常的情况和出错的情况混在了一起。很难从中找出正常代码的路径来。除此之外，因为错误条件有的时候是在If子句而不是else中处理，所以很难判断到底哪个if子句检测了与之相关的正常情况。
*'''''好代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Success ) Then 
  ReadFile ( inputFile, fileData, status )      //正常情况
  If ( status = Status_Success ) Then 
    SummarizeFileData ( fileData, summaryData, status )    //正常情况
    If ( status = Status_Success ) Then
      PrintSummary( summaryData )                   //正常情况
      SaveSummaryData( summaryData, status )
      If ( status = Status_Success ) Then
        UpdateALLAccounts ( )                        //正常情况
        EraseUndoFile ( )
        errorType = ErrorType_None
      Else
        errorType = ErrorType_SummarySavaError        //出错情况
      End If
    Else
      errorType = ErrorType_DataSummaryError          //出错情况
    End If
  Else
    errorType = ErrorType_FileReadError
  End If
Else
  errorType = ErrorType_FileOpenError      //出错情况
</pre>
    在修改后的例子里，可以通过阅读if条件测试的主流程来找到正常的情况。这一修改使认得注意力集中到了阅读代码的主流程上，而不是费力的去理解那些异常处理情况，因此整体代码更容易阅读。嵌套条件语句的下面积累了全部的错误情况，这是良好错误处理代码的一个标志。	

*'''让if子句后面跟随一个有意义的语句'''
有时候我们会看到这样一种代码，其中if子句是空的：

*'''''坏代码'''''
<pre>
If ( SomeTest )
       ;
Else {
//do something 
......
}
</pre>

    哪怕是为了少些那个额外的空语句行和else行代码，也应该避免这么编写代码。将上面程序中if语句的谓语做否定，把else子句中的代码移到if子句中并去掉else子句就可以可以得到下面的代码了：

*'''''好代码'''''
<pre>
If ( ! SomeTest ) {
      //do something 
      ......
}
</pre>

*'''测试else子句的正确性'''
在测试代码的时候，有人可能觉得只有if子句需要测试，实际上对else我们也一定要测试它。

*'''检查if和else子句是不是弄反了'''
    在编程中经常会犯这么一种错误，那就是要么把本应该放在if子句后面的代码和本应该放在else子句后面的代码给弄反了，要么就是把if测试的逻辑弄反了。在实际工作中，在写if-else语句的时候一定要注意代码里的逻辑关系，并需要认真测试。



==== 判断语句if else 使用心得（工号C6609 黄佳欣）====
*把正常情况的处理放在if处理的后面，不要放在else的后面。这样的代码可阅读性更强。
'''坏代码：'''
<pre>
if（status = Status_Error1）{
	error=Error1;//出错情况1
}else{
	A = B;//正常情况2
	if（status = Status_Success）{
		C = D；//正常情况
		if（status = Status_Error2）{
			error=Error2;//出错情况2
		}else{
			E = F;//正常情况3
		}
	}else{
		error=Error3;//出错情况3
	}
}
</pre>
'''好代码：'''
<pre>
if（！status = Status_Error1）{
	A = B;//正常情况1
	if（status = Status_Success）{
		C = D；//正常情况2
		if（！status = Status_Error2）{
			E = F;//正常情况 3
		}else{
			error=Error2;//出错情况2
		}
	}else{
		error=Error3;//出错情况3
	}
}else{
	error=Error1;//出错情况1
}
</pre>
*if后面跟上一个有意义的语句。
'''坏代码：'''
<pre>
if（A=B）{
	//do nothing
}else{
	//do something
	A=B;
}
</pre>
'''好代码：'''
<pre>
if（!A=B）{
	//do something
	A=B;
}else{
	//do nothing
}
</pre>
*if语句后面一定要加else，哪怕是写一个空语句也行。
'''坏代码：'''
<pre>
if（!A=B）{
	//do something
	A=B;
}
</pre>
'''好代码：'''
<pre>
if（!A=B）{
	//do something
	A=B;
}else{
	//do nothing
	//这种情况下A不赋值。
}
</pre>
====if语句心得1（工号C6609 黄佳欣）====
*if语句中有多个逻辑运算的时候，每个逻辑运算都用括号括起来，这样便于代码阅读。<br>
'''坏代码：'''
<pre>
if（A = B && C = D）{
	A=C+D;//A等于C+D
}else{
	B=C+D;//B等于C+D
}
</pre>
'''好代码：'''
<pre>
if（（A = B ）&&（ C = D））{
	A=C+D;//A等于C+D
}else{
	B=C+D;//B等于C+D
}
</pre>
====if语句心得2（工号C6609 黄佳欣）====
*if语句中有多个逻辑运算（and 和 or）的时候，使用&&和||,可以加快代码运行速度。<br>
'''坏代码：'''
<pre>
if（（（A = B ）&（ C = D））| (（A = C ）&（ B = D））{
	A=C+D;//A等于C+D
}else{
	B=C+D;//B等于C+D
}
</pre>
'''好代码：'''
<pre>
if（（（A = B ）&&（ C = D））|| (（A = C ）&&（ B = D））{
	A=C+D;//A等于C+D
}else{
	B=C+D;//B等于C+D
}
</pre>
====if语句心得3（工号C6609 黄佳欣）====
*使用if ...else if ...else 进行多个判断的时候，要把最常见或者最容易出现的情况放到最前面，以最常见或者最容易出现的情况来排顺序，做判断。假如 A = 1 是最多出现的最多，A = 2 是差不多出现的排第二，A = 3 是差不多出现的排第三。（实际上这种情况使用swith更好，在本例子中只是为了表现if语句。）<br>
'''坏代码：'''
<pre>
if（A = 3）{
	A=A+3；//A等于A+3
}else if（A = 1）{
	A=A+1；//A等于A+1
}else if（A = 2）{
	A=A+2；//A等于A+2
}else{
	//do nothing
}
</pre>
'''好代码：'''
<pre>
if（A = 1）{
	A=A+1；//A等于A+1
}else if（A = 2）{
	A=A+1；//A等于A+2
}else if（A = 3）{
	A=A+1；//A等于A+3
}else{
	//do nothing
}
</pre>
====case 语句的善用心得1（工号C6609 黄佳欣）====
*使用case简化对应的操作，也让代码变得更清晰。使用上面的例子：<br>
'''坏代码：''
<pre>'
if（A = 1）{
	A=A+1；//A等于A+1
}else if（A = 2）{
	A=A+1；//A等于A+2
}else if（A = 3）{
	A=A+1；//A等于A+3
}else{
	//do nothing
}
</pre>
'''好代码：'''
<pre>
switch（A）{
	case 1：
	A=A+1；//A等于A+1
	break；
	case 2：
	A=A+2；//A等于A+2
	break；
	case 3：
	A=A+3；//A等于A+3
	break；
	default:
	//do nothing
}
</pre>
====case 语句的善用心得2（工号C6609 黄佳欣）====
*不要为了使用case语句而刻意的制造一个变量。这是判断用户操作的代码，copy，delete，fmoat，help。
'''坏代码：'''
<pre>
action = userCommand[0];
switch(action){
	case 'c':
	Copy();//copy操作
	break;
	case 'd':
	DeleteCharacter();//删除操作
	break;
	case 'f':
	Format();//格式操作
	break;
	case 'h':
	Help();//帮助
	break;
	default:
	HandleUserInputError(ErrorType.InvalidUserCommand);//异常处理
}
</pre>
如果用户输入了一个C开头的字符串，就会运行Copy（），但这并不是我们想要的。<br>
'''好代码：'''
<pre>
if(UserCommand.equals(COMMAND_STRING_COPY)){
	Copy;//copy操作
}else if(UserCommand.equals(COMMAND_STRING_DELETE)){
	DeleteCharacter();//删除操作
}else if(UserCommand.equals(COMMAND_STRING_FORMAT)){
	Format();//格式操作
}else if(UserCommand.equals(COMMAND_STRING_HELP)){
	Help();//帮助
}else{
	HandleUserInputError(ErrorType.InvalidUserCommand);//异常处理
}
</pre>
====case 语句的善用心得3（工号C6609 黄佳欣）====
*把default子句只用于检查真正的默认情况，不要把它作为最后一种判断情况来处理，这样会失去default子句检测错误的能力。假如A只能等于1,2,3 的情况：<br>
'''坏代码：'''
<pre>
switch（A）{
	case 1：
	A=A+1；//A等于A+1
	break；
	case 2：
	A=A+2；//A等于A+2
	break；
	default:
	A=A+3；//A等于A+3
}
</pre>
'''好代码：'''
<pre>
switch（A）{
	case 1：
	A=A+1；//A等于A+1
	break；
	case 2：
	A=A+2；//A等于A+2
	break；
	case 3：
	A=A+3；//A等于A+3
	break；
	default:
	DisplayInternalError("出现错误");//异常处理
}
</pre>
=====简单if-then语句(c6618 陈渊)=====
if-then的简单示例
<pre>
if(...) Then
...
</pre>
'''注意'''：if后面判断的语句要仔细考虑条件是否满足实际情况，比如：>=和>就不一样前面一种情况既包含了大于又包含了等于，要结合实际情况下，判断这两种情况是否要分开写。

=====简单if-then-else 语句(c6618 陈渊)=====

当我们写if，else语句的时候首先会考虑有几种情况，这样我们就定了用几个if、else('''个人建议if、else最好成对出现避免出现遗漏混乱的情况''')
其次，我们最该考虑的就是if后面的语句和else后面的语句
*'''if后面的语句'''
上述if-then中已经提到提到了if后面加判断语句，就是后面要加一个有意义的的语句
错误代码：
<pre>
if(someTset){
...;
}
else{
....;
}
</pre>
这里面的someTset就不是一个有意义的语句即判断句
可以改为如下代码：
<pre>
if(！someTset){
...;
}
else{
....;
}
</pre>
*'''else后面的语句'''
在一些语句中可能只有if语句，但是，应该吧else的情况也考虑到，可以写一个else的空语句，就像我上面说的最好成对出现，因为在复杂的情况下，这样写很容易帮你看出语句的完整性，不容易出现少判断，漏情况的问题。而且让别人看你的代码的时候也更容易看懂，可维护性大大提高另外。我们可以在else语句中注释为什么这里不需要else子句
（个人推荐的书写格式）
<pre>
if(a=b){
...;
}else if(a<b){
...;
}else if(a>b){
...;
}else {
//假设a与b的只有这三种情况的判断，那么在这个else里就不用子句，但最好注释一下便于维护
}
</pre>

=====确保对于等量的分支是正确的（C6604 郭思）=====
　　在循环里，要仔细考虑端点的值，在条件语句里，也要确定条件是否满足实际情况。
<pre>
int A=5;
int n=0;
If (A > 1) {
    n++;
    A--;
}
</pre>
<pre>
int A=5;
int n=0;
If (A >= 1) {
    n++;
    A--;
}
</pre>
　　上面两段代码中，由于条件的不同，最终ｎ的值也不一样。这只是一个比较小的问题，如果在很复杂，很重要的代码中发生这样的问题，很可能会造成不易发现的错误。

=====让if子句后面跟一个有意义的语句（C6604 郭思）=====
　　有时候，在某个条件下没有动作要进行，也就是If子句是空的。比如下面的代码：
<pre>
int A=5;
int n=0;
If (A < 1) 
    ;
else {
    n++;
    A--;
}
</pre>
　　这样看上去很奇怪，这时我们可以对if的条件做否定，把else的子句移到if子句中，并去掉else子句。比如：
<pre>
int A=5;
int n=0;
If (A >= 1) {
    n++;
    A--;
}
</pre>

=====要考虑else子句（C6604 郭思）=====
　　很多情况下，我们写的代码都只有if语句，其实，在我们写代码的时候，应该吧else的情况也考虑到，可以编写一个else的空语句。另外，当在测试的过程中遇到只有if语句的时候，除非原因显而易见，否则要用注释来解释为什么这里不需要else子句。
<pre>
//if color is vaild
if (COLOR_MIN <= color && color<= COLOR_MAX){
    //do something
    ....
}
else {
    //else color is invaild
    //screen not written to -- safely ignore command
}
</pre>


====15.2 case语句                （何刚）====
=====为case选择最有效的列顺序=====
*'''按字母顺序或按数字顺序排列各种情况'''
    如果所有情况的重要性都相同，那么就把它们按A-B-C的顺序加以排列，以便提高可读性。
*'''把正常的情况放在前面'''
    如果有一个正常情况和多个异常情况，那么把那个正常的情况放在最前面。用注释来说明它是正常情况，而其他的属于非正常情况。
*'''按执行频率排列case子句'''
    把最经常执行的情况放在最前面，最不常执行的放在最后面。这样做有两方面的好处。首先阅读程序的人可以很容易的找出最常见的情况。那些检索情况列表，找出某个具体情况的读者很可能对最常见的情况感兴趣，而把最常见的情况放在代码的上部会加速这种检索。
=====使用case语句的诀窍=====
*'''简化每种情况对应的操作'''
    使得每种情况有关的代码短小精悍。简短的情况处理代码会使case语句的结构更加清晰。如果某种情况执行的操作非常复杂，那么就写一个子程序，并在该情况对应的case子句中调用它。
*'''不要为了使用case语句而刻意制造一个变量'''
    case语句应该用于处理简单，容易分类的数据。如果数据并不简单，那么就使用if-then-else语句串。
*'''利用default子句来检测错误'''
    如果一条case语句中的默认子句既没有用来做其他的处理，按照正常执行顺序也不太可能会发生，那么就向里面加入一条诊断消息：
<pre>
Switch ( commandShortcutLetter ) {
  case ‘a’ :
    PrintAnnualReport () ;
    Break;
  case ‘p :
    //No action required, but case was considered
    Break;
  case ‘q’ :
    PrintQuarterlyReport () ;
    Break;
  case ‘s’ :
    PrintSummaryReport () ;
    Break;
  default:
    DisplayTnternalError(
            “Internal Error 905: Call customer support.”)  
}
</pre>
    如果把默认子句用于错误检测以外的其他目的，那就意味着每一种情况的选择都是正确的。请仔细检查以确认每一个可能进入case语句的值都是合法的。如果发现一些不合法的值，那就重写这些语句，让默认子句去执行错误检测。

=====case语法形式常用心得（工号C6428 葛川川）=====
<pre>
switch(表达式)
{   case 常量表达式1：语句序列1
case 常量表达式2：语句序列2
.
.
.
case 常量表达式n：语句序列n
default： 语句序列n+1
}
</pre>
其中
①switch、case和default是C语言关键字，default是可以缺省的项；
②switch后的表达式必须为整型或字符型表达式；
③case后的常量表达式称为标号，且标号须互不相同，case与标号之间必须留有空格；
④必要时，某些case标号后的语句序列可以不写，但冒号不可省；
⑤语句序列可以是一条也可以是多条，且多条不需组合成复合语句。
=====执行过程简述（工号C6428 葛川川）=====
首先计算switch后表达式的值，然后寻找与其相等的case标号，如果找到了则从该case后的语句序列开始执行下去，不再进行判断，直至遇break或switch结构结束；如果没有找到与switch表达式的值相等的case标号，则执行default后的语句序列或退出switch结构（default缺省的情况下）。
=====break使用与否的对比（工号C6428 葛川川）=====
break，它是一个使程序立即从switch结构或循环中退出的语句
设变量grade是字符型的,代表成绩的等级，以下程序段则实现根据学生成绩的等级来输出相应的分数范围：
<pre>
switch(grade)
{case ‘A’:printf(“90~100\n”);break;
case ‘B’:printf(“80~89\n”); break;
case ‘C’:printf(“70~79\n”); break;
case ‘D’:printf(“60~69\n”); break;
case ‘E’:printf(“ 0~59\n”); break;
default: printf(“error!\n”);
}
</pre>
执行以上程序段时，若grade的值为‘A’则输出结果是：90~100回车；若grade的值为‘D’则输出结果是：60~69回车；若grade的值超出A-E这五个等级之外，例如’G’则输出结果是：error!回车。
如果将所有的break语句去掉，程序变成：
<pre>
switch(grade)
{case ‘A’:printf(“90~100\n”);
case ‘B’:printf(“80~89\n”);
case ‘C’:printf(“70~79\n”);
case ‘D’:printf(“60~69\n”);
case ‘E’:printf(“ 0~59\n”);
default: printf(“error!\n”); }
则程序找到一个入口之后会一直执行到switch结束，例如，若grade的值为‘C’则输出结果是：70~79
60~69
0~59
error!
</pre>
显然，后面三行的信息我们是不需要的，所以实际应用中要善于使用break语句。


=====case子句的排序要有意义（C6604 郭思）=====
　　我们都知道case子句是顺序执行的，如果是只有两三个选项的case语句，顺序就不那么重要；但是如果用case来解决复杂的问题，要处理多个事件，那顺序就很重要。所以case子句的排序要有一定的规则。
#按字母顺序或数字顺序排列  当所有的case选项同样重要时，可以用A-B-C或者1-2-3这样的顺序表示，这样可以让读者更容易理解代码，也更容易找到特定的情况。
#把正常的情况放在前面  如果有正常情况和异常情况，把正常的情况放在前面，并注释说明。
#按执行频率排序  把执行频率高的情况放在前面，这样便于阅读代码的人找到最常见的情况。


=====在C++和Java里，每个case的末尾都要有一个break（C6604 郭思）=====
　　在C++和Java中，case语句不会自动跳出每一种情况。必须给每一个case子句写上break语句。如果没有break，程序运行完当前的情况后会继续执行下一条case子句，直到遇到break为止；如果没有break，则会运行到default语句，最后结束switch语句。比如：
<pre>
int n=2;
switch(n){
    case 1:printf("1");
    case 2:printf("2");
    case 3:printf("3");break；
    case 4:printf("4");
    default;
}
</pre>
　　上面的代码本意是想输出2，但是没有加break的时候，switch发现2匹配，执行printf("2");然后继续执行printf("3");遇到break停止。与预想的结果不符，而且这种没有break的switch-case语句让读者很难理解，修改代码的时候要考虑的事情还很多，所以最好在写代码的时候就让每一个case子句后面跟上break语句。

=====在case末尾明确地标明需要穿越执行的程序（C6604 郭思）=====
　　如果需要让代码故意跳过某个case子句的末尾，那就要在相应的位置注释说明为什么要这样写代码。比如：
<pre>
int n;
cin>>n;
switch(n){
    case 1: //当n=1或n=2时，都输出'X'
    case 2:cout<<'X';break;
    case 3: //当n=3或n=4时，都输出'Y'
    case 4:cout<<'Y';break;
    default:cout<<'Z';
}
</pre>
　　上面的代码最后的结果可能是Y或者Z或者XY，但是不可能出现X，因为case 2没有break语句，会继续到case 4，直到break结束。在穿越执行的程序附近加上注释，让读者更容易理解，增强了代码的可读性。
=====case子句排列的有意义吗？要合理排序，便于理解阅读。  （工号C6620 刘思）=====
普通程序中的switch没有多少个分支，对于效率可以认为没有影响。但如果是很长的循环switch语句中case子句的顺序不同，也会会影响效率。
好的代码
<pre>
	int a = 0;
	while (a < 5) { 
                switch (a) {    
		case 0:                    
		case 1:
		case 2:	a = a + 3;break;  
		case 3: a = a + 2; break;             
		default:  break;         
		}
	}
		System.out.println(a);
</pre>
不好的代码
<pre>
	int a = 0;
	while (a < 5) {    
		switch (a) {
		case 0:                    
		case 3:a = a + 2; break;
		case 1:
		case 2: a = a + 3;  break;              
		default:   break;
		}
	}
		System.out.println(a);
</pre>
前面的代码能一目了然，后者显得杂乱无章。尽量把正常情况，执行频率高的case放在前面。
=====case语句高效使用几大原则  （工号C6620 刘思）=====
*default子句只用于检查真正的默认情况，而不要把剩下的一种情况放到case里。
*即使不需要default处理，也应该保留一个空的default语句。
*不要为了使用case语句可以制造一个变量。case语句应该用于处理简单的、容易分类的数据。如果数据不简单易于分类，请使用if-else语句。


=== 第16章 控制循环===

====16.1 选择循环的种类           （徐杰）====
=====常见的循环有计数循环、连续求值的循环、无限循环和迭代器循环。（工号C6621 徐杰）=====
*计数循环执行的次数是一定的。
'''计数循环Java示例代码'''
<pre> 
   public static void main(String[] args) {
        int count = 0;//定义一个计数器变量
        for (int i = 1; i <= 1000; i++) {
            if (i % 3 == 1 && i % 5 == 3 && i % 7 == 5) {
                System.out.println(i);
                count++;//每次符合要求后计数器都+1
            }
        }
        System.out.println(count);
    }
</pre>
*连续求值的循环预先并不知道要执行多少次，它会在每次循环遍历时判断是否应该结束。
'''连续求值的循环Java示例代码'''
<pre>
    public static void main(String[] args) {
	for (int i = 1; i < 10; i = i + 1) {
		System.out.println(i);
	}
    }
</pre>
*无限循环一旦启动就会一直执行。多用在心中起搏器、微波炉和导航控制仪中。
'''无限循环Java示例代码'''
<pre>
     for(int i=1;;i++){
	System.out.println(i);
     }
</pre>
*迭代器循环对容器类里面的每个元素执行一次操作。
'''迭代器循环Java示例代码'''
<pre>
       public static void main(String[] args) {
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
		arrayList.add(1);
		arrayList.add(2);
		arrayList.add(3);
		Iterator iterator = arrayList.iterator();
		while (iterator.hasNext()) {  //迭代器遍历查询，判断是否还有值可以显示
			System.out.println(iterator.next());
		}
	}
</pre>
=====把检查放在循环结尾处，循环就会至少执行一次。（工号C6621 徐杰）=====
*把检查放在循环开始处，那么它的循环体就不一定会执行。
*如果是放在中间检查，那么检查前面的那一部分至少执行一次，检查后面部分就不一定会执行到。
=====循环次数不确定时用while循环。（工号C6621 徐杰）=====
*while循环有do while（直到型循环）和while（当型循环）
**当你需要一个灵活的循环且该循环至少被执行一次，那么你就可是用一个在结尾处做条件检测的while循环。
=====灵活度和检查位置决定选择循环的种类。（工号C6621 徐杰）=====
*循环的种类列表如下：
{| class="wikitable"
! 语言
! 循环的种类
! 灵活度
! 检查位置
|-
| Visual Basic
| For-Next
| 严格
| 开始
|- 
| 
| While-Wend
| 灵活
| 开始
|- 
| 
| Do-Loop-While
| 灵活
| 开始或结尾
|- 
| 
| For-Each
| 严格
| 开始
|- 
| C,C++,C#,Java
| for
| 灵活
| 开始
|- 
| 
| While
| 灵活
| 开始
|- 
| 
| do-While
| 灵活
| 结尾
|- 
| 
| foreach
| 严格
| 开始
|}
=====当循环条件检测在循环开始或结尾处时，我们就要用带退出的循环。（工号C6621 徐杰）=====
*带退出的循环就是循环终止条件出现在循环中间而不是在开始或者结尾处。
**C++,C和Java中可以用break语句退出当前循环。在其他语言中也可以用goto实现。正常的带退出循环由循环头、循环体（包括终止条件）和循环尾组成。
**Java中使用循环语句时，只有循环条件表达式的值为false时，才能结束循环。有时，我们想提前中断循环，要实现这一点，只需要在循环语句块中添加break或continue语句。break（退出整个循环）、continue（退出本次循环，进入下一次循环）。“break;”语句：可以出现在while、do…while、for、switch语句体中。“continue;” 语句：只能出现在循环语句while、do…while、for中。
*'''坏代码'''
<pre> 
   // Compute scores and ratings.
   score = 0;
   GetNextRating( &ratingIncrement );
   rating = rating + ratingIncrement;
   While ( (score < targetScore ) && ( ratingIncrement != 0 ) ) {
        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement; 
        //7，8行与上面的3,4行重复，维护时会出现问题（上下两组代码需同步修改容易忘记）。解决办法写个带退出的条件。
    }
</pre>
*'''好代码'''
<pre> 
   // Compute scores and ratings.The code uses an infinite loop
   // and a break statement to emulate a loop-with-exit loop.
   score = 0;
   While ( true ) {
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement;

        if ( !( (score < targetScore ) && ( ratingIncrement != 0 ) ) ) { //写了退出循环的条件，容易维护。
            break;  //满足if条件时退出循环。
        }

        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
    }
</pre>
=====循环次数固定时用for循环。（工号C6621 徐杰）=====
*用for循环来执行那些不需要循环内部控制的简单操作。
**使用for循环的好处是你在循环头处写好它之后就可以忘掉它了，无需在循环的内部做任何事情去控制它。
**不要在for循环里通过直接修改下标值得方式迫使它终止，这种情况应该用while循环。
=====foreach循环简化数组和集合的遍历。（工号C6621 徐杰）=====
*foreach循环优势是消除了循环内务处理算术，从而也就消除了任何由循环控制算术导致出错的可能性。 
*'''代码示例'''
<pre>
int[] str = { 1, 2, 3, 4, 5, 6, 7, 8 };
int i =0;
foreach (int s in str)
{
   if (i < 5)
   {
      MessageBox.Show(s.ToString());
      i++;
   }
   else
   {
      break;
   }
}
</pre>
*foreach语句的局限性是如果要引用数组或者集合的索引，则foreach语句无法做到，foreach仅仅老老实实地遍历数组或者集合一遍。
=====while与do while 区别与联系         （C6618 陈渊）=====
* while语句格式
<pre>
  While(条件表达式)
<pre>
  {
             执行语句；
}
</pre>

* do while 语句格式
<pre>
  do
{
      执行语句；
}while(条件表达式)；
</pre>

*while与do while 最大的区别由例子可以看出：
<pre>
int i=0;
while(i>0){
    System.out.println("0");
}
//这样不输出；

int i=0;
do{
    System.out.println("0");
}while(i>0)
//这样输出结果是0
</pre>

*联系：它们都是循环语句，都可以判别条件，执行循环体，都具有循环体的一般特性。<br>
*区别：while 先判断条件，只有条件满足才执行循环体。do while 先执行循环体，再判别条件，条件满足，再执行循环体。总之一句话：do while无论条件是否满足，循环体至少执行一次。

=====for与while的区别与联系         （C6618 陈渊）=====
*for语句格式:
<pre>
 for(初始化表达式；循环条件表达式；循环后的操作表达式)

   {
           执行语句；
}
</pre>
*相互转换的小例子:
<pre>
int main(void)
{
    int i,sum = 0;
    for(i=1;i<=100;++i)
    sum+=i;
    printf("%d\n", sum);
    return 0;
}

int main(void)
{
    int i = 1,sum= 0;
    while(i<=100)
    {
        sum+=i;
        ++i;
    }
    printf("%d\n", sum);
    return 0;    
}
</pre>

*联系：for与while都可以用来表示循环结构，一般在内存比较大的情况下，它们之间可以替换。<br>
*区别：变量有自己的作用域，对于for来讲：如果将用于控制循环的增量定义在for语句中，那么该变量只在for语句内有效。For语句执行完毕。该变量在内存中被释放。for和while可以进行互换。如果需要定义循环增量。用for更为合适。
=====何时使用for循环何时使用foreach循环         （工号C6618 陈渊）=====
*for循环的使用（工号C6618 陈渊）
for的语句格式：
<pre>
for(表达式1;表达式2;表达式3){
    循环语句
}
或者更直观的表示为这样：
for(变量初始化;循环条件;迭代语句){
    循环语句
}
</pre>
for循环的执行流程是：首先执行表达式1，一般是进行变量初始化操作，然后执行表达式2，即对循环条件进行判断，如果结果为真，则执行循环体；循环体执行完毕后，执行表达式3，改变循环变量的值，再次执行表达式2；结果为真，继续循环；如果结果为假，则终止循环，执行后面的语句。无论执行多少次，表达式1仅执行一次。

代码示例：
<pre>
/**
*计算1到100的和
*/
public class Summation {

    public static void main(String[] args) {
        int sum = 0; //声明变量sum存放计算的和，赋初值为0
        for(int i=1;i<=100;i++)
            sum +=i;//等价于语句sum=sum+score
        System.out.println("sum="+sum);
    }

}
</pre>

*foreach循环的使用（工号C6618 陈渊）
foreach语句是for语句的特殊简化版本，但是foreach语句并不能完全取代for语句，然而，任何的foreach语句都可以改写为for语句版本。
foreach的语句格式：
<pre>
for(元素类型t 元素变量x : 遍历对象obj){

     引用了x的java语句;
}
</pre>

代码示例：
<pre>
public class ForEachTest
{
public static void main(String[] args)
{
String[] books = {"java","c","c++","c#","asp"};
for(String book : books)
{
System.out.println(book);
}
}
}
</pre>
*何时使用for循环何时使用foreach循环（工号C6618 陈渊）
上述已经说到任何的foreach语句都可以改写为for语句，所以说for循环更通用，但是在很多时候使用foreach循环会很省事，那么怎么判断何时使用for循环何时使用foreach循环,其实和简单foreach循环有一个很大的特点就是你可以一个容器内的全部元素都做相同的操作。就像上面那个例子，books看做一个容器，里面有各种各样的书，都做输出书的操作这样用foreach循环用就特别省力。当你想精确控制循环的过程，对每个元素要做不同操作的时候，就必须用for循环。

====带退出的循环（工号C6609 黄佳欣）====
*一个带退出循环通常由循环头，循环体（包括）和循环尾组成，如：
<pre>
Do
	...
	if( some exit condition ) Then Exit Do
	...
Loop
</pre>
下面是应该带退出循环，但没有用的例子。<br>
'''坏代码：'''
<pre>
score = 0;
GetNextRating( &ratingIncrement );
rating = rating + ratingIncrement;
while((score < targetScore) && ( ratingIncrement !=1)){
	GetNextScore( &scoreIncrement );
	score = score + scoreIncrement;
	GetNextRating( &ratingIncrement );
	rating = rating + ratingIncrement;
}
</pre>
'''好代码：'''
<pre>
score = 0;
GetNextRating( &ratingIncrement );
rating = rating + ratingIncrement;
while( true ){
	GetNextRating( &ratingIncrement );
	rating = rating + ratingIncrement;
	if((score < targetScore) && ( ratingIncrement !=1)){
		break;
	}
	GetNextScore( &scoreIncrement );
	score = score + scoreIncrement;
}
</pre>
====非正常的带退出循环（工号C6609 黄佳欣）====
*非正常的带退出循环，另一种利用带退出循环避免一个半循环的情况。
'''坏代码：'''
<pre>
goto Start;
while( expressing ){
	//do something
	...
	Start:
	//do something else
	...
}
</pre>
'''好代码：'''
<pre>
while（true）{
	//do something else
	...
	if(!(expression)){
		break;
	}
	//do something
	...
}
</pre>
====什么时候使用for循环（工号C6609 黄佳欣）====
*在适当的情况下多使用FOR循环，FOR循环把循环的控制代码集中在一起，从而有助于写成可读性强的循环。
'''坏代码：'''
<pre>
i = 0;
a = 0;
while（i<100）{
	a = a+ i;
	i++;
}
</pre>
'''好代码：'''
<pre>
a = 0;
for(i = 1;i<100;i++){
	a = a+ i;
}
</pre>


====16.2 循环控制                （徐杰）====
=====代码进入循环的五大指导原则。（工号C6621 徐杰）=====
#只从一个位置进入循环。
#把初始化代码紧放在循环前面。
#用while(true)表示无限循环。
#在适当的情况下多使用for循环。
#在while循环更适用的时候，不要用for循环。
=====用“{”和“}”把循环中的语句括起来。（工号C6621 徐杰）=====
*任何时候都要在代码中使用括号。它们是一种很好的预防性编程实践。
=====不要写空循环。（工号C6621 徐杰）=====
*不要把循环处理的代码和检测循环是否终止的代码写在一起。
*'''坏代码'''
<pre>
while (（inputChar = dataFile.GetChar() ) != CharType_Eof ) {
;//循环的操作和循环的检测写在了一起
}
</pre>
*'''好代码'''
<pre>
do {
    inputChar = dataFile.GetChar();//循环操作
}while （inputChar != CharType_Eof );//循环检测分开
</pre>
=====把循环内务操作要么放在循环开始，要么放在循环末尾。（工号C6621 徐杰）=====
*循环内务操作是指像i++或者i=i+1这样的表达式，它们的目的是控制循环。
=====一个循环只做一件事。（工号C6621 徐杰）=====
=====你写的循环是要能够终止的。（工号C6621 徐杰）=====
=====循环的条件控制语句要放在一起。（工号C6621 徐杰）=====
=====不要为了终止循环而胡乱改动for循环的下标。（工号C6621 徐杰）=====
*一旦写好for循环，那么它的循环计数器i就不受你的控制了。
*想要更多的控制退出条件，可以使用while循环。
*'''坏代码'''
<pre>
for ( int i = 0; i < 100; i++ ) {
    ... //some code
    if ( ... ) {
       i = 100;//随便改动i的值，赋值100来终止循环
    }
    ... // more code
}
</pre>
=====不要出现依赖于循环下标最终取值的代码。（工号C6621 徐杰）=====
*'''坏代码'''
<pre>
for （ recordCount = 0;recordCount < MAX_RECODES;recordCount++ ）{
    if ( entry[ recordCount ] == testValue ){
       break;
    }
}
// lots of code
...
if ( recordCount < MAX_RECODES ) { //滥用循环索引的终止值,容易出现大小差一的错误
   return( true );
} else {
   return( false );
}
</pre>
*'''好代码'''
<pre>
found = false;
for （ recordCount = 0;recordCount < MAX_RECODES;recordCount++ ）{
    if ( entry[ recordCount ] == testValue ){
        found = true; //使recordCount使用局部化，使用布尔变量found循环清晰不出错
        break;
    }
}
// lots of code
...
return( found );
</pre>
=====合理使用安全计数器。（工号C6621 徐杰）=====
*安全计数器是一个变量，每次循环时递增，来判断循环执行次数是不是过多。
*'''坏代码'''
<pre>
do { 
    node = node -> Next;//指向node的下一个节点值
    ...
} while (node -> Next != NULL);//node不为空，会发生死循环
</pre>
*'''好代码'''
<pre>
sCounter = 0;
do { 
    node = node -> Next;
    ...
    sCounter++;   //安全计数器递增
    if ( sCounter >= SAFETY_LIMT ) {  //判断范围循环次数有没有超出安全
        Assert( false,"超出安全计数范围" );
    }
    ...
} while (node -> Next != NULL);
</pre>
=====在while循环中尽量使用break语句退出循环而不用布尔标记。（工号C6621 徐杰）=====
*'''坏代码'''
<pre>
boolean flag=true;//定义布尔变量
int a[]={11,1,3,10,5};
int i=0;
while(flag) {
     if(a[i]<10){
     flag=false;
     System.out.println(a[i]+"程序中止！");
     }else{
     i++;     
     flag=true; //多层次，使循环复杂难理解
     }
}
</pre>
*'''好代码'''
<pre>
int a[]={11,1,3,10,5};
while(i<6) {
	if(a[i]<10){
             break;//简化循环控制
	     i++;
        }
}
System.out.println(a[i]+"程序中止！");
</pre>
=====不要用有很多break的循环。（工号C6621 徐杰）=====
*大量使用break的循环，可以更换成用一系列的循环来表达，更清晰。
*'''坏代码'''
<pre>
do { 
    ...
    switch
       ...
       if () {
           ...
            break; //break退出if把switch也退出了
           ...
       }
       ...
}while ( ... );
</pre>
=====在循环开始处使用continue进行判断。（工号C6621 徐杰）=====
*continue在循环开始处，使得做完条件判断后可让代码越过剩下的循环体继续执行。
*'''Java代码'''
<pre>
for(int i=1;i<50;i++) {
   
      if((i%2)==0){
        
       continue;
   
}      
System.out.print(i+" ");
}
 
</pre>
=====如果语言支持，请使用带标号break结构。（工号C6621 徐杰）=====
*Java支持使用带标号break语句，可以在for循环、if语句或者任何大括号里的代码段中使用。
*'''Java代码'''
<pre>
do { 
    ...
    switch
       ...
       CALL_CENTER_DOWN:
       if () {
           ...
            break CALL_CENTER_DOWN; //这里的标号使得break语句的退出一目了然
           ...
       }
       ...
}while ( ... );
</pre>
=====使用break和continue时要小心。（工号C6621 徐杰）=====
*Java中中断语句 — break
**break语句用于终止某个语句块的执行。用在循环语句体中，可以强行退出循环。
**“break;”语句：可以出现在while、do…while、for、switch语句体中。**“break label”语句 ：可以出现在任何语句体中。
*'''Java代码'''
<pre>
public class Test {
    public static void main(String[] args) {
         outer: for (int i = 0; i < 10; i++) {
             System.out.println("Outer loop");
             inner: while (true) {
                  Scanner sc = new Scanner(System.in);
                  String s = sc.next();
                  System.out.println("inner Loop:" + s);
                  if (s.equals("hello"))    
                   break inner;
                  if (s.equals("kitty"))
                       break outer;
            }
        }
    }
}
</pre>
*Java中中断语句 — continue
**continue语句用在循环语句体中，用于终止某次循环过程，跳过循环体中continue语句下未执行的循环，开始下一次循环过程。
**“continue;” 语句：只能出现在循环语句while、do…while、for中。
*'''Java代码'''
<pre>
for(int i=1;i<50;i++) {
    if((i%2)==0){
         continue;
    }  
    System.out.print(i+" ");
}
</pre>
=====用整数或者枚举类型表示数组和循环边界。（工号C6621 徐杰）=====
*通常情况，循环计数器是整数。浮点数递增时会有问题，可能出现死循环。
=====在嵌套循环中要使用有意义的变量名。（工号C6621 徐杰）=====
*'''坏代码'''
<pre>
for ( i = 0; i < teamCount; i++) {
    for ( j = 0; j < eventCount[teamIndex]; j++) {
        score[i][j] = 0;
    }
}
</pre>
*'''好代码'''
<pre>
for ( teamIndex = 0; teamIndex < teamCount; teamIndex++) {
    for ( eventIndex = 0; eventIndex < eventCount[teamIndex]; eventIndex++) {
        score[teamIndex][eventIndex] = 0;
    }
}
//score[teamIndex][eventIndex] 比 score[i][j]给出的信息更多。
</pre>
=====用有意义的名字来避免循环下标串话。（工号C6621 徐杰）=====
*习惯性地使用i、j和k会导致下标串话，也就是同一变量名用途不同。
*'''坏代码'''
<pre>
for ( i = 0; i < numPayCodes; i++) { //i在这里首次用到
    // lots of code
    ...
    for ( j = 0; j <12; j++) {
        // lots of code
        ...
        for ( i = 0; i < numDivisions; i++) { //这里又出现i，重复
       CALL_CENTER_DOWN:
       sum = sum + transaction[j][i][k]
       }
     }
}
</pre>
*'''好代码'''
<pre>
recordCount = 0;
while ( moreScores() ) {
    score[recordCount] = GetNextScore();
    recordCount++;// 使用 recordCount
}
</pre>
=====把循环下标变量的作用域限制在本循环内。（工号C6621 徐杰）=====
*这项准则可以获得语言的内建机制的支持，例如在循环头声明下标变量：
*C++代码示例
<pre>
for ( int recordCount = 0; recordCount < MAX_RECORDS;recordCount++ ) { 
        // looping code that uses recordCount
}//在for循环内部声明循环下标变量
</pre>
*C++代码示例
<pre>
for ( int recordCount = 0; recordCount < MAX_RECORDS;recordCount++ ) { 
        // looping code that uses recordCount
}
// intervening code
for ( int recordCount = 0; recordCount < MAX_RECORDS;recordCount++ ) { 
        // additional looping code that uses a different recordCount
}//在for循环头部声明下标，则recordCount变量的作用域不会超出for循环，安全的重用这个变量。
</pre>
*但请不要太依赖这条准则，循环变量还是要有意义的名字且避免重复。
=====保持循环简单便于其他人阅读你的代码。（工号C6621 徐杰）=====
*保持循环简单的技巧包括：避免使用怪异的循环、减少嵌套层次、让入口和出口一目了然、把内务操作代码放在一起。
*'''坏代码'''
<pre>
if (score > 60){
	if(score > 80）{
		if(score > 90){
			System.out.println("成绩非常优秀");
    		}
		else{
			System.out.println("成绩优秀");
		   }
	     }
	else{
		System.out.println("成绩良好");
	}
else{
	System.out.println("成绩不及格");
}
</pre>//循环嵌套复杂，代码不便于阅读
*'''好代码'''
<pre>
if (score > 90){
	System.out.println("成绩非常优秀");
}
else if (score > 80){
	System.out.println("成绩优秀");
}
else if (score > 60){
	System.out.println("成绩良好");
}
else{
    System.out.println("成绩不及格");
}//减少了循环嵌套，使代码更加简洁
</pre>
=====for循环在Java中增强版。（工号C6621 徐杰）=====
*新声明块变量，这是一种与正在访问数组中的元素兼容的。变量将是可利用的块内并且它的值将是相同的作为当前的数组元素。
*这个计算结果完成需要循环数组。表达式可以是一个数组变量或方法调用返回一个数组。
*Java代码for循环一般写法示例
<pre>
/* 建立一个数组 */
 int[] integers = {1， 2， 3， 4};
 /* 开始遍历 */
 for (int j = 0; j < integers.length; j++) {
     int i = integers[j];
     System.out.println(i);
 }
</pre>
*Java代码for循环简单写法示例
<pre>
 int[] integers = {1， 2， 3， 4};//建立一个数组

 for (int i : integers) {//开始遍历
     System.out.println(i); /* 依次输出“1”、“2”、“3”、“4” */
 }
</pre>
=====把初始化代码紧放在循环前面         （C6620 刘思）=====
一旦把循环放到更大的循环中，会忘记移动或复制初始化代码，修改的时候可能忽略造成不正确的修改。
*把循环初始化语句和它相关循环放一起，运用或修改的时候容易避免出错。
好的代码
 int main()
 {
     int i=0;
     int sum=0;
     for(i;i<=100;++i)//
     {
         sum+=i;
     }
     int j=0;
     int sum1=0;
     for(int j=0;j<=100;++j)//
     {
         sum+=j;
     }
     printf("%d",sum,sum1);
     return 0;
 }
不好的代码
 int main()
 {
     int i=0;
     int j=0;
     int sum=0;
     int sum1=0;
     for(i;i<=100;++i)//
     {
         sum+=i;
     }
     for(int j=0;j<=100;++j)//
     {
         sum+=j;
     }
     printf("%d",sum,sum1);
     return 0;
 }
=====减少能影响该循环各种因素的数量，把循环内部当做一个子程序看待  （C6620 刘思）=====
把控制尽可能地放到循环体外。把循环体执行的条件表述清楚。不要让读者看了循环体以后才明白循环的控制。
*应该把循环看做是一个黑盒子：外围程序只知道它的控制条件，却不知道它的内容。
<pre>
 while( !inputFile.EndOfFIle() && moreDataAvailable){ 
         ************************************
          *                  *  
         *             黑盒子          *  
         *                  *  
        ************************************
 }  
</pre>
循环终止条件inputFile.EndOfFIle()为真，要么moreDataAvailable为假，这就是你所需要知道的全部。
阻止忽略或错误地对循环执行初始化、忽略了对累加变量或其他与循环有关的变量执行初始化、不正确的嵌套、不正确的循环终止、忽略或者错误地增加了循环变量的值、以及不正确的循环下标访问数组元素等错误。
=====尽可能多使用for循环        (C6620 刘思)=====
*for语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，它将循环控制语句集中放在一起，比while更紧凑因此修改起来更加容易。
=====不要滥用for循环    （C6620 刘思）=====
好的代码
<pre>
 c++示例：while循环的适当用法
 inputeFile.MoveToStart()；
 recordCount=0；
 while(!inputeFile.EndOfFile()){
	inputeFile.GetRecord();
	recordCount++;
 }
</pre>
不好的代码
<pre>
 c++示例：胡乱把while循环体填充到for循环头
 for(inputeFile.MoveToStart(),recordCount=0;inputeFile.EndOfFile();recordCount++)
 {
	inputeFile.GetRecord();
 }
</pre>
recordCount的语句并不控制循环，不应该放在循环头。
<pre>
 c++示例：规则的循环头部但不适用
 recordCount=0
 for(inputeFile.MoveToStart();
 !inputeFile.EndOfFile();
 inputeFile.GetRecord())
 {
	recordCount++;
 }
</pre>
虽然循环初始化语句inputeFile.MoveToStart()，循环条件!inputeFile.EndOfFile()，终止语句inputeFile.GetRecord()都有了，但是不直观用while循环更合适。
=====在嵌套循环中使用有意义的便利名来提高代码可读性   (C6620  刘思)=====
*有意义的数组下标名字既能表明循环用途，也能表明数组的用途
好代码
<pre>
JAVA示例：差劲的循环变量
for(int i=0;i<numPayCodes;i++){
	for(int j=0;j<12;j++){
		for(int k=0;k< numDivision;k++){
			sum=sum+transaction[j][i][k]
		}
	}
}
</pre>
不好的代码
<pre>
JAVA示例：好的的循环变量
for(int payCodeIdx=0; payCodeIdx < numPayCodes; payCodeIdx++){
	for(int month =0;month<12;month++){
		for(int divisionIdx = 0;divisionIdx < numDivision;divisionIdx++){
			sum=sum+transaction[month][payCodeIdx][divisionIdx]
		}
	}
}
</pre>
计算机能同样轻松阅读这两种循环，但显然第二种人更容易读懂，移植性也好。
=====高效和低效程序员之间的一项关键差别：是否愿意执行检查端点。（工号C6620 刘思）=====

*对于一个简单循环，需要注意三种情况：开始的情况，任意选择的中间情况，以及最终的情况。
在你创建循环的时候，应在本子上画画，脑海里运行这三种循环的情况，以确认该循环不会出现任何off-by-one错误。
=====循环应该多长  （C6619 何刚）=====
*'''循环要尽可能的短'''
循环要尽可能的短，以便一目了然。如果显示器显示能够显示50行代码那么就应该把循环的长度限制在50行以内，这样方便能够一目了然的看循环。但是在接受编写简单代码这一原则后，那就很少会写出超过15行或者20行的循环。
附：语句构造的原则:简单直接，不能为了追求效率而使代码复杂化。为了便于阅读和理解，不要一行多个语句。不同层次的语句采用缩进形式，使程序的逻辑结构和功能特征更加清晰。要避免复杂的判定条件，避免多重的循环嵌套。表达式中使用括号以提高运算次序的清晰度等等。

*'''把嵌套限制在3层以内'''
    在嵌套超出3层以后，程序员对循环的理解能力会极大的降低。如果嵌套层次超出3层，那么就应该通过把某一部分提取为子程序或者简化控制结构的方式来缩短它。
*'''''坏代码'''''
<pre>
if (10 < quantity){
	if(100 < quantity）{
		if(1000 < quantity){
			discount = 0.01;
    		}
		else{
			discount = 0.05;
		   }
	     }
	else{
		discount = 0.025;
	}
else{
	discount = 0.0
}
</pre>
    这段代码的主要问题是判断逻辑组织的很差使得判断中有许多冗余。当判断了quantity是否大于1000的时候，就不需要再去判断他是否大于100并且大于10。因此可以重新组织这段代码：
*'''''好代码'''''
<pre>
if (1000 < quantity){
	discount = 0.01;
}
else if (100 < quantity){
	discount = 0.05;
}
else if (10 < quantity){
	discount = 0.025;
}
else{
discount = 0.0;
}
</pre>

*'''把长循环的内容移到子程序里'''
如果循环设计的好，那么通常可以把循环体内的代码移到一个或几个子程序里，并在循环体内加以调用。

*'''要让长循环退出条件等格外清晰'''
    循环的长度会增加代码的复杂度。如果写的是短循环，那么可以使用break、continue、多个出口、复杂的终止条件等控制结构。如果循环较长，并担心代码的可读性，那么就要给它写一个单一出口，并要保持退出条件清晰无误。
=====进入循环(工号c6618 陈渊)=====
*只从一个位置进入循环：一个循环分为循环头，循环体，循环尾,最好从循环头进入该循环（工号C6618 陈渊）
*把初始化代码紧放在循环体前面：主张把相关的语句放在一起，如果相关语句分散在各个子程序中，就很容易忽略掉他们，导致不正确的改修。（工号C6618 陈渊）
*用while（true）表示无限循环：当我们需要一个不需要终止的循环，我们可以使用while（true）这是一个普遍认同的写法
另外也可以用for( ; ; )（工号C6618 陈渊）
*在适当情况下多用for()循环 因为在改修起来for（）循环相关代码都在顶部，改修方便，不想while循环要改修顶部和底部这样容易遗漏（工号C6618 陈渊）
代码示例：
<pre>
int main(void)
 {
     int i,sum = 0;
     for(i=1;i<=100;++i)
     sum+=i;
     printf("%d\n", sum);
     return 0;
</pre>
<pre>
 int main(void)
 {
     int i = 1,sum= 0;
     while(i<=100)
     {
         sum+=i;
         ++i;
     }
     printf("%d\n", sum);
     return 0;    
 }
</pre>
上面分别用for和while写的一个加到一百的例子，但是如果判断的条件和，和循环后的操作发生变更，for循环只要在之后的括号里修改
而while既要在while的后修改，在循环体里也要修改，这样会增加出错的几率。

*在while循环更适用的时候，不要使用for循环（工号C6618 陈渊）
坏代码（胡乱的把while循环体填充到for循环头）：
<pre>
for(inputFile.MoveToStart(),recordCount=0;!inputFile.EndOfFile();recordCount++){
inputFile.GetRecord();
}
</pre>
改良版：
<pre>
recordCount=0;
for(inputFile.MoveToStart(),!inputFile.EndOfFile();recordCount++){
inputFile.GetRecord();
}
</pre>
但是如果使用while就回非常合理：
<pre>
inputFile.MoveToStart();
recordCount=0;
while(!inputFile.EndOfFile()){
inputFile.GetRecord();
;recordCount++;
}
</pre>


=====处理好循环体（工号c6618 陈渊）=====
*避免空循环（工号C6618 陈渊）
空循环：
<pre>
while（（inputChar=dataFileGetChar()）!=CharType_Eof){
    ;
}
</pre>

产生这个空循环的原因在意while后的判断其实有两个操作，一个等于和一个不等操作，如果把它们分开来
那看起来就回很舒服

<pre>
do{
inputChar=dataFileGetChar();
}
while（inputChar!=CharType_Eof);
</pre>

*把循环内的操作要么放在循环开始，要么放在循环末尾（工号C6618 陈渊）
代码示例：
<pre>
nameCount=0;
//放在循环开始
while(!inputing.EndOfFile()){
input>>inputString;
names{nameCount}=inputString
...


//放在循环末尾
nameCount++;
}
</pre>

*一个循环只做一件事（工号C6618 陈渊）
循环应该和子程序一样，每个循环只做一件事并且把它做好，如果用两个循环会导致效率低下，而且使用一个循环更合适。

=====循环应尽可能简洁（工号C6616 兰杰）=====
*循环要尽可能的短，一遍能够一目了然
*把嵌套控制在三层以内
*把长循环移到子程序中
*要让长循环格外清晰
*'''''好例子'''''
<pre>
ass For99Multiple {
    public static void main(String[] args){
     for(int i=1;i<10;i++){
        for(int j=1;j<=i;j++){
        System.out.printf("%d*%d=%2d\t",i,j,i*j);
       }
        System.out.println();
    }
  }
}
</pre>
这个例子简洁明了，两个for循环输出了一个九九乘法表。
*'''''坏例子'''''
<pre>
if(p[r][c]==1){         //如果击中
lings(b);
  for(k=0;k<48;k++){
    if(a[r][c][k]==1){
        type++;
  for(i=0;i<7;i++){
     for(j=0;j<7;j++){
        b[i][j]=b[i][j]+a[i][j][k];  //进行了多层循环和判断
   }
 }
}
</pre>
这个例子用了多层循环和if判断嵌套，可读性比较低，而且加大了理解的难度。


=====使用循环应注意细节（工号C6616 兰杰）=====
*保持简单循环有助于别人阅读你的代码
*避免使用怪异的循环，减少嵌套层次。
*让入口有和出口一目了然，把内务操作代码放在一处
*命名要准确，且各自用于一个用途。
*仔细考虑循环，确保在每一种情况下正常运行和退出。

====16.3 轻松创建循环——由内而外   （刘思）====
=====从简单情况开始并由内向外生成代码能轻松创建循环。=====
所谓由内而外就是从一种情况开始，用字面量（literal）来编写代码。然后缩进它，在外面加上一个循环然后用循环下标或计算表达式替换那些字面量。最后加上所需要的初始化。比如需要写一个能从列表中取得每个人的费率并累加的循环。
*首先，在注释里写下循环体要执行的操作步骤。先不考虑语法，下标等细节，把要做的事情先写下来。
 第1步：由内而外创建循环（伪代码示例）
 --get rate from table    (从表中取得费率)
 --add rate to total      (将费率加到总和上)
*然后，尽可能把循环体内注释转化成代码。
 第2步：由内而外创建循环（伪代码示例）
  rate = table[]     //table为存有费率数据的数组，现在table还没任何下标，
  totalRate = totalRate + rate //rate为表中取出的个人费率，totalRate为存储总费用
*接下来，往table数组里加入下标：
 第3步：由内而外创建循环（伪代码示例）
 rate = table[census.Age][census.Gender] //census存储个人信息的结构体
 totalRate = totalRate + rate
*接下来是给现有语句加上一层循环。缩进现有代码，并放在一个begin-end对里。
 第4步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census.Age][census.Gender]
  totalRate = totalRate + rate
 End For
*本列中，census变量随person而变，所以要适当推广（generalized）它。
 第5步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*最后，写出必要的初始化代码
 最后一步：由内而外创建循环（伪代码示例）
 totalRate = 0
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*要点在于从具体事件入手，在同一时间只考虑一件事，以及从简单的部分开始创建循环。
====16.4 循环和数组的关系         （刘思）==== 
====循环和数组之间有着密切的联系，选择好语言可免去繁琐的循环。====
*编程是来解决问题的，有时候解决方案是特定于语言的。所选择的开发语言将很大程度上影响到你的解决方案。
JAVA示例：数组乘法
<pre>
 for (int row = 0; row < maxRows; row++){
        for (int row = 0; row < maxCols; column++){
	     product[row][column]=a[row][column]*b[row][column]
	}
 }
</pre>
APL示例：数组乘法
 product <- a * b
可见APL代码更加简单，更不容易出错。它只用了3个操作符，而相应的JAVA用了17个之多。
*所以编程之前应该研究继而选择更为适合的语言。比如APL和Fortran 90 以及其后续版本提供了强大的数组操作功能。

=====使用循环操纵数组方便快捷（工号C6616 兰杰）=====
循环和数组有着密切的关系，许多情况下循环被用来操纵数组，并且循环计数器和
数组下标对应，使用起来很方便。
*'''''坏例子：不使用循环遍历数组a[10]'''''
<pre>
 printf("%d",a[1])
 printf("%d",a[2])
 printf("%d",a[3])
......
</pre>
非常麻烦，如果数组太大，会非常浪费时间。

*'''''好例子：for循环遍历数组a[10]'''''
<pre>
for(i=0;i<10;i++){
  printf("%d",a[i])
}
</pre>
简单快捷，一个for循环就可以遍历数组。
=====进入循环(工号 C6622 李腾飞）=====
只从一个地方进入循环，初始化代码紧放在代码前边，就近原则把相关代码放在一起。适当的情况下多用for循环--条件循环都在头部,相对于while还要修改底部更好维护。											
=====更适合while的时候不要用for(工号C6622李腾飞)=====											
'''for循环'''											
<pre>											
recordCount=0;											
for(inputFile.MoveToStart(),!inputFile.EndOfFile();inputFile.GetRecord())											
{											
recordCount++;											
}											
</pre>											
'''while循环'''											
<pre>											
recordCount=0;											
while ( !inputFile.EndOfFile() )											
{											
inputFile.GetRecord();											
recordCount++;											
}											
</pre>											
对比可以看出，while循环更加清晰。											
=====避免空循环（工号C6622李腾飞）=====											
<pre>											
while ( (inputChar = cin.get() ) != '\n' ） {											
；											
}											
</pre>											
这条语句产生空循环是因为while表达式包含了两项操作，改进后如下：											
<pre>											
do {											
inputChar = cin.get();											
} while ( inputChar != '\n' );											
</pre>											


=== 第17章 不常见的控制结构===

====17.1 子程序中的多处返回       （郭思）==== 
　　程序可以通过return和exit在任何时候退出子程序。比如C++和Java中的return，VB中的Exit Sub和Exit Function。Java中的return一般就是在有返回值的方法中，用来返回方法指定类型的值，同时结束方法执行；也可以在返回值为void的方法中，用来终止方法运行。
=====使用return增强可读性=====
　　如果得到了想要的答案，就可以立即返回该值到调用方子程序，让读者更容易理解。
*'''''好代码'''''
<pre>
Comparison Compare(int value1,int value2){  //返回Comparison枚举类型
  if(value1<value2){
     return Comparison_LessThan;  //小于
  }
  if(value1>value2){
     return Comparison_GreaterThan;  //大于
  }
  return Comparison_Equal;  //相等
}
</pre>
=====用防卫子句（早返回或早退出）简化复杂的错误处理=====
　　当遇到复杂的错误处理，比如在执行某段正常代码之前要进行大量的错误条件检测时，如果用if...End if...循环嵌套的话，代码的缩进层次会过深，并且正常代码不容易查看。
*'''''坏代码'''''
<pre>
if file.validName() Then
   if file.Open() Then
      if encryptionKey.vaild() Then
         if file.Decrypt(encryptionKey) Then
            'lost of code //正常执行的代码;被遮蔽了
            ...
         End if
      End if
   End if
End if
</pre>
　　这时，我们可以在执行正常代码之前先检查错误条件，有错误则停止当前子程序的运行。这样，代码的布局清晰，画面美观。
*'''''好代码'''''
<pre>
if Not file.validName() Then Exit Sub
if Not file.Open() Then Exit Sub
if Not encryptionKey.vaild() Then Exit Sub
if Not file.Decrypt(encryptionKey) Then Exit Sub
'lost of code  //正常执行的代码
...
</pre>
=====减少子程序中return的数量=====
　　如果读子程序的后部时，没有意识到前面某个地方返回的可能性，就很难理解这个子程序。只有在可以增强可读性的时候使用return，尽可能少的使用return。
=====如果能增强可读性，知道了结果就返回（工号C6595 时昌彬）=====
*在某些子程序中，一旦知道了答案，就该返回，；
*如果子程序被定义为检测出错误以后不再做任何更多的清理操作，不马上返回就意味着你还得写更多的代码。
'''Java示例：坏代码'''
<pre>
public string Compare(int value1,int value2 ){
	String re;
	if(value1 < value2 ){
		re = "LT";
	}
	else if(value1 > value2){
		re = "GT";
	}
        else{
		re = "EQ";
	}
	return re;
}
</pre>
'''Java示例：子程序的多处返回——好代码'''
<pre>
public string Compare(int value1,int value2 ){
	String re;
	if(value1 < value2 ){
		re = "LT";
		return re;
	}
	else if(value1 > value2){
		re = "GT";
		return re 
	}
        else{
		re = "EQ";
		return re;
	}
}
</pre>
====17.2 递归                   （郭思）====
　　递归，就是在运行的过程中调用自己。它通常把一个大型复杂的问题转化成一个与原问题相似的规模较小的问题来求解，递归只需少量的程序就可以描述出多次的重复计算，大大的减少了程序的代码量。
=====确认递归能够停止=====
　　检查子程序，确认其中含有一条非递归的路径，防止产生无穷递归。这意味着子程序中有一条判断，可以让递归停止。
*'''示例：使用递归的排序算法'''
<pre>
void QuickSort(int firstIndex,int lastIndex,String [] names){
     if (lastIndex > firstIndex){  //判断，当lastIndex<=firstIndex时，就会停止对自身的调用。
        int midPoint = Partition(firstIndex,lastIndex,names);
        QuickSort(firstIndex,midPoint-1,names);  //调用自身，对数组的前部分进行排序
        QuickSort(midPoint+1,lastIndex,names);  //调用自身，对数组的后部分进行排序
     }
}
</pre>
=====使用安全计数器防止出现无穷递归=====
　　可以用安全计数器来防止无穷递归，该安全计数器必须是不随子程序调用而重新创建的变量，可以用一个类成员变量，或者作为参数传递。
*'''示例：用安全计数器避免无穷递归(作为参数传递)'''
<pre>
Public Sub RecursiveProc(ByRef safetyCounter As Integer)
    If(safetyCounter > SAFETY_LIMIT) Then
        Exit Sub
    End If
    safetyCounter = safetyCounter + 1
    ...
    RecursiveProc(safetyCounter)
End Sub
</pre>
=====把递归限制在一个子程序内=====
　　循环递归（A调用B，B调用C，C调用A）非常复杂，要理解起来很难。如果有循环递归，最好重新设计子程序，把递归放在一个子程序里。如果一定要用循环递归的话，最好使用安全计数器。
=====留心栈空间=====
　　使用递归，无法保证会使用多少栈空间，也很难预测程序在运行期间会怎么样。可以按照下面的步骤来控制程序在运行期间的表现。
#如果使用安全计数器，要考虑该给递归子程序分配多少栈空间。要把计数器的上限设置得足够低，防止栈溢出。
#注意观察递归函数中局部变量的分配情况，特别留意内存消耗大的对象。
=====不要用递归去计算阶乘或者斐波纳契数列=====
　　在许多教科书的中都喜欢用计算阶乘和斐波那契数列来讲解递归，其实，把递归用在这两者中是很愚蠢的。
*'''示例：用递归计算阶乘，不合适'''
<pre>
int Factorial(int number){
    if (number == 1){
        return 1;
    }
    else {
        return number * Factorial(number -1);
    }
}
</pre>
　　这种情况下用递归运行速度慢，无法预测运行期间内存的使用情况，并且更不容易理解。
*'''示例：用循环计算阶乘'''
<pre>
int Factorial(int number){
    int intermediateResult = 1;
    for(int factor = 2; factor <= number; factor++){
        intermediateResult =intermediateResult * factor;
    }
    retuen intermediateResult;
}
</pre>
=====使用安全计数器避免出现无穷递归（工号C6595 时昌彬）=====
'''Java示例：安全计数器避免无穷递归'''
<pre>
public void recursion(int num){ 
	if(num > 100）
	num=num+1;
	recursion(num);       
}
</pre>
*如果你不希望把安全计数器作为明确的参数传递，那么可以使用成员变量。

=====不要用递归去计算阶乘或者斐波纳契数列（工号C6595 时昌彬）=====
'''Java 示例：用递归计算阶乘，坏代码'''
<pre>
int factorial( int number){
	if (number == 1){
        return 1;
	}
	else{
		return number* factorial(number - 1);
	}
}
</pre>
*这样速度慢，无法预测运行期间的内存使用情况，而且更难理解。
'''Java示例： 用循环计算阶乘，好代码'''
<pre>
int factorial(int number){
	int result = 1;
	for(int factor = 2;factor <= number;factor++){
		result = result * factor;
	}
	return result;
}
</pre>  

====17.3 goto                   （兰杰）====
=====要在特定场合下谨慎地使用goto（C6616 兰杰）=====

*goto的坏处
**还有goto的代码很难安排好格式，影响逻辑结构
**goto会破换编译器的优化特性，使流程变得难以分析
*goto的好处
**如果位置恰当，goto可以减少重复的代码
**某些情况下会让代码的运行速度更快，体积更小
**goto用在执行清理操作，可以减少忘记释放资源的可能

=====goto代码重写很容易出错（C6616 兰杰）=====

*'''''C++示例：看上去很容易就能重写为不使用goto是代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) ) {
      goto LOOP_EXIT;
    }
    Dosomething( data );
}  whlie ( data ！= -1);
LOOP_EXIT;
</pre>

*'''''去掉了goto的所谓等价代码'''''
<pre>
 GetData( inputFile, data );
while ( ( !eof(inputFile) ) && ( ( data ! = -1 ) ) ) { //检测到-1，退出循环而不执行Dosomething（）
   Dosomething( data );
   GetData( inputFile, data ); 
}
</pre>

*'''''去掉了goto的真正等价代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) )  {
      Dosomething( data );//检测到-1之前，执行Dosomething（）
   }
}while { ( data != -1 ) && ( !eof( inputFile ) ) );
</pre>

=====分配和清理时使用goto利大于弊（C6616 兰杰）=====
<pre>
*'''''Visual Basic示例：处理错误以及释放资源的带goto代码'''''
errorState = fileStatus_Sussess
fileIndex = 0
While { fileIndex < numFilesToPurge } //获得一个需要清除的文件列表时检测错误状态
       fileIndex = fileIndex + 1
	If Not ( FindFile ( fileList ( fileIndex),numFilesToPurge ) )Then
  	    errorState = FileStatus_FileFindError
   	GoTo END_PROC
     End If
	If Not OpenFile( fileToPurge ) Then   //打开文件列表时检测错误状态
       		errorState = FileStatus_FileOpenError
   	GoTo END_PROC
      End If  
	If Not OverWriteFile( fileToPurge ) Then  //覆盖其内容时检测错误状态
       		errorState = FileStatus_FileOverWriteError
   	GoTo END_PROC
      End If 
	If Not Erase( fileToPurge ) Then     //删除时检测错误状态
       		errorState = FileStatus_FileEraseError
   	GoTo END_PROC
       End If
    End While

END_PROC:     //这是goto的label
    DeletePurageFileList( fileList, numFileToPurge ) 

</pre>

当子程序需要为数据库连接、内存或临时文件执行分配和清理操作的时候，如果不用goto，
通常就需要重复写出清理资源的代码。维护重复代码带来的麻烦比使用goto的弊端大。




=====可以用if嵌套语句重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用嵌套的if语句消除goto代码'''''
<pre>
   errorPurgeFileList( fileList, numFileTopurge )
   errorState = FileStatus_Success
   fileIndex = 0
   While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success )
       fileIndex = fileIndex + 1
  If FindFile( fileList ( fileIndex),numFilesToPurge ) ) Then
      If  OpenFile( fileToPurge ) Then
          If OverWriteFile( fileToPurge ) Then
             If Not Erase( fileToPurge ) Then
                errorState = FileStatus_FileEraseError
          End If
      Else 
          errorState = FileStatus_FileOverWriteError
      End If
  Else
      errorState = FileStatus_FileOpenError
  End If
Else
    errorState = FileStatus_FileFindError
End If

End While
DeletePurageFileList( fileList, numFileToPurge )

</pre>
如示例这样嵌套，使嘚仅当一条if语句检测成功时才执行下一条if语句，这是标准的消除goto的编程方法。
这样做最大的缺点在于嵌套太深，必须把整个嵌套装入大脑才能理解。

=====可以用一个状态变量重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用状态变量消除goto代码'''''
<pre>
   errorPurgeFileList( fileList, numFileTopurge )
   errorState = FileStatus_Success
   fileIndex = 0
   While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success )// while判断增加了对errorstate的判断
       fileIndex = fileIndex + 1
  If Not ( FindFile ( fileList ( fileIndex),numFilesToPurge ) )Then
  	    errorState = FileStatus_FileFindError
   	GoTo END_PROC
     End If
     If ( errorState = FileStatus_Success ) Then //这里判断了状态变量
	If Not OpenFile( fileToPurge ) Then   
       		errorState = FileStatus_FileOpenError
   	GoTo END_PROC
      End If
     If ( errorState = FileStatus_Success ) Then  //这里判断了状态变量
	If Not OverWriteFile( fileToPurge ) Then  
       		errorState = FileStatus_FileOverWriteError
   	GoTo END_PROC
      End If 
     If ( errorState = FileStatus_Success ) Then//这里判断了状态变量
	If Not Erase( fileToPurge ) Then     
       		errorState = FileStatus_FileEraseError
   	GoTo END_PROC
       End If
    End While
    DeletePurageFileList( fileList, numFileToPurge )
</pre>
*这样做的优点在于，没有使用深层嵌套，读起来比较容易，同时，与嵌套if相比，if—then—else
检测后面的操作与该检测的距离更近，避免使用了else子句。
*缺点在于，使用状态变量的方法应用不够普遍。应该对它们的用法充分说明，否则别人可能
不懂你的意思





=====可以用try-finally重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用try-finally消除goto代码'''''
<pre>
  MakePurgeFileList( fileList, numFilesToPurge )
  Try
     fileIndex = 0
     while ( fileIndex < numFilesToPurge )
        fileIndex = fileIndex + 1
        FindFile ( fileList ( fileIndex),numFilesToPurge ) 
        OpenFile( filesToPurge)
        OverwriteFile( FilesToPurge)
        Erase（ FilesToPurge）
      End While
   Finally
       DeletePurageFileList( fileList, numFileToPurge )
End Try   
</pre>
*这种方法优点在于，它比使用goto简单的多，没有用到goto也没有用到深层嵌套结构
*缺点在于，必须所有代码持续一致的使用这种方法，否则产生的代码会很复杂。




=====使用这4种方法更有优劣（C6616 兰杰）=====

{| border="1" style="border-collapse;"
!方法
!优点
!缺点
|-
||使用goto
||避免了深层嵌套和不必要的检测
||使流程变得难以分析
|-
||嵌套if
||避免了使用goto
||增加了子程序的复杂度
|-
||状态变量
||避免了使用goto和深层嵌套
||引入了额外的检测
|-
||try-finally
||避免了使用goto和深层嵌套
||不是所有语言都支持
|}


=====不要用goto共享else子句中的代码（C6616 兰杰）=====
*'''''坏例子'''''
<pre>
  if ( statusOK ){
     if ( dataAvailable ){
        importVariable = x ;
        goto MID_LOOP;//借助goto共享else子句的一段代码
      }
   }
  else{
     importantVariable = GetValue();

     MID_LOOP;

    // lots of code
  }
</pre>
这样的话逻辑非常曲折，照这个样子，想读懂它几乎是不可能的，想不用goto而正确
地重写也非常难。


*'''''好例子'''''
<pre>
    if ( statusOK ){
     if ( dataAvailable ){
        importVariable = x ;
        DoLotsOfCode( importantVariable );//在这里调用放公共代码的子程序
      }
     }
    else{
         importantVariable = GetValue();
         DoLotsOfCode( importantVariable );
     }
</pre>
将公共代码放到子程序中，就可以在原goto语句出现或跳转的地方调用该子程序，同时
保留原有的条件结构




=====可以重新组织判断语句结构来共享代码（C6616 兰杰）=====

通常，写一个新的子程序是最好的方法，但是有时候把重复的代码提取成单独的子程序是
不显示的。这时可以通过重新组织判断语句结构来解决该问题

*'''''C++示例：不使用goto共享else子句中的代码'''''
<pre>
if (  （statusOK && dataAvailable ) ll !statusOK { //可以去掉一个statusOK的检测
   if ( statusOK && dataAvailable ){  //可以去掉dataAvailable的检测
     if ( dataAvailable ){
        importVariable = x ;
      }
   else{
     importantVariable = GetValue();
   }
  
    // lots of code
 }
</pre>
这种对goto版本代码的转换比较可靠，也很机械，它检测了两statusOK ，多检测了一次
dataAvailable，不过代码实现的功能是一样的。


=====goto不到不得已的情况下不要使用（C6616 兰杰）=====
*在那些不支持结构化控制语句的语言里，用goto去模拟那些控制结构是应准确，
不要滥用goto带来的灵活性
*如果语言内置了等价的控制结构，那么就不要使用goto
*如果能为代码提升效率，并对效率的提升作出说明，可以使用goto，大多数情况下不要用
*除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号。
*除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转。
*确认所有的goto标号都被用到了。
*确认goto不会产生某些执行不到的代码
*对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且
愿意为使用goto辩解，那么用goto也无妨


====17.4 针对不常见控制结构的观点  （兰杰）====
=====对非传统的控制结构应持怀疑态度（C6616 兰杰）=====

*不加限制地使用goto
*能动态计算出goto跳转目标并且执行跳转
*通foto从一个子程序中部跳到另一个子程序中部
*根据行数或标号调用子程序，从而允许代码从子程序中间某个位置开始执行
*具备让应用程序动态生成代码并且执行这些代码的能力
这些想法看起来离奇，但曾经都被认为是可以接受的。很大程度上，软件开大这一领域实在限制程序员
对代码的使用中得到发展的。

=====不常见控制结构使用时应多加小心（C6616 兰杰）=====
*多个return可增加程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心，
如果在读子程序后期时，你没有意识到它从前面某个地方返回的可能性，想理解这个子程序就很困难。
*递归能够很优雅的解决一小部分问题。但对于大多数问题，它所带来的解将是极其复杂的，对它的使用也要倍加小心。
*在少数情况下，goto是编写可读性和可维护代码的最佳方法，但这种情况非常罕见。除非万不得以，不要使用goto。



=== 第18章 表驱动法===

====18.1 表驱动法使用总则         （梁运）====
=====不要使用复杂的逻辑代码=====
*当遇到想把字符、划分为字母、标点符号、和数字三类，使用复杂的逻辑链是错误的。
'''错误示例代码'''
<pre>
if(
   (('a'<=inputChar)&&( inputChar<='z'))||(('A'<=inputChar)&&( inputChar<='Z'))
  )
{
 charType=CharacterType.Letter;
}
else if ((inputchar==' ')||(inputChar==',')
	 ||(inputChar=='.')|| (inputChar=='!')
	 || (inputChar=='(')|| (inputChar==')') 
	 || (inputChar==':') || (inputChar==';')
	 || (inputChar=='?') || (inputChar=='-')
        )
{
 charType=CharacterType.Punctuation;
}
else if (('0'<= inputChar)&&( inputChar<='9'))
{
 charType= CharacterType.Digit;
}
</pre>
=====解决方法=====
*把每一个字符的类型保存在一个用字符编码访问的数组里。
'''正确示例代码'''
<pre>
charType= CharTypeTable[inputChar];
</pre>
====18.2 直接访问表              （梁运）====
=====IF语句的劣势=====
*当需要计算每个月的天数时，笨拙的方法就是直接写一个大的IF语句。
'''错误示例代码'''
<pre>
IF(month=1)Then
  days=31
ElseIf(month=2)Then
  days=28
ElseIf(month=3)Then
  days=31
ElseIf(month=4)Then
  days=30
ElseIf(month=5)Then
  days=31
ElseIf(month=6)Then
  days=30
ElseIf(month=7)Then
  days=31
ElseIf(month=8)Then
  days=31
ElseIf(month=9)Then
  days=30
ElseIf(month=10)Then
  days=31
ElseIf(month=11)Then
  days=30
ElseIf(month=12)Then
  days=31
End If
</pre>

=====直接索引方法的步骤===== 
*更简单容易的方法就是把这些数据存到一张表里面。在Microsoft Basic里面，需要首先创建这张表：
'''正确示例代码'''
<pre>
' Initialize Table of "Days Per Month" Data
Dim daysPerMonth() As Integer = _
    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
</pre>
=====数组访问语句===== 
*现在，你无须在写那么长的if语句，只需要用一条简单的数组访问语句就可以得出每个月中的天数了。
'''正确示例代码'''
<pre>
days = daysPerMonth( month-1 )
</pre>
=====查表遇到特殊情况的解决方法===== 
*如果你想把查表的版本中再把闰年考虑进去，那么代码仍然会很简单，建设LeapYearIndex()的取值要么为0，要么为1；
'''正确示例代码'''
<pre>
days = daysPerMonth( month-1, LeapYearIndex() )
</pre>
*如果把闰年也考虑进来，那么长长的if句将会变得更为复杂了。
*计算每月的天数是一个很适合用直接访问表描述 的例子，因为你可以用month变量去表里面查询记录。一般来说，你可以用原本控制着很多if语句的书记去直接访问表。


=====声明数据建表===== 
*医疗保险费率的程序，是随着很多的不同情况在变化的，如果用逻辑结构就会很复杂，更好的方法是把这些费率都存入所有因素索引的数组里。
'''正确示例代码'''：
<pre>
Public Enum SmokingStatus
 SmokingStatus_First=0
 SmokingStatus_Smoking=0
 SmokingStatus_NonSmoking=1
 SmokingStatus_Last=1
End Enum
Public Enum Gender
 Gender_ First=0
 Gender_Male=0
 Gender_Female=1
 Gender_Last=1
End Enum
Public Enum MaritalStatus
 MaritalStatus_ First=0
MaritalStatus_Single=0
MaritalStatus_Married=1
MaritalStatus_Last=1
End Enum
Const MAX_AGE As Integer=125
Dim rateTable (SmokingStatus_Last,Gender_Last,MaritalStatus_Last,_MAX_AGE)As Double
</pre>

=====存数据的方法=====
*声明之后，可使用赋值语句，读入数据、计算出这些数据、或者执行合适的操作。备好数据后，就可以用更简单的方法取而代之：
'''示例代码'''
<pre>
rate =rateTable(smokingStatus,gender,maritalStatus,age)
</pre>
*这种方法可读性好，也更容易修改。

=====灵活的消息格式=====
*假如需要编写一个子程序，通常会有500条消息，每份文件大约有20中不同的消息。这些消息源于一些浮标，提供有关水温、浮标位置等信息。
*每一条消息都有若干字段，并且每条消息都有一个消息头，其中有一个ID，告诉你该消息属于哪一种。
*这些格式不是固定不变的，它们由你的客户来决定。

=====基于逻辑的方法的劣势(C6632梁运)=====
*有的时候，基于逻辑的方法，需要很多步骤，很多的底层子程序去支持它，用面向对象的方法也好不到哪里去。
*通常我们会用一种抽象的消息对象，并为每种消息类别派生出一个子类。
'''错误示例代码'''
<pre>
While more message to read
  Read a message header
  Decode the message ID from the message header
  If the message header is type 1 then
    Print a type 1 message 
  Else if the message header is type 2 then
    Print a type 2 message
  ...
  Else if the message header is type 19 then
    Print a type 19 message
  Else if the message header is type 20 then
    Print 1 type 20 message     
</pre>
*如上还是简化过的代码，但是无须看完所有情况，就可以看出路数，每次有一种格式变了，就不得不修改负责处理该消息的子程序或者累的逻辑。
=====面向对象的方法劣势(C6632梁运)=====
*面向对象的方法，在特定情况，基本结构同样复杂，因为无论是直接写逻辑，还是把它包含在特定的类里，每种消息都有自己的子程序，新增一种消息类型都要去修改代码。
'''错误示例代码'''
<pre>
While  more message to read 
  Read a message header
  Decode the message ID from the message header
  If the message header is type 1 then
    Instantiate a type 1 message obect
  Else if the message header is type 2 then
    Instantiate a type 2 message object
 ...
  If the message header is type 19 then
    Instantiate a type 19 message obect
  Else if the message header is type 20 then
    Instantiate a type 20 message object
  End if
End While
</pre>
'''好方法：'''<br>
*表驱动法比前面两种方法都要方便、经济。其中的消息子程序由循环组成，它负责读入消息头,再对ID解码，一种表就可以描述每种消息的格式，无须修改代码就可以轻松的进行维护。

=====表驱动的定义再解释 (工号 C6632 梁运)=====

*表驱动法是一种编程模式，从表里面查询信息而不使用逻辑语句（如if或switch）。
/用自己的话概括：就是用查表来代替if语句或switch语句。

=====不使用表驱动的反例 (工号 C6632 梁运)=====

*如果有这样一个函数int getTotalDayInMonth(int month)，它输入一个月份，然后返回这个月份的总天数（不考虑闰年，二月以28天计），比如输入5，返回的是31，因为5月里共有31天。
'''坏代码'''
<pre>
  int getTotalDayInMonth(int month)
 { 
      int totalDay = 0;
      if(month == 2)
      {
          totalDay = 28;// 二月以28天计
      }
      else if(month == 4 || month == 6 || month == 9 || month == 11)//为天数为30天的做了一次判断
   {
         totalDay = 30;
     }
     else
     {
        totalDay = 31;// 为天数为31天的又做了一次判断
     }
     return totalDay;
 }
</pre>

*在这种写法里使用了逻辑if判断，里面有很多凭空出现的数字，比如2，4，11等，这些数字出现在程序里是很不好的，因为不好修改与扩充，可能要因为更多的天数可能性（假定7月只有17天，而9月有21天），而添加更多的if分支。

=====使用表驱动法让程序更简单(工号 C6632 梁运)=====
'''好代码'''
<pre>
const int totalDayTable[12] =
 {
     31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
 };
 // 获得某一月中的总天数
 int getTotalDayInMonthFromTable(int month)
 {
     return totalDayTable[month - 1];
 }
</pre>
*把用表与不用表的代码对比一下，要简化许多。如果某个天数变了，可以直接修改或扩充totalDayTable就行了，至于函数则不用修改。

=====直接访问表的使用方法(工号 C6632 梁运)=====

*查表方法分类：查表方法可以细分为三种：直接访问、索引访问、阶梯访问
*直接访问是最简单的，查表本质其实就是去索引“键”来获得“值”，有点像获得数组值一样，给定下标index，然后matrix[index]就获得数组在相应下标处的数值。
**直接访问表的例子：
'''在表中查询对象及其成员函数的代码'''
<pre>
fieldIdx = 1;
while ( ( fileIdx <= numFieldsInMessage ) && ( fileStatus == OK ) )//这些是针对消息中每个字段的维护代码
  { fieldType = fieldDescription[ fieldIdx ].FieldType;
    fieldName = fieldDescription[ fieldIdx ].FieldName;
    field[ fieldType ].ReadAndPrint( fieldName, fileStatus );
  } //这就是表查找，它通过查找对象表调用一个由字段类型所决定的函数
</pre>

=====构造查询键值的方法(工号 C6632 梁运)=====

*复制信息从而能够直接使用键值。
**如果用直接访问法但某些键值是相同的，（18岁以下的保险费率相同），最简单的办法就是为0-17的每个年龄都复制一份相同的键值。
//但是缺点比较明显，数据冗余

*转换键值以使其能够直接使用。
**用一个函数，把0-17之间的年龄转换成一个键值。例如：可以用min()和max()函数做一个转换。
'''表达式'''
<pre>
Max(min(66,age),17)//生成一个位于17到66之间的表键值
</pre>
//缺点是可能每一部分区间都不同，导致的函数也不尽相同

*把键值转换提取成独立的子程序。
**现阶段已经有不少成熟的语言支持键值转换功能，例如Java中的HashMap，C#中的Dictionary。

=====遇到“键”是不能直接用的时候的解决方法(工号 C6632 梁运)=====

*如下例子：这里的键是动物名，而值是相应的描述。下标必须是整数，但动物名是string。
*解决方法:
**可以由程序员自行设计string到int的映射，自己做个菜单，让用户只能选择相应的数字，这样“键”就成int了。
'''解决代码方法的例子'''
<pre>
class Animal
  {
  public:
      virtual void print() = 0;
  };
  class Dog: public Animal
  {
  public:
     void print()
     {
         cout << "This is Dog..." << endl; // 使程序输出结束
     }
 };
 class Cat: public Animal
 {
 public:
     void print()
     {
         cout << "This is Cat..." << endl; // 使程序输出结束
     }
};
 class Cow: public Animal
 {
 public:
     void print()
     {
         cout << "This is Cow..." << endl; // 使程序输出结束
     }
 };
 
 Animal* animalTable[] = {
     new Dog, new Cat, new Cow
 }; //创建一个表
 int main()
 {
     cout << "想知道哪种动物的描述？" << endl;// endl是程序的结束符
     cout << "1. 狗" << endl << "2. 猫" << endl << "3. 奶牛" << endl << endl; // 使程序输出结束
     int choiceIndex; 
     cout << "我选择：";//cout是c++语言的输出符号
     cin >> choiceIndex;
     assert(choiceIndex >= 1 && choiceIndex <= 3);
     animalTable[choiceIndex - 1]->print();//表animalTable就是将Dog映射成数字1，Cat映射成数字2。
 }
</pre>

*这里用了C++的多态性，根据不同的实体对象能调用相应的print函数。

====18.3 索引访问表              （工号 C6632 梁运）====
=====需要用到索引访问表的例子(工号 C6632 梁运)=====
*它适用于这样的情况，假设你经营一家商店，有100种商品，每种商品都有一个ID号，但很多商品的描述都差不多，所以只有30条不同的描述。
*现在的问题是建立商品与商品描述的表，如果和上面做法来一一对应，那样描述会扩充到100的，会有70个描述是重复的。
**解决这个问题的方法：
建立一个100长的索引，然后这些索引指向相应的描述，注意不同的索引可以指向相同的描述，这样就解决了表数据冗余的问题。
=====索引访问表的优点(工号 C6632 梁运)=====
*如果主查询表的每一条记录都很大，创建一个索引数组所用的空间，要比创建一个主查询表所用的空间小很多。
*即使索引以后没有节省内存空间，操作位于索引中的记录，比操作位于主表中的记录更方便廉价。
*编写到表里面的数据比嵌入代码中的数据更容易维护。


====18.4 阶梯访问表              (工号 C6632 梁运)====
=====需要用到阶梯访问表的例子(工号 C6632 梁运)=====
*它适用于数据不是一个固定的值，而是一个范围的问题，比如将百分制成绩转成五级分制（A、B、C、D和F），假定转换关系是当成绩在90-100区间，判为A，成绩在80-90区间，判为B，成绩在70-80区间，判为C，成绩在60-70区间，判为D，成绩在60以下，判为F（failure）。
*用表格对付这个范围问题，一种方法是申请一个100长的表，然后在这个表中填充相应的等级就行了，但这样太浪费空间了，所以这个时候就需要用阶级访问表：
'''好代码'''
//阶梯访问表，二分查找
<pre>

  const char gradeTable[] = {
      'A', 'B', 'C', 'D', 'F'
 };//用表把成绩分成五个等级
  const int DONWLIMIT_LENGTH = 4;
 const int downLimit[] = {
      90, 80, 70, 60
};
int BinarySearch(int score)
{
     int low = 0;
    int high = DONWLIMIT_LENGTH - 1; //downLimit的最大的Index
  while(low <= high)
    {
       int mid = (low + high) / 2;
         if(score < downLimit[mid])
        {
            low = mid + 1;
         }
         else if(score > downLimit[mid])
       {
           high = mid - 1;
        }
        else
       {
            return mid;
        }
     }
     return low;
}

int main()
{
    int score = 87;
    int gradeLevel = BinarySearch(score);
    cout << "等级为 " << gradeTable[gradeLevel] << endl;// 使程序输出结束
     return 0;
}
</pre>

*用表驱动法避免了大量的if或switch分支，还应用上了二分查找法。



====表驱动心得（工号C6609 黄佳欣）====


'''表驱动方法'''
'''坏方法：'''
无论是什么样的逻辑运算，都是一步的用代码去表示，去演算。
'''好方法：'''
借助数据库去减化代码，减少错误。
对于比较复杂的逻辑运算，可以通过访问表的方法直接取得逻辑运算想要的数据。
*简单的直接访问表。
对于获取的数据比较直接的时候，我们可以通过直接访问存储了想要数据的表，
通过逻辑运算条件做为访问数据库的条件。
比如，判断每个月的天数。
坏代码如下：<br>
<pre>
If(month=1)Then
   days=31
ElseIf(month=2)Then
   days=28
   ......
ElseIf(month=12)Then
   days=31
End If
</pre>
好代码如下：<br>
在VB里，你需要首先创建出这张表：<br>
<pre>
'Initialize Table of "Days Per Month" Data
Dim daysPerMonth() As Integer=_
   {31,28,31,30,31,30,31,31,30,31,30,31}
</pre>
而现在只需要一条简单的数组访问语句就可以得出每个月中的天数：<br>
<pre>
days=daysPerMonth(month-1)
</pre>
*基于逻辑的访问表。 
对于获取的数据每种情况都不相同时的时候，我们可以通过创建多张存储不同数据的表，
通过逻辑判断，去读取不同表的数据，用来阅读。
*面像对象的方法访问表。
对于这样的方法，同样是去处理每种情况下，不相同时。
但这是处理更为复杂的，比如在判断成功后，还会在里面继续做逻辑判断。
这时，我们可以把第二层里想要的结果做为对象，拿出来。
写到特定的类里，每一个逻辑判断的想定结果都作为一个子程序。
这样就减少了错误，使代码更加清晰。

====18.3 索引访问表              （黄佳欣）====
====索引访问表心得（工号C6609 黄佳欣）====
*数据库检索方法索引访问介绍：
'''坏方法：'''<br>
直接通过检索条件检索这个表，遍历整个表，从而找到这条数据。<br>
'''好方法：'''<br>
用数据库表建立一个索引表（包含了这个表个表中一列或者
若干列值的集合，不是必须用主键，可以确定这条数据的唯一
性就可以）。<br>
例如：
SELECT NAME FROM TABLE_TEST WHERE ID = '10000';。<br>
没有索引:必须遍历整个表，直到ID等于10000的这一
行被找到为止；<br>
有索引:即可在索引中查找到这条数据的位置。由于索引是经过
某种算法优化过的，因而查找次数要少的多。
*索引的优点:
占用的总内存量少
可以大大加快数据检索速度。
通过创建唯一索引，可以保证数据记录的唯一性。
更容易维护。


=====索引访问表方便且实用（C6616 兰杰）=====
*如果主查询表中的每一条记录都很大，创建索引数组用的空间比创建主查询表的小很多。
*即使用了索引以后没有节省内存空间，操作位于索引中的记录有时也要比操作位于主表
中的记录更方便更廉价
*编写到表里的数据比嵌入代码的数据更容易维护。

====18.4 阶梯访问表              （黄佳欣）====
====阶梯访问表心得（工号C6609 黄佳欣）====
*基本思想：对数据进行区间划分，再该区间内的是一类数据，然后在该区间
内找到这个数据。
适用于无规则的数据。像分数等级划分，电费等级的划分。
*阶梯的优点：
节约存储空间，加快数据检索速度（慢于索引）。
*使用阶梯访问表时需要注意的一些细节：
留心端点<br>
考虑用二分查找取代顺序查找<br>
考虑用索引访问来取代阶梯技术<br>
把阶梯表查询操作提取成单独的子程序<br>

=====使用阶梯技术应注意细节（C6616 兰杰）=====
*留心断点，确认已经考虑到到每一个阶梯区间的上界。注意不要把<误用为<=。确认循环
能够找出最高一级的的区间之后恰当地终止，且正确处理了区间的边界。
*考虑用二分法查找取代顺序查找。如果表很大，顺序查找的成本会成为效率的制约。
*考虑用索引访问取代阶梯技术。阶梯方法的查找操作可能比较耗时，可以考虑用索引
方法，即以牺牲存储空间来换取速度。
*把阶梯表查询操作提取成单独的子程序。在创建了一个转换函数，能把数值转换成键
值时，把它提取成单独的子程序更方便。

====18.5 表查询的其他示例         （黄佳欣）====
====由内而外，创建循环体心得（工号C6609 黄佳欣）====
'''坏方法：'''<br>
循环体的创建我们通常会从FOR循环开始想起，然后在写循环体。
写一个复杂的循环，这样的方法是耗时间，还容易出错的。<br>
'''好方法：'''<br>
先从循环体开始思考，先建立好循环的内部循环程序，最后加上for循环
，然后缩进代码。这样的方法在面对比较复杂的循环时，可以减少代码和
思维上的错误。保证循环的准确性和节约编码的时间。（不是必须要着
样做，对于比较简单的循环来说，一直顺手写也是很快。）
====低效代码的优化心得====
*低效代码的发生只要是不必要的输入\输出。
像大量的磁盘、数据库、网络文件访问。在硬件设施保证的情况下可
以在内存中处理的文件就不需要这样费力了。
*编程语言的原因。
编译型(C++、VB、C#)<字节型(JAVA)<解释型(PHP、Python)
，适当的编程语言可以大量的节约程序运行时间。
*较常见原因。
参数运算，(a+1)>(a++)。
多余的逻辑运算：(&、&&)和(|、||).(&&和|| 有短路的功能，可以节约
逻辑运算的时间)
====书本衍生的代码程序优化想法（工号C6609 黄佳欣）====
*代码量的缩减：例如：从一个集合或者数组中取对象可以
直接用增强FOR循环取。
*参数精度：可以用int类型的，就不必要用double或者更高精度的
类型定义。
*变量的重复定义。例如：在FOR循环中定义一个可以在FOR循环外定
义的变量。
*大量的不必要变量定义和变量的赋值。

=====使用表应注意决策（C6616 兰杰）=====
*表提供了一种复杂的逻辑和继承结构的替换方案。如果对某个程序的逻辑或继承树关系感到困惑，
可以尝试通过一个表来简化。
*使用表的一项关键决策时决定如何去访问表。可以采取直接访问、索引访问或者阶梯访问。
*使用表的另一项关键决策时决定应该把什么内容放入表中。



=== 第19章 一般控制问题===
====19.1 布尔表达式              （工号c6622 李腾飞）====
*在布尔表达式中要用标识符true和false，而不是0和1等数值，隐式地比较布尔值与true和false。
'''错误示例代码'''
<pre>
Dim printerError As Integer
Dim reportSelected As Integer
Dim summarySelected As Integer
...
If printerError = 0 Then InitializePrinter ()
If printerError = 1 Then NotifyUserOfError ()

If reportSelected = 1 Then PrintReport ()
If summarySelected = 1 Then PrintSummary ()

If printerError = 0 Then CleanupPrinter ()
</pre>
'''正确示例代码'''
<pre>
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()
</pre>
通过这样可以明确你在执行一个布尔判断，使用隐式比较能减少阅读代码时需要记住的项数。
*简化复杂的表达式
拆分复杂的判断并引入新的布尔变量，把中间结果赋给变量

'''复杂的判断'''
<pre>
If ( ( document.AtEndOfStream ) And ( Not inputError ) ) And _
  ( ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES ) ) And _
  ( Not ErrorProcessing( ) ) Then
 ' do something or other
...
End if
</pre>
'''去掉复杂判断后'''
<pre>
If ( DocumentIsValid( document, lineCount, inputError ) ) Then
' do something or other
...
End If
</pre>
假设ErrorProcessing()是一个可以表明当前处理状态的布尔函数，那么阅读代码时就可以忽略那个复杂判断，这样代码就会简洁易懂了。
*编写肯定的表达式										
在写代码过程中会出现否定形式的逻辑判断可能会增加阅读难度，把否定形式转变成肯定形式会使阅读代码变得简单										

'''否定形式的判断'''										
<pre>										
If ( ！statusOK ) (										
  // do something										
 ...
 )										
else (										
 // do something else										
 ...
 )										
</pre>										
'''变肯定后的判断'''										
<pre>										
If ( statusOK ) (										
// do something else										
...										
)										
else (										
 // do something										
 ...
 )										
</pre>										
通过比较不难看出，肯定形式的代码可以更容易清晰的得到主要信息。										
*狄摩根定理										
一个表达式可以用另外一个双重否定形式含义却相同的表达式表达，便于代码的阅读理解。										
*用括号使代码表述更加清晰										
虽然语言有自己的求值顺序，但是适当的加入括号可以提高程序的准确性和可读性。										

'''括号少的表达式'''										
<pre>										
if ( a < b == c == d ) ...
</pre>										
'''加入括号的表达式'''										
<pre>										
if ( （ a < b ） == （ c == d ) ） ...
</pre>
*正确的结构顺序						 (工号c6622 李腾飞）
对于求值的表达式，一个正确的结构顺序可以减少错误的发生和读取的难度						

'''结构不合理的判断'''						
<pre>						
while ( i < MAX_ELEMENTS and item[ i ] <> 0 )...
</pre>						
'''合理结构的判断'''						
<pre>						
while ( i < MAX_ELEMENTS )						
if ( item[ i ] <> 0 ) then						
...
</pre>						
*利用短路原理求值						（工号c6622 李腾飞）
例：						
<pre>						
if ( ( denominator != 0 ) && ( ( item / denominator ) > MIN_VALUE ) ) ...
</pre>						
*隐式地比较逻辑变量						（工号c6622 李腾飞）
0在我们编写代码中有多种用途，在逻辑表达式中可以隐式地与0做比较						

例：						
<pre>						
while ( !done ) ...
</pre>						
										
====19.1 布尔表达式              (陈欢欢)====
*代码中不要使用1和0表示代码(工号C6623 陈欢欢)
**代码中用1和0表示意思不清晰，根本没有反映究竟1代表是真，0代表假，还是正好相反，甚至1和0是不是代表真假都不清楚。读到代码的时候，往往不能在第一时间，快速的了解代码所表达的含义
*用隐式布尔值，不用隐式的true和false(工号C6623 陈欢欢)
**把表达式当做布尔表达式，可以写出更清晰的判断语句，如下图的Visual Basic示例中的0和1代表的不是布尔标示
<pre>
Visual Basic示例，使用True和False代替数值来作判断用(很好，但不是最好)
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()//非布尔标示
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()//非布尔标示
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()//非布尔标示
</pre>
<pre>
Java示例
If (printerError=="False")//不存在printerError
</pre>
*不支持布尔变量，无法使用(工号C6623 陈欢欢)
**通过使用隐式表示，能够减少阅读代码所必须的项数,这样写出的表达式读起来也更加的简单易读懂。如上图所示的If (printerError=="False")语句中就是使用的隐式表达标示，如果是使用0和1的方式表示，还有去追究0和1分表代表的含义，但是若是使用隐式表示的方式，给代码的阅读带来了便利，从而减少了工作量




*不要用庞大的的复杂判断(工号C6623 陈欢欢)
**拆分复杂的判断，然后引入新的布尔变量，从而将中间结果赋给变量，是的判定变的更加简单。而且这样可以使得命令能起到简化复杂度，提高执行效率的效果
</pre>
'''坏代码'''
<pre>
    if(a==(3000/(7-2)/(30/7)))
   //假设3000是你现在的月收入，你要计算每天的平均收入，那么首先，你要知道自己工作了多少天
   //（7-2）是每个礼拜工作的天数，（30/7）是每月有几个礼拜
</pre>
'''好代码'''
<pre>
    int b=(3000/(7-2)/(30/7));
    if(a==b)
</pre>
*不要用复杂的判定条件,使用决策表(工号C6623 陈欢欢)
**决策表的使用类似于数组的使用方法
**有时候一个很复杂的判断，涉及的变量很多。用决策表代替if或者case等复杂的语句执行，只需要几行代码就能对于判断有帮助。还能减低复杂度，极大程度的降低出错的可能
**表查询方法有：直接访问、索引访问、阶梯访问
<pre>
   String a=new String("admin","big","cat");
</pre>
*判断条件不要以否定形式(工号C6623 陈欢欢)
'''坏代码'''
<pre>
Java示例：否定形式
if(!statusOk){//(除了!statusOk以外的情况，测试的重点是非特别情况)
  // do something——A处
  ...
}
else{
  // do something else——B处
  ...
}
</pre>
'''好代码'''
<pre>
Java示例：肯定形式
if(statusOk){//(除了statusOk的情况,剔除特定的情况) 
  // do something ——B处 
  ...
}else{
 // do something else——A处
  ...
}
</pre>



*在表达式中要使用括号（工号C6623 陈欢欢）
**使用括号可以更改语句的求值顺序。一个含义不清晰的表达式，如：if（a&lt;b==c==d）隐藏着if（&lt;(b==c)==d）或者if（(a&lt;b）==(c==d）)的判断
'''坏代码'''
<pre>
Java示例：括号少的表达式
if（a<b==c==d）{
  //do something
  ...
}
</pre>
'''好代码'''
<pre>
Java示例：括号少的表达式
if（(a<b）==(c==d）) {
  //do something
  ...
}
</pre>


*使用隐式方式逻辑变量（工号C6623 陈欢欢）
**变量被new使用之后，会开辟新的栈内存，而使用隐式方式进行数值，有效的避免了这个问题，减少了所占用得内存空间<br>
将数和0做比较时，使用这个方式较好
<pre>
   while(balance!="a")
</pre>
零终止符字符和数字一样，都不是逻辑表达式。
<pre>
   while(charPtr!='\0')
</pre>
针对指针使用
<pre>
   while(bufferPtr!=NULL)
</pre>

*a==b和a.equals(b)使用（工号C6623 陈欢欢）
**数据在实例化的时候，往往会产生一个新的空间用于存放实例化对象
**a==b判断的是a和b是否引用了同一个对象
**a.equals(b)判断的是这两个对象是否具有相同的值<br>
a==b用途
<pre>
Student a=new Student();
Student b=new Student();
if(a==b)
</pre>
a.equals(b)用途
<pre>
String a="aaaa";
String b="bbbb";
if(a.equals(b))
</pre>

=====在布尔表达式的判断中用true和false来表示真和假（工号C6604 郭思）=====
　　有时我们会在代码中看到布尔表达式除了用true和false来表示真假外，还有用0和1的，或者自定义数据的。
*'''不好的代码（使用1和0判断）'''
<pre>
public class Test
{
    public static void main(String args[])
    {
        int A,B;
        ....
        if (A==1)
            //do something;
            ....
        if (B==0)
            //do something;
            ....
    }
}
</pre>
　　上面的代码使用0和1进行布尔判断，根本看不出1是代表真还是假，甚至1和0是不是代表真假都不知道，这样在查看或者修改代码的时候，会有很大的困难。另外由于是简单的数字，在输入时很有可能会写错，而且如果写错了也很难发现。
*'''好代码（使用true和false判断）'''
<pre>
public class Test
{
    public static void main(String args[])
    {
        boolean flag;
        if (flag==true)
            //do something;
            ....
        if (flag==false)
            //do something;
            ....
    }
}
</pre>　
　　使用true和false就可以很清晰地表示真假了,而且写错的可能性也降低了。

=====隐式地比较布尔值与true和false（工号C6604 郭思）=====
　　把表达式当做布尔表达式，可以把true和false隐藏，让式子更清晰。比如：　　
    if(A==false) ...
    if((A>B)==true) ...
可以写成：
    if(!A) ...
    if(A>B) ...
　　这样隐式地表达，意思清晰，还减少了阅读量。下面有个更具体的例子：
<pre>
public class Test
{
    public static void main(String args[])
    {
        int A;
        int B;
        boolean C;
        ....
        if (A>B)
            //do something;
            ....
        if (!C)
            //do something;
            ....
    }
}
</pre>

=====引入新的布尔变量简化复杂的判断（工号C6604 郭思）=====
　　如果要进行复杂而庞大的判断时，我们可以把中间结果赋值给一个变量，这样更加简洁明了。
<pre>
int A,B,C,D;
if(A>B && C>D && A!=0){
    //do something
    ...
}
</pre>
<pre>
boolean log;  //引入新的布尔变量
int A,B,C,D;
log=A>B && C>D && A!=0;
if(log){
    //do something
    ...
}
</pre>
　　上面的例子中，引入新的布尔变量log，它就是原来条件判断的中间结果。再进行条件判断时，就更简单了。

=====把复杂的表达式做成布尔函数（工号C6604 郭思）=====
　　如果一个复杂的判断需要重复做，或者会影响对主程序的理解，就可以把这个判断提取成一个函数，然后判断函数的返回值就可以了。当这个代码不重要时，可以不理会它。
*复杂的表达式
<pre>
if(条件1 && 条件2 && 条件3 && 条件4 && 条件5){
    //do something
    ...
}
</pre>
*布尔函数
<pre>
public class panduan{
    public static boolean panduan(){
        boolean A;
        boolean B;
        boolean C;
        A=条件1 && 条件2； //中间值
        B=条件3 && 条件4； //中间值
        C=A && B && 条件5；
        return C;
    }
}
</pre>
*主流程
<pre>
if(panduan()){
    //do something
    ...
}
</pre>
　　上面的例子中把条件判断的句子写成了一个函数，返回一个布尔值。只看程序的主流程的时候，就更加简单，更容易理解了。

=====在C家族语言中，把常量放在比较的左侧（工号C6604 郭思）=====
　　刚接触到C语言时，我们学到==才是比较，=是赋值的意思，有时会不小心把==写成=，这时就可以在编程时把常量放在表达式的左侧。
 if(EINTER=i) ...
这样写的话，编译器就会在=的地方报错，因为常量不能被赋值。如果写成下面的形式,编译器只会报一个警告：
 if(i=EINTER) ...



====19.2 复合语句（语句块）       （李腾飞）====
====把括号对一起写出，用括号来把条件表达清楚====
*先写块的开始和结束部分，之后填充中间部分。
例如：
*先写
<pre>
for ( i = 0; i < maxLines; i++ )
</pre>
*再写
<pre>
for ( i = 0; i < maxLines; i++ ) { }
</pre>
*最后写
<pre>
for ( i = 0; i < maxLines; i++ ) {
   // whatever goes in here ...
}
</pre>
这种方法适用于所有的块结构，用语句块时一定要清楚的表达你的用意，无论块内的代码行数是1还是20.
====19.3 空语句                  （时昌彬）====
=====空语句并不多见，因此应突出这种用法=====
*空语句，即一条仅含有分号的语句
'''C++实例：传统的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））
;
</pre>
*空语句并不多见，因此应突出这种用法，方法之一是用一组空的括号来强调空语句。
'''C++实例：加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{ }
</pre>
*另外可以让空语句中的分号自占一行，并加以缩进来强调空语句。		
'''C++实例： 加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{
	;
}
</pre>
=====为空语句创建一个DoNothing（）预处理宏或者内联函数=====
*这条语句什么也不做，但却能毫无争议的表明“这里希望不做任何事情”的用意。下面就是C++中如何使用#define来定义空语句
'''C++实例： 用DoNothing（）来强调空语句'''
<pre>
#define DoNothing()
...
while (recordArray.Read( index++) != recordArray.EmptyRecord()){
	DoNothing();
}
</pre>
除了在空的while和for循环中使用DoNothing(),你也可以在switch语句中的无意义选项中使用它；加入DoNothing()表明你已经考虑了这种case，并且的确不需要对该case做什么操作。

=====用非空的循环体代替空语句（工号C6604 郭思）=====
*'''用;表示的空语句'''
<pre>
int A[10];
int a=0;
while(A[a++] != 0){
    ;
}
</pre>
*'''转换成非空循环体'''
<pre>
int A[10];
int a=0;
int num=A[a];
a++;
while(num != 0){
    num=A[a];
    a++;
}
</pre>
　　对比上面两段代码，可以看出，用非循环体代替空语句时，引入了一个新的变量num，但是更加直观，代码也更容易理解。


====19.4 驯服危险的深层嵌套        （时昌彬）====
=====避免使用超过3到4层的嵌套=====
*很少有人能够理解超过3层的if嵌套，很多研究人员建议避免使用超过3到4层的嵌套。
*把嵌套if转换成一组if-then-else语句
'''Java实例：坏代码'''
<pre>
if (10 < quantity){
	if(100 < quantity）{
		if(1000 < quantity){
			discount = 0.01;
    		}
		else{
			discount = 0.05;
		}
	}
	else{
		discount = 0.025;
	}
else{
	discount = 0.0
}
</pre>
出现多层嵌套的原因是其中的判断逻辑组织的很差，这些判断中有许多冗余。当判断了quantity是否大于1000的时候，
就不需要再去判断他是否大于100并且大于10。因此可以重新组织这段代码：
'''Java实例： 好代码'''
<pre>
if (1000 < quantity){
	discount = 0.01;
}
else if (100 < quantity){
	discount = 0.05;
}
else if (10 < quantity){
	discount = 0.025;
}
else{
discount = 0.0;
}
</pre>

=====把嵌套if转换成case语句=====
*你可以用case语句重写一些判断，特别是那些含有整数的判断，而不是去用一长串if和else。
'''Visual Basic实例：将嵌套if语句转换成case语句'''
<pre>
Select Case quantity
	Case 0 to 10
		discount = 0.0
	Case 11 to 100
		discount = 0.025
	Case 101 to 1000
		discount = 0.05
	Case Else
		discount = 0.10
End Select 
</pre>
有些语言中你无法使用这种方法，但是对那些可以使用case的语言来说，这是一种功能强大的技术。

=====把深层嵌套的代码抽取出来放进单独的子程序中=====
'''C++实例：将嵌套代码分解到子程序的好代码'''
<pre>
while(!TransactionsComplete()){
	//read Transaction record
	transaction = ReadTransaction();
	// process transaction depending on type of transaction
	if (transaction.Type == TransactionType_Deposit){
		ProcessDeposit(
			Transaction.AccountType,
			Transaction.AccountSubType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else if (transaction.Type == TransactionType_Withdrawal){
		ProcessWithdrawal(
			Transaction.AccountType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else if (transaction.Type == TransactionType_Transfer){
		MakeFundsTransfer(
			Transaction.SourceAccountType,
			Transaction.TargetAccountType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else{
	//process unknown Transaction type
	LogTransactionError("Unknown Transaction Type", transaction);
	}
}
</pre>
这里没有给出新的子程序。
*把深层嵌套的代码抽取出来放进子程序，使代码结构更简单并容易理解。其次你可以在一个屏幕里阅读，修改和调试这个while循环——它不再跨越好几屏，或者超出打一字的边界。


=====重新设计深层嵌套的代码=====
*一些专家认为，在面向对象的程序设计中出现case语句，就说明代码没有做好分解，因此实际上极少有必要使用case语句。
*更一般的说法是，复杂的代码表明你还没有充分的理解你的程序，所以无法简化它。深层嵌套是一个警告，他告诉你要么应该拆分出一个子程序，要么应该重新设计那部分复杂的代码。




====19.4 驯服危险的深层嵌套        （陈欢欢）====
*通过重复检测条件中部分条件简化嵌套的if语句（工号C6623 陈欢欢）
'''坏代码'''
<pre>
if(inputStatus==InputStatus){
  //lots of code
  ...
  if(printerRoutine!=NULL){
     //lots of code
     ...
     if(setPage!=NULL){
        //lots of code
        ...
    }
  }
}
</pre>
'''好代码'''
<pre>

if(inputStatus==InputStatus){
  //lots of code
  ...
  if(printerRoutine!=NULL){
     //lots of code
     ...
     if(setPage!=NULL){
        //lots of code
        ...
    }
  }
}

if((inputStatus==InputStatus)&&(printerRoutine!=NULL)&&(setPage!=NULL)){
  //lots of code
  ...
}
</pre>

*用break块简化嵌套if（工号C6623 陈欢欢）
**break可以在语句块中间某些条件没有满足，跳转至某位时使用
<pre>
do{
  if(inputStatus!=InputStatus){
   break;//跳出代码块
  //lots of code
  ...
     if(setPage!=NULL){
       break;//跳出代码块
     }
     //lots of code
     ...
  }
}
</pre>

*用if-then-else代替嵌套if（工号C6623 陈欢欢）
**if-then-else比if嵌套语句更具有组织结构，因为else版本可以避免不必要的重复。
'''好代码'''
<pre>
if(1000<quantity){
   discount=0.01;
}else if((100<quantity)&&(quantity<=1000)){
   discount=0.05;
}else if((10<quantity)&&(quantity<=100)){
   discount=0.025;
}else if(quantity<=10){
   discount=0;
}
</pre>
====19.5 编程基础：结构化编程      （陈欢欢）====
*“结构化”包括结构化分析、结构化设计以及结构化混日子
**'''*除了都创建于“结构化”被广泛推崇的时代之外，这些状态各异的结构化方法学之间并没有多少相互联系'''
*核心思想很简单
**一个应用程序应该只采用一些单入单出的控制结构（也称单一入口、单一出口的控制结构）
***'''*单入单出的控制结构指一个代码块，只有一个执行开始点与执行结束点'''
*执行方式是有序的且有规则的
*结构化编程的三个组成部分:顺序、选择、迭代
*顺序
<pre>
Java示例：顺序
//a sequence of assignment statements
a=”1”;
b=”2”;
c=”3”;

//a sequence of calls to routines
System.out.println(a);
System.out.println(b);
System.out.println(c);
</pre>
*选择是一种有选择的执行语句的控制结构:if-then-else,case
<pre>
Java示例：选择
//selection in an if sttement
If(totalAmount>0.0){
  //do something
  ...
}
else{
  //do something
  ...
}

//selection in a case statement
switch(commandShortcutLetter){
   case ‘a’:
      PrintAnnualReport();
      break; 
   case ‘q’:
      PrintAnnualReport();
      break;  
   case ‘s’:
      PrintAnnualReport();
      break;
default:
DisplayInternalError(“Internal  Error 905:Call customer support”);
}
</pre>
*迭代——是一组语句多次执行的控制结构（也称循环）
<pre>
Visual Basic示例：迭代
‘ example of iteration using a For loop
For index=first To last
   DoSomething (index)
Next

‘ example of iteration using a while loop
index=first
While(index<=last)
   DoSomething (index)
   Index=index+1
Wend

‘ example of iteration using a loop-with-exit loop
index=first
Do
   If(index>last) Then Exit Do
   DoSomething(index)
   Index=index+1
Loop
</pre>
*结构化编程的中心论点——任何一个控制利用可以有顺序、选择和迭代三种结构构成


====19.6 控制结构与复杂度         （陈欢欢）====
*控制结构的作用是降低复杂度
*程序复杂度决定了理解程序所需要花费的精力
*控制流是影响复杂度的大因素之一
**'''*与控制流有关的复杂度非常重要——与不可靠的代码和频繁出现的错误息息相关'''
*度量复杂度——计算子程序的“决策点”的数量来衡量复杂度
<pre>
决策点的计算方式：
(1)决策点初始值为1；
(2)遇到一次if，while，repeat，for，and，or决策点就加1
(3)Case语句中的每一种情况加1
</pre>
<pre>
处理复杂度的度量结果
（1）0-5 子程序可能还不错
（2）6-10 得想办法简化子程序了
（3）10+ 把子程序的某一部分拆分成另一个子程序并调用它
</pre>
*将子程序提取到另一个子程序，不会降低整个程序的复杂度，只是降低在同一时间必须关注的复杂度水平
*其他度量方法——所用的数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码行数（跨度）、变量生存的代码行数（生存期）以及输入的输出的量








*使用return减少工作量（工号C6623 陈欢欢）
**一旦知道答案，就马上返回。没有return的话，在出错后，不能及时得到反馈。有return语句也可以增强可读性
'''好代码'''
<pre>
  if(inputStatus>outputStatus){
    return inputStatus;
  }else if(inputStatus<outputStatus){
     return outputStatus;//返回较大值
  }
</pre>


*排序常用递归（工号C6623 陈欢欢）
递归并不常用，主要是将程序划分成多个子程序.当它调用自身的时候，有时所使用的数组太小而无需排序的时候会停止对自身的调用
<pre> 
Java示例：使用递归的算法排序——调用自身
void Action（int firstIndex，int lastIndex，String names）{
  if(lastIndex>firstIndex){
     int length=Partition(firstIndex,lastIndex,names);
     Action(firstIndex,length-1,names);
     Action(firstIndex+1,length,names);
  }
}
</pre>


*不要用递归去计算阶乘（工号C6623 陈欢欢）
**除了速度缓慢，并且无法预测运行期间的内存使用情况，用递归写出的子程序在计算时往往比循环难以理解。
<pre>
   int Factorial(int number){
     int intermediateResult=1;
     for(int factor=2;factor<=number;factor++){
        intermediateResult=intermediateResult*factor;
        //intermediateResult*=factor;
     }
   }
</pre>



*不要为了终止循环改动for循环下标（工号C6623 陈欢欢）
**for循环在写好后，它的循环计数器就会超出预期的控制。随意修改往往会使得程序超出原本的计划
**更好的方式是，用while循环去获得对退出条件的控制
'''坏代码'''
<pre>
   Java示例，胡乱改动循环下标
   for(int i=0;i<99;i++){
      if(i=50){
        i=100;
      }
      //doing something;
      ...
   }
</pre>
'''好代码'''
<pre>
   Java示例，while控制循环
      while(i<50){
        i+=100;
      }do{
        //doing something;
         ...
      }
</pre>


*不要用i，k这些无意义的数据作为局部变量（工号C6623 陈欢欢）
**在for语句中，对于变量的定义，往往喜欢用i，k等，但是在嵌套的语句中，这就容易使得数据混乱产生无法预计的后果
'''坏代码'''
<pre>
   Java示例:循环下标串话
    for(int i=0;i<9;i++){  
      //doing something;
      ...;
       for(int j=0;j<10;j++){  
         //doing something;
         ...;
          for(int i=0;i<99;i++){  
             //doing something;
              ...;
           }
        }
    }
</pre>



*用default子句检测错误（工号C6623 陈欢欢）
**如果case语句中的默认子句既没有用来做其他处理，按照正常顺序也不太可能发生，就在其中加入诊断消息，用来判断数据显示的错误
<pre> 
   使用defaukt子句检测错误
   switch(idea){
     case "a";
        Sysyem.out.println("YOU ARE WIN");
     case "b";
        Sysyem.out.println("YOU ARE LOSE");
     case "c";
        Sysyem.out.println("PLAY AGAIN");
     default:
        Sysyem.out.println("数据有误");
   }
</pre>