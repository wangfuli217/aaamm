=== 参加人员 ===

时昌彬  郭思  黄佳欣  兰杰  陈渊  何刚  刘思  徐杰  李腾飞  陈欢欢  梁运  共计11人


=== 第14章 组织直线型代码=== 

====14.1 必须有明确顺序的语句      （陈渊）====
14.1 必须有明确的语句顺序心得:
那么有明确语句顺序的代码好处在哪呢，下面通过一个有明确顺序的代码和没有明确顺序代码的实例，我们会一目了然的发现有明确顺序的代码的优点。<br>
<pre>
例1（有明确顺序）
date = ReadData();
results = =CalculateResultsFromData(date );
PrintResults(results );
</pre>
<pre>
例2（没有明确顺序）
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
</pre>

从上面的两个例子可以很好地看出例的优势，通俗易懂，而且逻辑方面也层层相扣，大大提高了代码的正确性，可读性和可维护性。

那我我们所要做的就是讲自己写的代码有意识的携程有顺序条理清晰的的代码现在，通过一个例子的展现如何改进写的代码的可读性。<br>
<pre>
InitializeExpenseData
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary
</pre>

*加注释对不清晰的依赖关系进行说明<br>
<pre>
InitializeExpenseData//计算Expense数据
ComputeMarketingExpense//四个子程序访问了ExpenseData数据成员
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary//调用了四个子程序访问了ExpenseData数据成员后的数据
</pre>

*'''加参数明确显示依赖关系（推荐）'''<br>
<pre>
expenData = InitializeExpenseData（expenData）;
marketingExpenData = ComputeMarketingExpense（expenData）;
salesExpenData = ComputeSalesExpense（expenData）;
travelExpenseData = ComputeTravelExpense（expenData）;
personnelExpenseData = ComputePersonnelExpense（expenData）;
DispalyExpenseSummary（marketingExpenData,salesExpenData,travelExpenseData,personnelExpenseData）;
</pre>

*用断言或者错误处理代码来检查依赖关系<br>
就是可以再在类的成员变量里将isExpenseDataInitialized设为false,然后再InitializeExpenseData（）中将isExpenseDataInitialized设为true,在下面四个函数对expenData进行操作之前，看看isExpenseDataInitialized是否为true,但是我觉得因为引入新的变量、新的初始化，就变得复杂也不是很好理解，还会增加错误，所以不是很推荐。

====14.2 顺序无关的语句           （陈渊）====

14.2 顺序无关的语句心得
=====是代码易于自上而下地阅读=====
其中最最重要的一点就是：要把相关的操作都放在一起。要让别人轻松的读懂你的代码，就要让你的程序易于自上而下的阅读，不能让读者去大量的代码中去搜寻他想要的信息，举一个例子:<br>
<pre>
MarketingData marketingData;
SalesData salesData;
TravelData travelData;

travelData.computeQuarterly();
salesData.computeQuarterly();
marketingData.computeQuarterly();

marketingData.computeAnnual();
salesData.computeAnnual();
travelData.computeAnnual();

salesData.Print();
travelData.Print();
marketingData.Print();
</pre>

上面的代码跳来跳去的让人看了很不舒服，如果放在一大堆的代码里，读者估计得花很长时间去搜寻他想要的信息如果想知道travelData是怎么来的，那他就得全局去搜，而且还会想，用到的地方是不是就仅仅只有这几个呢，给阅读带来了很大的不便，要是我们能做到把相关的操作放一起，那效果就不一样了。<br>
<pre>
MarketingData marketingData;
marketingData.computeQuarterly();
marketingData.computeAnnual();
marketingData.Print();

SalesData salesData;
salesData.computeQuarterly();
salesData.computeAnnual();
salesData.Print();

TravelData travelData;
travelData.computeQuarterly();
travelData.computeAnnual();
travelData.Print();
</pre>

如过我们改成了上面的代码，把相关的的语句组织到一起，放在一起，那么对代码的可读性、可维护性有了大大的提升

=====把相关的语句组织到一起=====
把相关的语句放一起。让一些处理相同的数据、执行相似的任务，或具有某种执行顺序上的依赖关系的语句放在一起，能够很好地提高代码的可读性。

=== 第15章 使用条件语句===

====15.1 if语句                  （何刚）====
*'''写if语句时，首先写正常代码路径；再处理不常见情况'''
    在编写代码时，要使的正常情况的执行路径在代码中是清晰的。要确保那些不常见的情况不会遮掩正常的执行路径。这对可读性和代码性能来说都很重要。
*'''把最常见的情况放在最前面'''
    把最常见的情况放在前面，可以让阅读的人为找出正常情况的处理代码而必须要读的非常见情况的代码边的最少。同时，由于把在执行最常见情况代码之前所需的判断减到最少，代码效率也得到了提高，就像下面一样：
<pre>
If ( IsLetter( inputCharacter ) ) {                //最为常见的情况会先在这里得到处理
  CharacterType = CharacterType_Letter;
}
else if ( IsPunctuation( inputCharacter ) ) {
  CharacterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
  CharacterType = CharacterType_Digit;
}
else if ( IsCotrolCharacter( inputCharacter ) ) {      //最不常见的情况则是放在最后来解决
  CharacterType = CharacterType_CotrolCharacter;
}
</pre>

*'''把正常情况的处理放在if后面而不要放在else后面'''
    把认为会正常出现的情况放在前面处理，这符合把决策的结果代码放在尽可能靠近决策位置的一般原则。
*'''''坏代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Error ) Then 
  errorType = FileOpenError            //出错情况
Else 
  ReadFile ( inputFile, fileData, status )    //正常情况
  If ( status = Status_Success ) Then    
    SummarizeFileData ( fileData, summaryData, status )    //正常情况
    If ( status = Status_Error ) Then 
      errorType = ErrorType_DataSummaryError          //出错情况
    Else 
      PrintSummary( summaryData )                   //正常情况
      SaveSummaryData( summaryData, status )
      If ( status = Status_Error ) Then
        errorType = ErrorType_SummarySavaError        //出错情况
      Else 
        UpdateALLAccounts ( )                        //正常情况
        EraseUndoFile ( )
        errorType = ErrorType_None
      End If
    End If
  Else 
  errorType = ErrorType_FileReadError
  End if
End If
</pre>
    这段代码很难理解，因为它把正常的情况和出错的情况混在了一起。很难从中找出正常代码的路径来。除此之外，因为错误条件有的时候是在If子句而不是else中处理，所以很难判断到底哪个if子句检测了与之相关的正常情况。
*'''''好代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Success ) Then 
  ReadFile ( inputFile, fileData, status )      //正常情况
  If ( status = Status_Success ) Then 
    SummarizeFileData ( fileData, summaryData, status )    //正常情况
    If ( status = Status_Success ) Then
      PrintSummary( summaryData )                   //正常情况
      SaveSummaryData( summaryData, status )
      If ( status = Status_Success ) Then
        UpdateALLAccounts ( )                        //正常情况
        EraseUndoFile ( )
        errorType = ErrorType_None
      Else
        errorType = ErrorType_SummarySavaError        //出错情况
      End If
    Else
      errorType = ErrorType_DataSummaryError          //出错情况
    End If
  Else
    errorType = ErrorType_FileReadError
  End If
Else
  errorType = ErrorType_FileOpenError      //出错情况
</pre>
    在修改后的例子里，可以通过阅读if条件测试的主流程来找到正常的情况。这一修改使认得注意力集中到了阅读代码的主流程上，而不是费力的去理解那些异常处理情况，因此整体代码更容易阅读。嵌套条件语句的下面积累了全部的错误情况，这是良好错误处理代码的一个标志。	

*'''让if子句后面跟随一个有意义的语句'''
有时候我们会看到这样一种代码，其中if子句是空的：

*'''''坏代码'''''
<pre>
If ( SomeTest )
       ;
Else {
//do something 
......
}
<pre>

    哪怕是为了少些那个额外的空语句行和else行代码，也应该避免这么编写代码。将上面程序中if语句的谓语做否定，把else子句中的代码移到if子句中并去掉else子句就可以可以得到下面的代码了：

*'''''好代码'''''
<pre>
If ( ! SomeTest ) {
      //do something 
      ......
}
<pre>

*'''测试else子句的正确性'''
在测试代码的时候，有人可能觉得只有if子句需要测试，实际上对else我们也一定要测试它。

*'''检查if和else子句是不是弄反了'''
    在编程中经常会犯这么一种错误，那就是要么把本应该放在if子句后面的代码和本应该放在else子句后面的代码给弄反了，要么就是把if测试的逻辑弄反了。在实际工作中，在写if-else语句的时候一定要注意代码里的逻辑关系，并需要认真测试。

====判断语句if else 使用心得（C6609 黄佳欣）====
*把正常情况的处理放在if处理的后面，不要放在else的后面。这样的代码可阅读性更强。
'''坏代码：'''
<pre>
if（status = Status_Error1）{
	error=Error1;//出错情况1
}else{
	A = B;//正常情况2
	if（status = Status_Success）{
		C = D；//正常情况
		if（status = Status_Error2）{
			error=Error2;//出错情况2
		}else{
			E = F;//正常情况3
		}
	}else{
		error=Error3;//出错情况3
	}
}
</pre>

'''好代码：'''
<pre>
if（！status = Status_Error1）{
	A = B;//正常情况1
	if（status = Status_Success）{
		C = D；//正常情况2
		if（！status = Status_Error2）{
			E = F;//正常情况 3
		}else{
			error=Error2;//出错情况2
		}
	}else{
		error=Error3;//出错情况3
	}
}else{
	error=Error1;//出错情况1
}
</pre>


*if后面跟上一个有意义的语句。
坏代码：
<pre>
if（A=B）{
	//do nothing
}else{
	//do something
	A=B;
}
</pre>
好代码：
<pre>
if（!A=B）{
	//do something
	A=B;
}else{
	//do nothing
}
</pre>
*if语句后面请加上else，尽管这个else里可能不做处理，
可能没有意义。但这是为了表明我已经考虑了else的情况。
除非没有处理的情况显而易见，否则请注释解释为什么没
有必要做处理。
坏代码：
<pre>
if（!A=B）{
	//do something
	A=B;
}
</pre>
好代码：
<pre>
if（!A=B）{
	//do something
	A=B;
}else{
	//do nothing
	//这种情况下A不赋值。
}
</pre>
=====简单if-then语句(c6618 陈渊)=====
if-then的简单示例
<pre>
if(...) Then
...
</pre>
'''注意'''：if后面判断的语句要仔细考虑条件是否满足实际情况，比如：>=和>就不一样前面一种情况既包含了大于又包含了等于，要结合实际情况下，判断这两种情况是否要分开写。

=====简单if-then-else 语句(c6618 陈渊)=====

当我们写if，else语句的时候首先会考虑有几种情况，这样我们就定了用几个if、else('''个人建议if、else最好成对出现避免出现遗漏混乱的情况''')
其次，我们最该考虑的就是if后面的语句和else后面的语句
*'''if后面的语句'''
上述if-then中已经提到提到了if后面加判断语句，就是后面要加一个有意义的的语句
错误代码：
<pre>
if(someTset){
...;
}
else{
....;
}
</pre>
这里面的someTset就不是一个有意义的语句即判断句
可以改为如下代码：
<pre>
if(！someTset){
...;
}
else{
....;
}
</pre>
*'''else后面的语句'''
在一些语句中可能只有if语句，但是，应该吧else的情况也考虑到，可以写一个else的空语句，就像我上面说的最好成对出现，因为在复杂的情况下，这样写很容易帮你看出语句的完整性，不容易出现少判断，漏情况的问题。而且让别人看你的代码的时候也更容易看懂，可维护性大大提高另外。我们可以在else语句中注释为什么这里不需要else子句
（个人推荐的书写格式）
<pre>
if(a=b){
...;
}else if(a<b){
...;
}else if(a>b){
...;
}else {
//假设a与b的只有这三种情况的判断，那么在这个else里就不用子句，但最好注释一下便于维护
}
</pre>

=====确保对于等量的分支是正确的（C6604 郭思）=====
　　在循环里，要仔细考虑端点的值，在条件语句里，也要确定条件是否满足实际情况。
<pre>
int A=5;
int n=0;
If (A > 1) {
    n++;
    A--;
}
</pre>
<pre>
int A=5;
int n=0;
If (A >= 1) {
    n++;
    A--;
}
</pre>
　　上面两段代码中，由于条件的不同，最终ｎ的值也不一样。这只是一个比较小的问题，如果在很复杂，很重要的代码中发生这样的问题，很可能会造成不易发现的错误。

=====让if子句后面跟一个有意义的语句（C6604 郭思）=====
　　有时候，在某个条件下没有动作要进行，也就是If子句是空的。比如下面的代码：
<pre>
int A=5;
int n=0;
If (A < 1) 
    ;
else {
    n++;
    A--;
}
</pre>
　　这样看上去很奇怪，这时我们可以对if的条件做否定，把else的子句移到if子句中，并去掉else子句。比如：
<pre>
int A=5;
int n=0;
If (A >= 1) {
    n++;
    A--;
}
</pre>

=====要考虑else子句（C6604 郭思）=====
　　很多情况下，我们写的代码都只有if语句，其实，在我们写代码的时候，应该吧else的情况也考虑到，可以编写一个else的空语句。另外，当在测试的过程中遇到只有if语句的时候，除非原因显而易见，否则要用注释来解释为什么这里不需要else子句。
<pre>
//if color is vaild
if (COLOR_MIN <= color && color<= COLOR_MAX){
    //do something
    ....
}
else {
    //else color is invaild
    //screen not written to -- safely ignore command
}
</pre>


====15.2 case语句                （何刚）====
=====为case选择最有效的列顺序=====
*'''按字母顺序或按数字顺序排列各种情况'''
    如果所有情况的重要性都相同，那么就把它们按A-B-C的顺序加以排列，以便提高可读性。
*'''把正常的情况放在前面'''
    如果有一个正常情况和多个异常情况，那么把那个正常的情况放在最前面。用注释来说明它是正常情况，而其他的属于非正常情况。
*'''按执行频率排列case子句'''
    把最经常执行的情况放在最前面，最不常执行的放在最后面。这样做有两方面的好处。首先阅读程序的人可以很容易的找出最常见的情况。那些检索情况列表，找出某个具体情况的读者很可能对最常见的情况感兴趣，而把最常见的情况放在代码的上部会加速这种检索。
=====使用case语句的诀窍=====
*'''简化每种情况对应的操作'''
    使得每种情况有关的代码短小精悍。简短的情况处理代码会使case语句的结构更加清晰。如果某种情况执行的操作非常复杂，那么就写一个子程序，并在该情况对应的case子句中调用它。
*'''不要为了使用case语句而刻意制造一个变量'''
    case语句应该用于处理简单，容易分类的数据。如果数据并不简单，那么就使用if-then-else语句串。
*'''利用default子句来检测错误'''
    如果一条case语句中的默认子句既没有用来做其他的处理，按照正常执行顺序也不太可能会发生，那么就向里面加入一条诊断消息：
<pre>
Switch ( commandShortcutLetter ) {
  case ‘a’ :
    PrintAnnualReport () ;
    Break;
  case ‘p :
    //No action required, but case was considered
    Break;
  case ‘q’ :
    PrintQuarterlyReport () ;
    Break;
  case ‘s’ :
    PrintSummaryReport () ;
    Break;
  default:
    DisplayTnternalError(
            “Internal Error 905: Call customer support.”)  
}
</pre>
    如果把默认子句用于错误检测以外的其他目的，那就意味着每一种情况的选择都是正确的。请仔细检查以确认每一个可能进入case语句的值都是合法的。如果发现一些不合法的值，那就重写这些语句，让默认子句去执行错误检测。


=====case子句的排序要有意义（C6604 郭思）=====
　　我们都知道case子句是顺序执行的，如果是只有两三个选项的case语句，顺序就不那么重要；但是如果用case来解决复杂的问题，要处理多个事件，那顺序就很重要。所以case子句的排序要有一定的规则。
#按字母顺序或数字顺序排列  当所有的case选项同样重要时，可以用A-B-C或者1-2-3这样的顺序表示，这样可以让读者更容易理解代码，也更容易找到特定的情况。
#把正常的情况放在前面  如果有正常情况和异常情况，把正常的情况放在前面，并注释说明。
#按执行频率排序  把执行频率高的情况放在前面，这样便于阅读代码的人找到最常见的情况。


=====在C++和Java里，每个case的末尾都要有一个break（C6604 郭思）=====
　　在C++和Java中，case语句不会自动跳出每一种情况。必须给每一个case子句写上break语句。如果没有break，程序运行完当前的情况后会继续执行下一条case子句，直到遇到break为止；如果没有break，则会运行到default语句，最后结束switch语句。比如：
<pre>
int n=2;
switch(n){
    case 1:printf("1");
    case 2:printf("2");
    case 3:printf("3");break；
    case 4:printf("4");
    default;
}
</pre>
　　上面的代码本意是想输出2，但是没有加break的时候，switch发现2匹配，执行printf("2");然后继续执行printf("3");遇到break停止。与预想的结果不符，而且这种没有break的switch-case语句让读者很难理解，修改代码的时候要考虑的事情还很多，所以最好在写代码的时候就让每一个case子句后面跟上break语句。

=====在case末尾明确地标明需要穿越执行的程序（C6604 郭思）=====
　　如果需要让代码故意跳过某个case子句的末尾，那就要在相应的位置注释说明为什么要这样写代码。比如：
<pre>
int n;
cin>>n;
switch(n){
    case 1: //当n=1或n=2时，都输出'X'
    case 2:cout<<'X';break;
    case 3: //当n=3或n=4时，都输出'Y'
    case 4:cout<<'Y';break;
    default:cout<<'Z';
}
</pre>
　　上面的代码最后的结果可能是Y或者Z或者XY，但是不可能出现X，因为case 2没有break语句，会继续到case 4，直到break结束。在穿越执行的程序附近加上注释，让读者更容易理解，增强了代码的可读性。


=== 第16章 控制循环===

====16.1 选择循环的种类           （徐杰）====
=====常见的循环有计数循环、连续求值的循环、无限循环和迭代器循环。=====
*计数循环执行的次数是一定的。
'''计数循环Java示例代码'''
<pre> 
   public static void main(String[] args) {
        int count = 0;//定义一个计数器变量
        for (int i = 1; i <= 1000; i++) {
            if (i % 3 == 1 && i % 5 == 3 && i % 7 == 5) {
                System.out.println(i);
                count++;//每次符合要求后计数器都+1
            }
        }
        System.out.println(count);
    }
</pre>
*连续求值的循环预先并不知道要执行多少次，它会在每次循环遍历时判断是否应该结束。
'''连续求值的循环Java示例代码'''
<pre>
    public static void main(String[] args) {
	for (int i = 1; i < 10; i = i + 1) {
		System.out.println(i);
	}
    }
</pre>
*无限循环一旦启动就会一直执行。多用在心中起搏器、微波炉和导航控制仪中。
'''无限循环Java示例代码'''
<pre>
     for(int i=1;;i++){
	System.out.println(i);
     }
</pre>
*迭代器循环对容器类里面的每个元素执行一次操作。
'''迭代器循环Java示例代码'''
<pre>
       public static void main(String[] args) {
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
		arrayList.add(1);
		arrayList.add(2);
		arrayList.add(3);
		Iterator iterator = arrayList.iterator();
		while (iterator.hasNext()) {  //迭代器遍历查询，判断是否还有值可以显示
			System.out.println(iterator.next());
		}
	}
</pre>
=====把检查放在循环结尾处，循环就会至少执行一次。=====
*把检查放在循环开始处，那么它的循环体就不一定会执行。
*如果是放在中间检查，那么检查前面的那一部分至少执行一次，检查后面部分就不一定会执行到。
=====循环次数不确定时用while循环。=====
*while循环有do while（直到型循环）和while（当型循环）
**当你需要一个灵活的循环且该循环至少被执行一次，那么你就可是用一个在结尾处做条件检测的while循环。
=====灵活度和检查位置决定选择循环的种类。=====
*循环的种类列表如下：
{| class="wikitable"
! 语言
! 循环的种类
! 灵活度
! 检查位置
|-
| Visual Basic
| For-Next
| 严格
| 开始
|- 
| 
| While-Wend
| 灵活
| 开始
|- 
| 
| Do-Loop-While
| 灵活
| 开始或结尾
|- 
| 
| For-Each
| 严格
| 开始
|- 
| C,C++,C#,Java
| for
| 灵活
| 开始
|- 
| 
| While
| 灵活
| 开始
|- 
| 
| do-While
| 灵活
| 结尾
|- 
| 
| foreach
| 严格
| 开始
|}
=====当循环条件检测在循环开始或结尾处时，我们就要用带退出的循环。=====
*带退出的循环就是循环终止条件出现在循环中间而不是在开始或者结尾处。
**C++,C和Java中可以用break语句退出当前循环。在其他语言中也可以用goto实现。正常的带退出循环由循环头、循环体（包括终止条件）和循环尾组成。
**Java中使用循环语句时，只有循环条件表达式的值为false时，才能结束循环。有时，我们想提前中断循环，要实现这一点，只需要在循环语句块中添加break或continue语句。break（退出整个循环）、continue（退出本次循环，进入下一次循环）。“break;”语句：可以出现在while、do…while、for、switch语句体中。“continue;” 语句：只能出现在循环语句while、do…while、for中。
*'''坏代码'''
<pre> 
   // Compute scores and ratings.
   score = 0;
   GetNextRating( &ratingIncrement );
   rating = rating + ratingIncrement;
   While ( (score < targetScore ) && ( ratingIncrement != 0 ) ) {
        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement; 
        //7，8行与上面的3,4行重复，维护时会出现问题（上下两组代码需同步修改容易忘记）。解决办法写个带退出的条件。
    }
</pre>
*'''好代码'''
<pre> 
   // Compute scores and ratings.The code uses an infinite loop
   // and a break statement to emulate a loop-with-exit loop.
   score = 0;
   While ( true ) {
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement;

        if ( !( (score < targetScore ) && ( ratingIncrement != 0 ) ) ) { //写了退出循环的条件，容易维护。
            break;  //满足if条件时退出循环。
        }

        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
    }
</pre>
=====循环次数固定时用for循环。=====
*用for循环来执行那些不需要循环内部控制的简单操作。
**使用for循环的好处是你在循环头处写好它之后就可以忘掉它了，无需在循环的内部做任何事情去控制它。
**不要在for循环里通过直接修改下标值得方式迫使它终止，这种情况应该用while循环。
=====foreach循环简化数组和集合的遍历=====
*foreach循环优势是消除了循环内务处理算术，从而也就消除了任何由循环控制算术导致出错的可能性。 
*'''代码示例'''
<pre>
int[] str = { 1, 2, 3, 4, 5, 6, 7, 8 };
int i =0;
foreach (int s in str)
{
   if (i < 5)
   {
      MessageBox.Show(s.ToString());
      i++;
   }
   else
   {
      break;
   }
}
</pre>
*foreach语句的局限性是如果要引用数组或者集合的索引，则foreach语句无法做到，foreach仅仅老老实实地遍历数组或者集合一遍。
=====while与do while 区别与联系         （C6618 陈渊）=====
1 while语句格式
<pre>
  While(条件表达式)
<pre>
  {
             执行语句；
}
</pre>

2 do while 语句格式
<pre>
  do
{
      执行语句；
}while(条件表达式)；
</pre>

while与do while 最大的区别由例子可以看出：
<pre>
int i=0;
while(i>0){
    System.out.println("0");
}
//这样不输出；

int i=0;
do{
    System.out.println("0");
}while(i>0)
//这样输出结果是0
</pre>

联系：它们都是循环语句，都可以判别条件，执行循环体，都具有循环体的一般特性。<br>
区别：while 先判断条件，只有条件满足才执行循环体。do while 先执行循环体，再判别条件，条件满足，再执行循环体。总之一句话：do while无论条件是否满足，循环体至少执行一次。

=====for与while的区别与联系         （C6618 陈渊）=====
for与while的区别与联系:

<pre>
 for(初始化表达式；循环条件表达式；循环后的操作表达式)

   {
           执行语句；
}
</pre>
相互转换的小例子:
<pre>
int main(void)
{
    int i,sum = 0;
    for(i=1;i<=100;++i)
    sum+=i;
    printf("%d\n", sum);
    return 0;
}

int main(void)
{
    int i = 1,sum= 0;
    while(i<=100)
    {
        sum+=i;
        ++i;
    }
    printf("%d\n", sum);
    return 0;    
}
</pre>

联系：for与while都可以用来表示循环结构，一般在内存比较大的情况下，它们之间可以替换。<br>
区别：变量有自己的作用域，对于for来讲：如果将用于控制循环的增量定义在for语句中，那么该变量只在for语句内有效。For语句执行完毕。该变量在内存中被释放。for和while可以进行互换。如果需要定义循环增量。用for更为合适。
====16.2 循环控制                （徐杰）====
=====代码进入循环的五大指导原则=====
#只从一个位置进入循环。
#把初始化代码紧放在循环前面。
#用while(true)表示无限循环。
#在适当的情况下多使用for循环。
#在while循环更适用的时候，不要用for循环。
=====用“{”和“}”把循环中的语句括起来。=====
*任何时候都要在代码中使用括号。它们是一种很好的预防性编程实践。
=====不要写空循环。=====
*不要把循环处理的代码和检测循环是否终止的代码写在一起。
*'''坏代码'''
<pre>
while (（inputChar = dataFile.GetChar() ) != CharType_Eof ) {
;//循环的操作和循环的检测写在了一起
}
</pre>
*'''好代码'''
<pre>
do {
    inputChar = dataFile.GetChar();//循环操作
}while （inputChar != CharType_Eof );//循环检测分开
</pre>
=====把循环内务操作要么放在循环开始，要么放在循环末尾。=====
*循环内务操作是指像i++或者i=i+1这样的表达式，它们的目的是控制循环。
=====一个循环只做一件事。=====
=====你写的循环是要能够终止的。=====
=====循环的条件控制语句要放在一起。=====
=====不要为了终止循环而胡乱改动for循环的下标。=====
*一旦写好for循环，那么它的循环计数器i就不受你的控制了。
*想要更多的控制退出条件，可以使用while循环。
*'''坏代码'''
<pre>
for ( int i = 0; i < 100; i++ ) {
    ... //some code
    if ( ... ) {
       i = 100;//随便改动i的值，赋值100来终止循环
    }
    ... // more code
}
</pre>
=====不要出现依赖于循环下标最终取值的代码。=====
*'''坏代码'''
<pre>
for （ recordCount = 0;recordCount < MAX_RECODES;recordCount++ ）{
    if ( entry[ recordCount ] == testValue ){
       break;
    }
}
// lots of code
...
if ( recordCount < MAX_RECODES ) { //滥用循环索引的终止值,容易出现大小差一的错误
   return( true );
} else {
   return( false );
}
</pre>
*'''好代码'''
<pre>
found = false;
for （ recordCount = 0;recordCount < MAX_RECODES;recordCount++ ）{
    if ( entry[ recordCount ] == testValue ){
        found = true; //使recordCount使用局部化，使用布尔变量found循环清晰不出错
        break;
    }
}
// lots of code
...
return( found );
</pre>
=====合理使用安全计数器。=====
*安全计数器是一个变量，每次循环时递增，来判断循环执行次数是不是过多。
*'''坏代码'''
<pre>
do { 
    node = node -> Next;//指向node的下一个节点值
    ...
} while (node -> Next != NULL);//node不为空，会发生死循环
</pre>
*'''好代码'''
<pre>
sCounter = 0;
do { 
    node = node -> Next;
    ...
    sCounter++;   //安全计数器递增
    if ( sCounter >= SAFETY_LIMT ) {  //判断范围循环次数有没有超出安全
        Assert( false,"超出安全计数范围" );
    }
    ...
} while (node -> Next != NULL);
</pre>
=====把初始化代码紧放在循环前面         （C6620 刘思）=====
一旦把循环放到更大的循环中，会忘记移动或复制初始化代码，修改的时候可能忽略造成不正确的修改。
*把循环初始化语句和它相关循环放一起，运用或修改的时候容易避免出错。
好的代码
 int main()
 {
     int i=0;
     int sum=0;
     for(i;i<=100;++i)//
     {
         sum+=i;
     }
     int j=0;
     int sum1=0;
     for(int j=0;j<=100;++j)//
     {
         sum+=j;
     }
     printf("%d",sum,sum1);
     return 0;
 }
不好的代码
 int main()
 {
     int i=0;
     int j=0;
     int sum=0;
     int sum1=0;
     for(i;i<=100;++i)//
     {
         sum+=i;
     }
     for(int j=0;j<=100;++j)//
     {
         sum+=j;
     }
     printf("%d",sum,sum1);
     return 0;
 }
=====减少能影响该循环各种因素的数量，把循环内部当做一个子程序看待  （C6620 刘思）=====
把控制尽可能地放到循环体外。把循环体执行的条件表述清楚。不要让读者看了循环体以后才明白循环的控制。
*应该把循环看做是一个黑盒子：外围程序只知道它的控制条件，却不知道它的内容。
<pre>
 while( !inputFile.EndOfFIle() && moreDataAvailable){ 
         ************************************
          *                  *  
         *             黑盒子          *  
         *                  *  
        ************************************
 }  
</pre>
循环终止条件inputFile.EndOfFIle()为真，要么moreDataAvailable为假，这就是你所需要知道的全部。
阻止忽略或错误地对循环执行初始化、忽略了对累加变量或其他与循环有关的变量执行初始化、不正确的嵌套、不正确的循环终止、忽略或者错误地增加了循环变量的值、以及不正确的循环下标访问数组元素等错误。
=====尽可能多使用for循环        (C6620 刘思)=====
*for语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，它将循环控制语句集中放在一起，比while更紧凑因此修改起来更加容易。
=====不要滥用for循环    （C6620 刘思）=====
好的代码
<pre>
 c++示例：while循环的适当用法
 inputeFile.MoveToStart()；
 recordCount=0；
 while(!inputeFile.EndOfFile()){
	inputeFile.GetRecord();
	recordCount++;
 }
</pre>
不好的代码
<pre>
 c++示例：胡乱把while循环体填充到for循环头
 for(inputeFile.MoveToStart(),recordCount=0;inputeFile.EndOfFile();recordCount++)
 {
	inputeFile.GetRecord();
 }
</pre>
recordCount的语句并不控制循环，不应该放在循环头。
<pre>
 c++示例：规则的循环头部但不适用
 recordCount=0
 for(inputeFile.MoveToStart();
 !inputeFile.EndOfFile();
 inputeFile.GetRecord())
 {
	recordCount++;
 }
</pre>
虽然循环初始化语句inputeFile.MoveToStart()，循环条件!inputeFile.EndOfFile()，终止语句inputeFile.GetRecord()都有了，但是不直观用while循环更合适。
=====在嵌套循环中使用有意义的便利名来提高代码可读性   (C6620  刘思)=====
*有意义的数组下标名字既能表明循环用途，也能表明数组的用途
好代码
<pre>
JAVA示例：差劲的循环变量
for(int i=0;i<numPayCodes;i++){
	for(int j=0;j<12;j++){
		for(int k=0;k< numDivision;k++){
			sum=sum+transaction[j][i][k]
		}
	}
}
</pre>
不好的代码
<pre>
JAVA示例：好的的循环变量
for(int payCodeIdx=0; payCodeIdx < numPayCodes; payCodeIdx++){
	for(int month =0;month<12;month++){
		for(int divisionIdx = 0;divisionIdx < numDivision;divisionIdx++){
			sum=sum+transaction[month][payCodeIdx][divisionIdx]
		}
	}
}
</pre>
计算机能同样轻松阅读这两种循环，但显然第二种人更容易读懂，移植性也好。
====16.3 轻松创建循环——由内而外   （刘思）====
=====从简单情况开始并由内向外生成代码能轻松创建循环。=====
所谓由内而外就是从一种情况开始，用字面量（literal）来编写代码。然后缩进它，在外面加上一个循环然后用循环下标或计算表达式替换那些字面量。最后加上所需要的初始化。比如需要写一个能从列表中取得每个人的费率并累加的循环。
*首先，在注释里写下循环体要执行的操作步骤。先不考虑语法，下标等细节，把要做的事情先写下来。
 第1步：由内而外创建循环（伪代码示例）
 --get rate from table    (从表中取得费率)
 --add rate to total      (将费率加到总和上)
*然后，尽可能把循环体内注释转化成代码。
 第2步：由内而外创建循环（伪代码示例）
  rate = table[]     //table为存有费率数据的数组，现在table还没任何下标，
  totalRate = totalRate + rate //rate为表中取出的个人费率，totalRate为存储总费用
*接下来，往table数组里加入下标：
 第3步：由内而外创建循环（伪代码示例）
 rate = table[census.Age][census.Gender] //census存储个人信息的结构体
 totalRate = totalRate + rate
*接下来是给现有语句加上一层循环。缩进现有代码，并放在一个begin-end对里。
 第4步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census.Age][census.Gender]
  totalRate = totalRate + rate
 End For
*本列中，census变量随person而变，所以要适当推广（generalized）它。
 第5步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*最后，写出必要的初始化代码
 最后一步：由内而外创建循环（伪代码示例）
 totalRate = 0
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*要点在于从具体事件入手，在同一时间只考虑一件事，以及从简单的部分开始创建循环。
====16.4 循环和数组的关系         （刘思）==== 
====循环和数组之间有着密切的联系，选择好语言可免去繁琐的循环。====
*编程是来解决问题的，有时候解决方案是特定于语言的。所选择的开发语言将很大程度上影响到你的解决方案。
JAVA示例：数组乘法
<pre>
 for (int row = 0; row < maxRows; row++){
        for (int row = 0; row < maxCols; column++){
	     product[row][column]=a[row][column]*b[row][column]
	}
 }
</pre>
APL示例：数组乘法
 product <- a * b
可见APL代码更加简单，更不容易出错。它只用了3个操作符，而相应的JAVA用了17个之多。
*所以编程之前应该研究继而选择更为适合的语言。比如APL和Fortran 90 以及其后续版本提供了强大的数组操作功能。


=== 第17章 不常见的控制结构===

====17.1 子程序中的多处返回       （郭思）==== 
　　程序可以通过return和exit在任何时候退出子程序。比如C++和Java中的return，VB中的Exit Sub和Exit Function。Java中的return一般就是在有返回值的方法中，用来返回方法指定类型的值，同时结束方法执行；也可以在返回值为void的方法中，用来终止方法运行。
=====使用return增强可读性=====
　　如果得到了想要的答案，就可以立即返回该值到调用方子程序，让读者更容易理解。
*'''''好代码'''''
<pre>
Comparison Compare(int value1,int value2){  //返回Comparison枚举类型
  if(value1<value2){
     return Comparison_LessThan;  //小于
  }
  if(value1>value2){
     return Comparison_GreaterThan;  //大于
  }
  return Comparison_Equal;  //相等
}
</pre>
=====用防卫子句（早返回或早退出）简化复杂的错误处理=====
　　当遇到复杂的错误处理，比如在执行某段正常代码之前要进行大量的错误条件检测时，如果用if...End if...循环嵌套的话，代码的缩进层次会过深，并且正常代码不容易查看。
*'''''坏代码'''''
<pre>
if file.validName() Then
   if file.Open() Then
      if encryptionKey.vaild() Then
         if file.Decrypt(encryptionKey) Then
            'lost of code //正常执行的代码;被遮蔽了
            ...
         End if
      End if
   End if
End if
</pre>
　　这时，我们可以在执行正常代码之前先检查错误条件，有错误则停止当前子程序的运行。这样，代码的布局清晰，画面美观。
*'''''好代码'''''
<pre>
if Not file.validName() Then Exit Sub
if Not file.Open() Then Exit Sub
if Not encryptionKey.vaild() Then Exit Sub
if Not file.Decrypt(encryptionKey) Then Exit Sub
'lost of code  //正常执行的代码
...
</pre>
=====减少子程序中return的数量=====
　　如果读子程序的后部时，没有意识到前面某个地方返回的可能性，就很难理解这个子程序。只有在可以增强可读性的时候使用return，尽可能少的使用return。
====17.2 递归                   （郭思）====
　　递归，就是在运行的过程中调用自己。它通常把一个大型复杂的问题转化成一个与原问题相似的规模较小的问题来求解，递归只需少量的程序就可以描述出多次的重复计算，大大的减少了程序的代码量。
=====确认递归能够停止=====
　　检查子程序，确认其中含有一条非递归的路径，防止产生无穷递归。这意味着子程序中有一条判断，可以让递归停止。
*'''示例：使用递归的排序算法'''
<pre>
void QuickSort(int firstIndex,int lastIndex,String [] names){
     if (lastIndex > firstIndex){  //判断，当lastIndex<=firstIndex时，就会停止对自身的调用。
        int midPoint = Partition(firstIndex,lastIndex,names);
        QuickSort(firstIndex,midPoint-1,names);  //调用自身，对数组的前部分进行排序
        QuickSort(midPoint+1,lastIndex,names);  //调用自身，对数组的后部分进行排序
     }
}
</pre>
=====使用安全计数器防止出现无穷递归=====
　　可以用安全计数器来防止无穷递归，该安全计数器必须是不随子程序调用而重新创建的变量，可以用一个类成员变量，或者作为参数传递。
*'''示例：用安全计数器避免无穷递归(作为参数传递)'''
<pre>
Public Sub RecursiveProc(ByRef safetyCounter As Integer)
    If(safetyCounter > SAFETY_LIMIT) Then
        Exit Sub
    End If
    safetyCounter = safetyCounter + 1
    ...
    RecursiveProc(safetyCounter)
End Sub
</pre>
=====把递归限制在一个子程序内=====
　　循环递归（A调用B，B调用C，C调用A）非常复杂，要理解起来很难。如果有循环递归，最好重新设计子程序，把递归放在一个子程序里。如果一定要用循环递归的话，最好使用安全计数器。
=====留心栈空间=====
　　使用递归，无法保证会使用多少栈空间，也很难预测程序在运行期间会怎么样。可以按照下面的步骤来控制程序在运行期间的表现。
#如果使用安全计数器，要考虑该给递归子程序分配多少栈空间。要把计数器的上限设置得足够低，防止栈溢出。
#注意观察递归函数中局部变量的分配情况，特别留意内存消耗大的对象。
=====不要用递归去计算阶乘或者斐波纳契数列=====
　　在许多教科书的中都喜欢用计算阶乘和斐波那契数列来讲解递归，其实，把递归用在这两者中是很愚蠢的。
*'''示例：用递归计算阶乘，不合适'''
<pre>
int Factorial(int number){
    if (number == 1){
        return 1;
    }
    else {
        return number * Factorial(number -1);
    }
}
</pre>
　　这种情况下用递归运行速度慢，无法预测运行期间内存的使用情况，并且更不容易理解。
*'''示例：用循环计算阶乘'''
<pre>
int Factorial(int number){
    int intermediateResult = 1;
    for(int factor = 2; factor <= number; factor++){
        intermediateResult =intermediateResult * factor;
    }
    retuen intermediateResult;
}
</pre>

====17.3 goto                   （兰杰）====
=====要在特定场合下谨慎地使用goto（C6616 兰杰）=====

*goto的坏处
**还有goto的代码很难安排好格式，影响逻辑结构
**goto会破换编译器的优化特性，使流程变得难以分析
*goto的好处
**如果位置恰当，goto可以减少重复的代码
**某些情况下会让代码的运行速度更快，体积更小
**goto用在执行清理操作，可以减少忘记释放资源的可能

=====goto代码重写很容易出错（C6616 兰杰）=====

*'''''C++示例：看上去很容易就能重写为不使用goto是代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) ) {
      goto LOOP_EXIT;
    }
    Dosomething( data );
}  whlie ( data ！= -1);
LOOP_EXIT;
</pre>

*'''''去掉了goto的所谓等价代码'''''
<pre>
 GetData( inputFile, data );
while ( ( !eof(inputFile) ) && ( ( data ! = -1 ) ) ) { //检测到-1，退出循环而不执行Dosomething（）
   Dosomething( data );
   GetData( inputFile, data ); 
}
</pre>

*'''''去掉了goto的真正等价代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) )  {
      Dosomething( data );//检测到-1之前，执行Dosomething（）
   }
}while { ( data != -1 ) && ( !eof( inputFile ) ) );
</pre>

=====分配和清理时使用goto利大于弊（C6616 兰杰）=====
<pre>
*'''''Visual Basic示例：处理错误以及释放资源的带goto代码'''''
errorState = fileStatus_Sussess
fileIndex = 0
While { fileIndex < numFilesToPurge } //获得一个需要清除的文件列表时检测错误状态
       fileIndex = fileIndex + 1
	If Not ( FindFile ( fileList ( fileIndex),numFilesToPurge ) )Then
  	    errorState = FileStatus_FileFindError
   	GoTo END_PROC
     End If
	If Not OpenFile( fileToPurge ) Then   //打开文件列表时检测错误状态
       		errorState = FileStatus_FileOpenError
   	GoTo END_PROC
      End If  
	If Not OverWriteFile( fileToPurge ) Then  //覆盖其内容时检测错误状态
       		errorState = FileStatus_FileOverWriteError
   	GoTo END_PROC
      End If 
	If Not Erase( fileToPurge ) Then     //删除时检测错误状态
       		errorState = FileStatus_FileEraseError
   	GoTo END_PROC
       End If
    End While

END_PROC:     //这是goto的label
    DeletePurageFileList( fileList, numFileToPurge ) 

</pre>

当子程序需要为数据库连接、内存或临时文件执行分配和清理操作的时候，如果不用goto，
通常就需要重复写出清理资源的代码。维护重复代码带来的麻烦比使用goto的弊端大。




=====可以用if嵌套语句重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用嵌套的if语句消除goto代码'''''
<pre>
   errorPurgeFileList( fileList, numFileTopurge )
   errorState = FileStatus_Success
   fileIndex = 0
   While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success )
       fileIndex = fileIndex + 1
  If FindFile( fileList ( fileIndex),numFilesToPurge ) ) Then
      If  OpenFile( fileToPurge ) Then
          If OverWriteFile( fileToPurge ) Then
             If Not Erase( fileToPurge ) Then
                errorState = FileStatus_FileEraseError
          End If
      Else 
          errorState = FileStatus_FileOverWriteError
      End If
  Else
      errorState = FileStatus_FileOpenError
  End If
Else
    errorState = FileStatus_FileFindError
End If

End While
DeletePurageFileList( fileList, numFileToPurge )

</pre>
如示例这样嵌套，使嘚仅当一条if语句检测成功时才执行下一条if语句，这是标准的消除goto的编程方法。
这样做最大的缺点在于嵌套太深，必须把整个嵌套装入大脑才能理解。

=====可以用一个状态变量重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用状态变量消除goto代码'''''
<pre>
   errorPurgeFileList( fileList, numFileTopurge )
   errorState = FileStatus_Success
   fileIndex = 0
   While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success )// while判断增加了对errorstate的判断
       fileIndex = fileIndex + 1
  If Not ( FindFile ( fileList ( fileIndex),numFilesToPurge ) )Then
  	    errorState = FileStatus_FileFindError
   	GoTo END_PROC
     End If
     If ( errorState = FileStatus_Success ) Then //这里判断了状态变量
	If Not OpenFile( fileToPurge ) Then   
       		errorState = FileStatus_FileOpenError
   	GoTo END_PROC
      End If
     If ( errorState = FileStatus_Success ) Then  //这里判断了状态变量
	If Not OverWriteFile( fileToPurge ) Then  
       		errorState = FileStatus_FileOverWriteError
   	GoTo END_PROC
      End If 
     If ( errorState = FileStatus_Success ) Then//这里判断了状态变量
	If Not Erase( fileToPurge ) Then     
       		errorState = FileStatus_FileEraseError
   	GoTo END_PROC
       End If
    End While
    DeletePurageFileList( fileList, numFileToPurge )
</pre>
*这样做的优点在于，没有使用深层嵌套，读起来比较容易，同时，与嵌套if相比，if—then—else
检测后面的操作与该检测的距离更近，避免使用了else子句。
*缺点在于，使用状态变量的方法应用不够普遍。应该对它们的用法充分说明，否则别人可能
不懂你的意思





=====可以用try-finally重写goto（C6616 兰杰）=====

*'''''Visual Basic示例：利用try-finally消除goto代码'''''
<pre>
  MakePurgeFileList( fileList, numFilesToPurge )
  Try
     fileIndex = 0
     while ( fileIndex < numFilesToPurge )
        fileIndex = fileIndex + 1
        FindFile ( fileList ( fileIndex),numFilesToPurge ) 
        OpenFile( filesToPurge)
        OverwriteFile( FilesToPurge)
        Erase（ FilesToPurge）
      End While
   Finally
       DeletePurageFileList( fileList, numFileToPurge )
End Try   
</pre>
*这种方法优点在于，它比使用goto简单的多，没有用到goto也没有用到深层嵌套结构
*缺点在于，必须所有代码持续一致的使用这种方法，否则产生的代码会很复杂。




=====使用这4种方法更有优劣（C6616 兰杰）=====

{| border="1" style="border-collapse;"
!方法
!优点
!缺点
|-
||使用goto
||避免了深层嵌套和不必要的检测
||使流程变得难以分析
|-
||嵌套if
||避免了使用goto
||增加了子程序的复杂度
|-
||状态变量
||避免了使用goto和深层嵌套
||引入了额外的检测
|-
||try-finally
||避免了使用goto和深层嵌套
||不是所有语言都支持
|}


=====不要用goto共享else子句中的代码（C6616 兰杰）=====
*'''''坏例子'''''
<pre>
  if ( statusOK ){
     if ( dataAvailable ){
        importVariable = x ;
        goto MID_LOOP;//借助goto共享else子句的一段代码
      }
   }
  else{
     importantVariable = GetValue();

     MID_LOOP;

    // lots of code
  }
</pre>
这样的话逻辑非常曲折，照这个样子，想读懂它几乎是不可能的，想不用goto而正确
地重写也非常难。


*'''''好例子'''''
<pre>
    if ( statusOK ){
     if ( dataAvailable ){
        importVariable = x ;
        DoLotsOfCode( importantVariable );//在这里调用放公共代码的子程序
      }
     }
    else{
         importantVariable = GetValue();
         DoLotsOfCode( importantVariable );
     }
</pre>
将公共代码放到子程序中，就可以在原goto语句出现或跳转的地方调用该子程序，同时
保留原有的条件结构




=====可以重新组织判断语句结构来共享代码（C6616 兰杰）=====

通常，写一个新的子程序是最好的方法，但是有时候把重复的代码提取成单独的子程序是
不显示的。这时可以通过重新组织判断语句结构来解决该问题

*'''''C++示例：不使用goto共享else子句中的代码'''''
<pre>
if (  （statusOK && dataAvailable ) ll !statusOK { //可以去掉一个statusOK的检测
   if ( statusOK && dataAvailable ){  //可以去掉dataAvailable的检测
     if ( dataAvailable ){
        importVariable = x ;
      }
   else{
     importantVariable = GetValue();
   }
  
    // lots of code
 }
</pre>
这种对goto版本代码的转换比较可靠，也很机械，它检测了两statusOK ，多检测了一次
dataAvailable，不过代码实现的功能是一样的。


=====goto不到不得已的情况下不要使用（C6616 兰杰）=====
*在那些不支持结构化控制语句的语言里，用goto去模拟那些控制结构是应准确，
不要滥用goto带来的灵活性
*如果语言内置了等价的控制结构，那么就不要使用goto
*如果能为代码提升效率，并对效率的提升作出说明，可以使用goto，大多数情况下不要用
*除非你要模拟结构化语句，否则尽量在每个子程序内只使用一个goto标号。
*除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转。
*确认所有的goto标号都被用到了。
*确认goto不会产生某些执行不到的代码
*对某一个goto用法所展开的争论并不是事关全局的。如果程序员知道存在替换方案，并且
愿意为使用goto辩解，那么用goto也无妨


====17.4 针对不常见控制结构的观点  （兰杰）====
=====对非传统的控制结构应持怀疑态度（C6616 兰杰）=====

*不加限制地使用goto
*能动态计算出goto跳转目标并且执行跳转
*通foto从一个子程序中部跳到另一个子程序中部
*根据行数或标号调用子程序，从而允许代码从子程序中间某个位置开始执行
*具备让应用程序动态生成代码并且执行这些代码的能力
这些想法看起来离奇，但曾经都被认为是可以接受的。很大程度上，软件开大这一领域实在限制程序员
对代码的使用中得到发展的。

=====不常见控制结构使用时应多加小心（C6616 兰杰）=====
*多个return可增加程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心，
如果在读子程序后期时，你没有意识到它从前面某个地方返回的可能性，想理解这个子程序就很困难。
*递归能够很优雅的解决一小部分问题。但对于大多数问题，它所带来的解将是极其复杂的，对它的使用也要倍加小心。
*在少数情况下，goto是编写可读性和可维护代码的最佳方法，但这种情况非常罕见。除非万不得以，不要使用goto。



=== 第18章 表驱动法===

====18.1 表驱动法使用总则         （梁运）====
=====不要使用复杂的逻辑代码=====
*当遇到想把字符、划分为字母、标点符号、和数字三类，使用复杂的逻辑链是错误的。
'''错误示例代码'''
<pre>
if(
   (('a'<=inputChar)&&( inputChar<='z'))||(('A'<=inputChar)&&( inputChar<='Z'))
  )
{
 charType=CharacterType.Letter;
}
else if ((inputchar==' ')||(inputChar==',')
	 ||(inputChar=='.')|| (inputChar=='!')
	 || (inputChar=='(')|| (inputChar==')') 
	 || (inputChar==':') || (inputChar==';')
	 || (inputChar=='?') || (inputChar=='-')
        )
{
 charType=CharacterType.Punctuation;
}
else if (('0'<= inputChar)&&( inputChar<='9'))
{
 charType= CharacterType.Digit;
}
</pre>
=====解决方法=====
*把每一个字符的类型保存在一个用字符编码访问的数组里。
'''正确示例代码'''
<pre>
charType= CharTypeTable[inputChar];
</pre>
====18.2 直接访问表              （梁运）====
=====IF语句的劣势=====
*当需要计算每个月的天数时，笨拙的方法就是直接写一个大的IF语句。
'''错误示例代码'''
<pre>
IF(month=1)Then
  days=31
ElseIf(month=2)Then
  days=28
ElseIf(month=3)Then
  days=31
ElseIf(month=4)Then
  days=30
ElseIf(month=5)Then
  days=31
ElseIf(month=6)Then
  days=30
ElseIf(month=7)Then
  days=31
ElseIf(month=8)Then
  days=31
ElseIf(month=9)Then
  days=30
ElseIf(month=10)Then
  days=31
ElseIf(month=11)Then
  days=30
ElseIf(month=12)Then
  days=31
End If
</pre>

=====直接索引方法的步骤===== 
*更简单容易的方法就是把这些数据存到一张表里面。在Microsoft Basic里面，需要首先创建这张表：
'''正确示例代码'''
<pre>
' Initialize Table of "Days Per Month" Data
Dim daysPerMonth() As Integer = _
    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
</pre>
=====数组访问语句===== 
*现在，你无须在写那么长的if语句，只需要用一条简单的数组访问语句就可以得出每个月中的天数了。
'''正确示例代码'''
<pre>
days = daysPerMonth( month-1 )
</pre>
=====查表遇到特殊情况的解决方法===== 
*如果你想把查表的版本中再把闰年考虑进去，那么代码仍然会很简单，建设LeapYearIndex()的取值要么为0，要么为1；
'''正确示例代码'''
<pre>
days = daysPerMonth( month-1, LeapYearIndex() )
</pre>
*如果把闰年也考虑进来，那么长长的if句将会变得更为复杂了。
*计算每月的天数是一个很适合用直接访问表描述 的例子，因为你可以用month变量去表里面查询记录。一般来说，你可以用原本控制着很多if语句的书记去直接访问表。


=====声明数据建表===== 
*医疗保险费率的程序，是随着很多的不同情况在变化的，如果用逻辑结构就会很复杂，更好的方法是把这些费率都存入所有因素索引的数组里。
'''正确示例代码'''：
<pre>
Public Enum SmokingStatus
 SmokingStatus_First=0
 SmokingStatus_Smoking=0
 SmokingStatus_NonSmoking=1
 SmokingStatus_Last=1
End Enum
Public Enum Gender
 Gender_ First=0
 Gender_Male=0
 Gender_Female=1
 Gender_Last=1
End Enum
Public Enum MaritalStatus
 MaritalStatus_ First=0
MaritalStatus_Single=0
MaritalStatus_Married=1
MaritalStatus_Last=1
End Enum
Const MAX_AGE As Integer=125
Dim rateTable (SmokingStatus_Last,Gender_Last,MaritalStatus_Last,_MAX_AGE)As Double
</pre>

=====存数据的方法=====
*声明之后，可使用赋值语句，读入数据、计算出这些数据、或者执行合适的操作。备好数据后，就可以用更简单的方法取而代之：
'''示例代码'''
<pre>
rate =rateTable(smokingStatus,gender,maritalStatus,age)
</pre>
*这种方法可读性好，也更容易修改。

=====灵活的消息格式=====
*假如需要编写一个子程序，通常会有500条消息，每份文件大约有20中不同的消息。这些消息源于一些浮标，提供有关水温、浮标位置等信息。
*每一条消息都有若干字段，并且每条消息都有一个消息头，其中有一个ID，告诉你该消息属于哪一种。
*这些格式不是固定不变的，它们由你的客户来决定。

=====基于逻辑的方法的劣势(C6632梁运)=====
*有的时候，基于逻辑的方法，需要很多步骤，很多的底层子程序去支持它，用面向对象的方法也好不到哪里去。
*通常我们会用一种抽象的消息对象，并为每种消息类别派生出一个子类。
'''错误示例代码'''
<pre>
While more message to read
  Read a message header
  Decode the message ID from the message header
  If the message header is type 1 then
    Print a type 1 message 
  Else if the message header is type 2 then
    Print a type 2 message
  ...
  Else if the message header is type 19 then
    Print a type 19 message
  Else if the message header is type 20 then
    Print 1 type 20 message     
</pre>
*如上还是简化过的代码，但是无须看完所有情况，就可以看出路数，每次有一种格式变了，就不得不修改负责处理该消息的子程序或者累的逻辑。
=====面向对象的方法劣势(C6632梁运)=====
*面向对象的方法，在特定情况，基本结构同样复杂，因为无论是直接写逻辑，还是把它包含在特定的类里，每种消息都有自己的子程序，新增一种消息类型都要去修改代码。
'''错误示例代码'''
<pre>
While  more message to read 
  Read a message header
  Decode the message ID from the message header
  If the message header is type 1 then
    Instantiate a type 1 message obect
  Else if the message header is type 2 then
    Instantiate a type 2 message object
 ...
  If the message header is type 19 then
    Instantiate a type 19 message obect
  Else if the message header is type 20 then
    Instantiate a type 20 message object
  End if
End While
</pre>
'''好方法：'''<br>
*表驱动法比前面两种方法都要方便、经济。其中的消息子程序由循环组成，它负责读入消息头,再对ID解码，一种表就可以描述每种消息的格式，无须修改代码就可以轻松的进行维护。

=====表驱动法定义消息数据类型(C6632梁运)=====
*在【基于逻辑的方法】和【面向对象的方法劣势】的心得部分，已经分析表驱动法比这两种方法都经济的原因，接下来最重要的是学会如何使用这种好方法:
*我们需要先列出消息的种类和字段类型。在C++中，可以按照下面的方法来定义所有可能的字段类型：
''' C++代码示例'''
<pre>
enum FieldType 
{
 FieldType_FloatingPoin,
 FieldType_Integer,
 FieldType_String,
 FieldType_TimeOfDay,
 FieldType_Boolean,
 FieldType_BitField,
 FieldType_Last = FieldType_BitField
};
</pre>
*上面这段代码就是定义消息数据类型的方法，我们不需要再为多种消息中的每一种硬编码打印子程序。
*我们只需要创建少数几个子程序，分别负责打印每一种基本数据类型就可以了。这样可以更直观的看出这种方法的便捷性。

=====定义消息表中的一项的方法(C6632梁运)=====
*我们可以把每种消息的内容描述放在一张表里，包括每个字段的名称啊之类的，然后再根据表中的描述来分别解释每一消息。
*可以参考下面的用于描述一种消息的表记录的示例：
'''代码示例'''
<pre>
Message Begin
   NumFields 5
   MessageName "Buoy Temperature Message"
   Field 1, FloatingPonit, "Average Temperature"
   Field 2, FloatingPoint, "Temperature Range"
   Field 3, Integer, "Number of Samples"
   Field 4, String, "Location"
   Field 5, TimeOfDay, "Time of Measurement"
Message End
</pre>
*我们既可以把表硬编码在程序里，也可以在程序启动时或者随后从文件中读出。

=====表驱动法优点小结(C6632梁运)=====
*当我们把消息定义读入程序，我们就能把所有的消息嵌入在数据里面，而不用嵌入在程序的逻辑里面了。
*数据要比逻辑更加灵活。因为当消息格式改变的时候，修改数据是很容易的。如果必须要新增一种消息类型，那么只须往数据表里再增加一项元素就可以。

====18.3 索引访问表              （黄佳欣）====
====索引访问表心得====
*数据库检索方法索引访问介绍：
'''坏方法：'''<br>
直接通过检索条件检索这个表，遍历整个表，从而找到这条数据。<br>
'''好方法：'''<br>
用数据库表建立一个索引表（包含了这个表个表中一列或者
若干列值的集合，不是必须用主键，可以确定这条数据的唯一
性就可以）。<br>
例如：
SELECT NAME FROM TABLE_TEST WHERE ID = '10000';。<br>
没有索引:必须遍历整个表，直到ID等于10000的这一
行被找到为止；<br>
有索引:即可在索引中查找到这条数据的位置。由于索引是经过
某种算法优化过的，因而查找次数要少的多。
*索引的优点:
占用的总内存量少
可以大大加快数据检索速度。
通过创建唯一索引，可以保证数据记录的唯一性。
更容易维护。
====18.4 阶梯访问表              （黄佳欣）====
====阶梯访问表心得====
*基本思想：对数据进行区间划分，再该区间内的是一类数据，然后在该区间
内找到这个数据。
适用于无规则的数据。像分数等级划分，电费等级的划分。
*阶梯的优点：
节约存储空间，加快数据检索速度（慢于索引）。
*使用阶梯访问表时需要注意的一些细节：
留心端点<br>
考虑用二分查找取代顺序查找<br>
考虑用索引访问来取代阶梯技术<br>
把阶梯表查询操作提取成单独的子程序<br>
====18.5 表查询的其他示例         （黄佳欣）====
====由内而外，创建循环体心得====
'''坏方法：'''<br>
循环体的创建我们通常会从FOR循环开始想起，然后在写循环体。
写一个复杂的循环，这样的方法是耗时间，还容易出错的。<br>
'''好方法：'''<br>
先从循环体开始思考，先建立好循环的内部循环程序，最后加上for循环
，然后缩进代码。这样的方法在面对比较复杂的循环时，可以减少代码和
思维上的错误。保证循环的准确性和节约编码的时间。（不是必须要着
样做，对于比较简单的循环来说，一直顺手写也是很快。）
====低效代码的优化心得====
*低效代码的发生只要是不必要的输入\输出。
像大量的磁盘、数据库、网络文件访问。在硬件设施保证的情况下可
以在内存中处理的文件就不需要这样费力了。
*编程语言的原因。
编译型(C++、VB、C#)<字节型(JAVA)<解释型(PHP、Python)
，适当的编程语言可以大量的节约程序运行时间。
*较常见原因。
参数运算，(a+1)>(a++)。
多余的逻辑运算：(&、&&)和(|、||).(&&和|| 有短路的功能，可以节约
逻辑运算的时间)
====书本衍生的代码程序优化想法====
*代码量的缩减：例如：从一个集合或者数组中取对象可以
直接用增强FOR循环取。
*参数精度：可以用int类型的，就不必要用double或者更高精度的
类型定义。
*变量的重复定义。例如：在FOR循环中定义一个可以在FOR循环外定
义的变量。
*大量的不必要变量定义和变量的赋值。
=== 第19章 一般控制问题===
====19.1 布尔表达式              （李腾飞）====
*在布尔表达式中要用标识符true和false，而不是0和1等数值，隐式地比较布尔值与true和false。
'''错误示例代码'''
<pre>
Dim printerError As Integer
Dim reportSelected As Integer
Dim summarySelected As Integer
...
If printerError = 0 Then InitializePrinter ()
If printerError = 1 Then NotifyUserOfError ()

If reportSelected = 1 Then PrintReport ()
If summarySelected = 1 Then PrintSummary ()

If printerError = 0 Then CleanupPrinter ()
</pre>
'''正确示例代码'''
<pre>
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()
</pre>
通过这样可以明确你在执行一个布尔判断，使用隐式比较能减少阅读代码时需要记住的项数。
*简化复杂的表达式
拆分复杂的判断并引入新的布尔变量，把中间结果赋给变量
'''复杂的判断'''
<pre>
If ( ( document.AtEndOfStream ) And ( Not inputError ) ) And _
  ( ( MIN_LINES <= lineCount ) And ( lineCount <= MAX_LINES ) ) And _
  ( Not ErrorProcessing( ) ) Then
 ' do something or other
...
End if
</pre>
'''去掉复杂判断后'''
<pre>
If ( DocumentIsValid( document, lineCount, inputError ) ) Then
' do something or other
...
End If
</pre>
假设ErrorProcessing()是一个可以表明当前处理状态的布尔函数，那么阅读代码时就可以忽略那个复杂判断，这样代码就会简洁易懂了。

====19.1 布尔表达式              （陈欢欢）====
*代码中不要使用1和0表示代码
**代码中用1和0表示意思不清晰，根本没有反映究竟1代表是真，0代表假，还是正好相反，甚至1和0是不是代表真假都不清楚。读到代码的时候，往往不能在第一时间，快速的了解代码所表达的含义
*用隐式布尔值，不用隐式的true和false
**把表达式当做布尔表达式，可以写出更清晰的判断语句，如下图的Visual Basic示例中的0和1代表的不是布尔标示
<pre>
Visual Basic示例，使用True和False代替数值来作判断用(很好，但不是最好)
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()//非布尔标示
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()//非布尔标示
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()//非布尔标示
</pre>
<pre>
Java示例
If (printerError=="False")//不存在printerError
</pre>
*不支持布尔变量，无法使用
**通过使用隐式表示，能够减少阅读代码所必须的项数,这样写出的表达式读起来也更加的简单易读懂。如上图所示的If (printerError=="False")语句中就是使用的隐式表达标示，如果是使用0和1的方式表示，还有去追究0和1分表代表的含义，但是若是使用隐式表示的方式，给代码的阅读带来了便利，从而减少了工作量




*不要用庞大的的复杂判断
**拆分复杂的判断，然后引入新的布尔变量，从而将中间结果赋给变量，是的判定变的更加简单。而且这样可以使得命令能起到简化复杂度，提高执行效率的效果
*不要用复杂的判定条件,使用决策表
**决策表的使用类似于数组的使用方法
**有时候一个很复杂的判断，涉及的变量很多。用决策表代替if或者case等复杂的语句执行，只需要几行代码就能对于判断有帮助。还能减低复杂度，极大程度的降低出错的可能
**表查询方法有：直接访问、索引访问、阶梯访问
*判断条件不要以否定形式
'''坏代码'''
<pre>
Java示例：否定形式
if(!statusOk){//(除了!statusOk以外的情况，测试的重点是非特别情况)
  // do something——A处
  ...
}
else{ 
  // do something else——B处
  ...
}
</pre>
'''好代码'''
<pre>
Java示例：肯定形式
if(statusOk){//(除了statusOk的情况,剔除特定的情况)
  // do something ——B处 
  ...
}else{
  // do something else——A处
  ...
}
</pre>


====19.2 复合语句（语句块）       （李腾飞）====
====把括号对一起写出，用括号来把条件表达清楚====
*先写块的开始和结束部分，之后填充中间部分。
例如：
*先写
<pre>
for ( i = 0; i < maxLines; i++ )
</pre>
*再写
<pre>
for ( i = 0; i < maxLines; i++ ) { }
</pre>
*最后写
<pre>
for ( i = 0; i < maxLines; i++ ) {
   // whatever goes in here ...
}
</pre>
这种方法适用于所有的块结构，用语句块时一定要清楚的表达你的用意，无论块内的代码行数是1还是20.
====19.3 空语句                  （时昌彬）====
=====空语句并不多见，因此应突出这种用法=====
*空语句，即一条仅含有分号的语句
'''C++实例：传统的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））
;
</pre>
*空语句并不多见，因此应突出这种用法，方法之一是用一组空的括号来强调空语句。
'''C++实例：加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{ }
</pre>
*另外可以让空语句中的分号自占一行，并加以缩进来强调空语句。		
'''C++实例： 加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{
	;
}
</pre>
=====为空语句创建一个DoNothing（）预处理宏或者内联函数=====
*这条语句什么也不做，但却能毫无争议的表明“这里希望不做任何事情”的用意。下面就是C++中如何使用#define来定义空语句
'''C++实例： 用DoNothing（）来强调空语句'''
<pre>
#define DoNothing()
...
while (recordArray.Read( index++) != recordArray.EmptyRecord()){
	DoNothing();
}
</pre>
除了在空的while和for循环中使用DoNothing(),你也可以在switch语句中的无意义选项中使用它；加入DoNothing()表明你已经考虑了这种case，并且的确不需要对该case做什么操作。

====19.4 驯服危险的深层嵌套        （时昌彬）====
=====避免使用超过3到4层的嵌套=====
*很少有人能够理解超过3层的if嵌套，很多研究人员建议避免使用超过3到4层的嵌套。
*把嵌套if转换成一组if-then-else语句
'''Java实例：坏代码'''
<pre>
if (10 < quantity){
	if(100 < quantity）{
		if(1000 < quantity){
			discount = 0.01;
    		}
		else{
			discount = 0.05;
		}
	}
	else{
		discount = 0.025;
	}
else{
	discount = 0.0
}
</pre>
出现多层嵌套的原因是其中的判断逻辑组织的很差，这些判断中有许多冗余。当判断了quantity是否大于1000的时候，
就不需要再去判断他是否大于100并且大于10。因此可以重新组织这段代码：
'''Java实例： 好代码'''
<pre>
if (1000 < quantity){
	discount = 0.01;
}
else if (100 < quantity){
	discount = 0.05;
}
else if (10 < quantity){
	discount = 0.025;
}
else{
discount = 0.0;
}
</pre>

=====把嵌套if转换成case语句=====
*你可以用case语句重写一些判断，特别是那些含有整数的判断，而不是去用一长串if和else。
'''Visual Basic实例：将嵌套if语句转换成case语句'''
<pre>
Select Case quantity
	Case 0 to 10
		discount = 0.0
	Case 11 to 100
		discount = 0.025
	Case 101 to 1000
		discount = 0.05
	Case Else
		discount = 0.10
End Select 
</pre>
有些语言中你无法使用这种方法，但是对那些可以使用case的语言来说，这是一种功能强大的技术。

=====把深层嵌套的代码抽取出来放进单独的子程序中=====
'''C++实例：将嵌套代码分解到子程序的好代码'''
<pre>
while(!TransactionsComplete()){
	//read Transaction record
	transaction = ReadTransaction();
	// process transaction depending on type of transaction
	if (transaction.Type == TransactionType_Deposit){
		ProcessDeposit(
			Transaction.AccountType,
			Transaction.AccountSubType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else if (transaction.Type == TransactionType_Withdrawal){
		ProcessWithdrawal(
			Transaction.AccountType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else if (transaction.Type == TransactionType_Transfer){
		MakeFundsTransfer(
			Transaction.SourceAccountType,
			Transaction.TargetAccountType,
			Transaction.AccountNum,
			Transaction.Amount
		);			
	}
	else{
	//process unknown Transaction type
	LogTransactionError("Unknown Transaction Type", transaction);
	}
}
</pre>
这里没有给出新的子程序。
*把深层嵌套的代码抽取出来放进子程序，使代码结构更简单并容易理解。其次你可以在一个屏幕里阅读，修改和调试这个while循环——它不再跨越好几屏，或者超出打一字的边界。


=====重新设计深层嵌套的代码=====
*一些专家认为，在面向对象的程序设计中出现case语句，就说明代码没有做好分解，因此实际上极少有必要使用case语句。
*更一般的说法是，复杂的代码表明你还没有充分的理解你的程序，所以无法简化它。深层嵌套是一个警告，他告诉你要么应该拆分出一个子程序，要么应该重新设计那部分复杂的代码。


====19.5 编程基础：结构化编程      （陈欢欢）====
*“结构化”包括结构化分析、结构化设计以及结构化混日子
**'''*除了都创建于“结构化”被广泛推崇的时代之外，这些状态各异的结构化方法学之间并没有多少相互联系'''
*核心思想很简单
**一个应用程序应该只采用一些单入单出的控制结构（也称单一入口、单一出口的控制结构）
***'''*单入单出的控制结构指一个代码块，只有一个执行开始点与执行结束点'''
*执行方式是有序的且有规则的
*结构化编程的三个组成部分:顺序、选择、迭代
*顺序
<pre>
Java示例：顺序
//a sequence of assignment statements
a=”1”;
b=”2”;
c=”3”;

//a sequence of calls to routines
System.out.println(a);
System.out.println(b);
System.out.println(c);
</pre>
*选择是一种有选择的执行语句的控制结构:if-then-else,case
<pre>
Java示例：选择
//selection in an if sttement
If(totalAmount>0.0){
  //do something
  ...
}
else{
  //do something
  ...
}

//selection in a case statement
switch(commandShortcutLetter){
   case ‘a’:
      PrintAnnualReport();
      break; 
   case ‘q’:
      PrintAnnualReport();
      break;  
   case ‘s’:
      PrintAnnualReport();
      break;
default:
DisplayInternalError(“Internal  Error 905:Call customer support”);
}
</pre>
*迭代——是一组语句多次执行的控制结构（也称循环）
<pre>
Visual Basic示例：迭代
‘ example of iteration using a For loop
For index=first To last
   DoSomething (index)
Next

‘ example of iteration using a while loop
index=first
While(index<=last)
   DoSomething (index)
   Index=index+1
Wend

‘ example of iteration using a loop-with-exit loop
index=first
Do
   If(index>last) Then Exit Do
   DoSomething(index)
   Index=index+1
Loop
</pre>
*结构化编程的中心论点——任何一个控制利用可以有顺序、选择和迭代三种结构构成
=====结构化编程的组成部分——顺序（时昌彬）=====‪
*结构化编程的核心思想就是单入单出的控制结构，即一个代码块它只能从一个位置开始执行，并且只能结束于一个位置。它有3个组成部分。
*"顺序"是指一组按照先后顺序执行的语句。典型的顺序型语句包括赋值和调用子程序。
'''Java示例: 顺序'''
<pre>
string a = "1";
int b = 2;
string c= "3";
System.out.println(a);
System.out.println(b);
System.out.println(c);
</pre>

=====结构化编程的组成部分——选择（时昌彬）=====
*选择是一种有选择的执行语句的控制结构。if-else就是一个常见的例子。要么执行if子句，要么执行else子句，二者不会同时执行。
'''Java示例: 选择'''

<pre>
if ( a > 0 ){
//do something
...
}
else{
//do something else
}
</pre> 

=====结构化编程的组成部分——迭代（时昌彬）=====
*迭代，即循环，是一种使一组语句多次执行的控制结构。while和for就是经典的迭代
'''Java示例 迭代'''
<pre>
for (int i = 0 ,i < arr.length, i++ ){
	//do something
	...
}
</pre>
'''Java示例：迭代'''
<pre>
while(count < arr.length){
	//do something
	...
	count++
}
</pre>
*任何一种控制流都可以有由顺序，选择和迭代这三种结构生成

====19.6 控制结构与复杂度         （陈欢欢）====
*控制结构的作用是降低复杂度
*程序复杂度决定了理解程序所需要花费的精力
*控制流是影响复杂度的大因素之一
**'''*与控制流有关的复杂度非常重要——与不可靠的代码和频繁出现的错误息息相关'''
*度量复杂度——计算子程序的“决策点”的数量来衡量复杂度
<pre>
决策点的计算方式：
(1)决策点初始值为1；
(2)遇到一次if，while，repeat，for，and，or决策点就加1
(3)Case语句中的每一种情况加1
</pre>
<pre>
处理复杂度的度量结果
（1）0-5 子程序可能还不错
（2）6-10 得想办法简化子程序了
（3）10+ 把子程序的某一部分拆分成另一个子程序并调用它
</pre>
*将子程序提取到另一个子程序，不会降低整个程序的复杂度，只是降低在同一时间必须关注的复杂度水平
*其他度量方法——所用的数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码行数（跨度）、变量生存的代码行数（生存期）以及输入的输出的量