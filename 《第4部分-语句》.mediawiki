=== 参加人员 ===

时昌彬  郭思  黄佳欣  兰杰  陈渊  何刚  刘思  徐杰  李腾飞  陈欢欢  梁运  共计11人


=== 第14章 组织直线型代码=== 

====14.1 必须有明确顺序的语句      （陈渊）====
14.1 必须有明确的语句顺序心得:
那么有明确语句顺序的代码好处在哪呢，下面通过一个有明确顺序的代码和没有明确顺序代码的实例，我们会一目了然的发现有明确顺序的代码的优点。<br>
<pre>
例1（有明确顺序）
date = ReadData();
results = =CalculateResultsFromData(date );
PrintResults(results );
</pre>
<pre>
例2（没有明确顺序）
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
</pre>

从上面的两个例子可以很好地看出例的优势，通俗易懂，而且逻辑方面也层层相扣，大大提高了代码的正确性，可读性和可维护性。

那我我们所要做的就是讲自己写的代码有意识的携程有顺序条理清晰的的代码现在，通过一个例子的展现如何改进写的代码的可读性。<br>
<pre>
InitializeExpenseData
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary
</pre>

*加注释对不清晰的依赖关系进行说明<br>
<pre>
InitializeExpenseData//计算Expense数据
ComputeMarketingExpense//四个子程序访问了ExpenseData数据成员
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary//调用了四个子程序访问了ExpenseData数据成员后的数据
</pre>

*'''加参数明确显示依赖关系（推荐）'''<br>
<pre>
expenData = InitializeExpenseData（expenData）;
marketingExpenData = ComputeMarketingExpense（expenData）;
salesExpenData = ComputeSalesExpense（expenData）;
travelExpenseData = ComputeTravelExpense（expenData）;
personnelExpenseData = ComputePersonnelExpense（expenData）;
DispalyExpenseSummary（marketingExpenData,salesExpenData,travelExpenseData,personnelExpenseData）;
</pre>

*用断言或者错误处理代码来检查依赖关系<br>
就是可以再在类的成员变量里将isExpenseDataInitialized设为false,然后再InitializeExpenseData（）中将isExpenseDataInitialized设为true,在下面四个函数对expenData进行操作之前，看看isExpenseDataInitialized是否为true,但是我觉得因为引入新的变量、新的初始化，就变得复杂也不是很好理解，还会增加错误，所以不是很推荐。

====14.2 顺序无关的语句           （陈渊）====

14.2 顺序无关的语句心得
其中最最重要的一点就是：要把相关的操作都放在一起。要让别人轻松的读懂你的代码，就要让你的程序易于自上而下的阅读，不能让读者去大量的代码中去搜寻他想要的信息，举一个例子:<br>
<pre>
MarketingData marketingData;
SalesData salesData;
TravelData travelData;

travelData.computeQuarterly();
salesData.computeQuarterly();
marketingData.computeQuarterly();

marketingData.computeAnnual();
salesData.computeAnnual();
travelData.computeAnnual();

salesData.Print();
travelData.Print();
marketingData.Print();
</pre>

上面的代码跳来跳去的让人看了很不舒服，如果放在一大堆的代码里，读者估计得花很长时间去搜寻他想要的信息如果想知道travelData是怎么来的，那他就得全局去搜，而且还会想，用到的地方是不是就仅仅只有这几个呢，给阅读带来了很大的不便，要是我们能做到把相关的操作放一起，那效果就不一样了。<br>
<pre>
MarketingData marketingData;
marketingData.computeQuarterly();
marketingData.computeAnnual();
marketingData.Print();

SalesData salesData;
salesData.computeQuarterly();
salesData.computeAnnual();
salesData.Print();

TravelData travelData;
travelData.computeQuarterly();
travelData.computeAnnual();
travelData.Print();
</pre>

如过我们改成了上面的代码，把相关的的语句组织到一起，放在一起，那么对代码的可读性、可维护性有了大大的提升

=== 第15章 使用条件语句===

====15.1 if语句                  （何刚）====
*'''写if语句时，首先写正常代码路径；再处理不常见情况'''
    在编写代码时，要使的正常情况的执行路径在代码中是清晰的。要确保那些不常见的情况不会遮掩正常的执行路径。这对可读性和代码性能来说都很重要。
*'''把最常见的情况放在最前面'''
    把最常见的情况放在前面，可以让阅读的人为找出正常情况的处理代码而必须要读的非常见情况的代码边的最少。同时，由于把在执行最常见情况代码之前所需的判断减到最少，代码效率也得到了提高，就像下面一样：
<pre>
If ( IsLetter( inputCharacter ) ) {                //最为常见的情况会先在这里得到处理
  CharacterType = CharacterType_Letter;
}
else if ( IsPunctuation( inputCharacter ) ) {
  CharacterType = CharacterType_Punctuation;
}
else if ( IsDigit( inputCharacter ) ) {
  CharacterType = CharacterType_Digit;
}
else if ( IsCotrolCharacter( inputCharacter ) ) {      //最不常见的情况则是放在最后来解决
  CharacterType = CharacterType_CotrolCharacter;
}
</pre>

*'''把正常情况的处理放在if后面而不要放在else后面'''
    把认为会正常出现的情况放在前面处理，这符合把决策的结果代码放在尽可能靠近决策位置的一般原则。
*'''''坏代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Error ) Then 
  errorType = FileOpenError            //出错情况
Else 
  ReadFile ( inputFile, fileData, status )    //正常情况
  If ( status = Status_Success ) Then    
SummarizeFileData ( fileData, summaryData, status )    //正常情况
If ( status = Status_Error ) Then 
  errorType = ErrorType_DataSummaryError          //出错情况
Else 
  PrintSummary( summaryData )                   //正常情况
  SaveSummaryData( summaryData, status )
  If ( status = Status_Error ) Then
    errorType = ErrorType_SummarySavaError        //出错情况
  Else 
    UpdateALLAccounts ( )                        //正常情况
    EraseUndoFile ( )
errorType = ErrorType_None
End If
End If
Else 
  errorType = ErrorType_FileReadError
End if
End If
</pre>
    这段代码很难理解，因为它把正常的情况和出错的情况混在了一起。很难从中找出正常代码的路径来。除此之外，因为错误条件有的时候是在If子句而不是else中处理，所以很难判断到底哪个if子句检测了与之相关的正常情况。
*'''''好代码'''''
<pre>
OpenFile ( inputFile, status )
If ( status = Status_Success ) Then 
  ReadFile ( inputFile, fileData, status )      //正常情况
  If ( status = Status_Success ) Then 
    SummarizeFileData ( fileData, summaryData, status )    //正常情况
If ( status = Status_Success ) Then
  PrintSummary( summaryData )                   //正常情况
  SaveSummaryData( summaryData, status )
  If ( status = Status_Success ) Then
    UpdateALLAccounts ( )                        //正常情况
    EraseUndoFile ( )
    errorType = ErrorType_None
  Else
    errorType = ErrorType_SummarySavaError        //出错情况
  End If
Else
  errorType = ErrorType_DataSummaryError          //出错情况
End If
  Else
    errorType = ErrorType_FileReadError
  End If
Else
  errorType = ErrorType_FileOpenError      //出错情况
</pre>
    在修改后的例子里，可以通过阅读if条件测试的主流程来找到正常的情况。这一修改使认得注意力集中到了阅读代码的主流程上，而不是费力的去理解那些异常处理情况，因此整体代码更容易阅读。嵌套条件语句的下面积累了全部的错误情况，这是良好错误处理代码的一个标志。	

====15.2 case语句                （何刚）====


=== 第16章 控制循环===

====16.1 选择循环的种类           （徐杰）====
======常见的循环有计数循环、连续求值的循环、无限循环和迭代器循环。======
*计数循环执行的次数是一定的。
'''计数循环Java示例代码'''
<pre> 
   public static void main(String[] args) {
        int count = 0;//定义一个计数器变量
        for (int i = 1; i <= 1000; i++) {
            if (i % 3 == 1 && i % 5 == 3 && i % 7 == 5) {
                System.out.println(i);
                count++;//每次符合要求后计数器都+1
            }
        }
        System.out.println(count);
    }
</pre>
*连续求值的循环预先并不知道要执行多少次，它会在每次循环遍历时判断是否应该结束。
'''连续求值的循环Java示例代码'''
<pre>
    public static void main(String[] args) {
	for (int i = 1; i < 10; i = i + 1) {
		System.out.println(i);
	}
    }
</pre>
*无限循环一旦启动就会一直执行。多用在心中起搏器、微波炉和导航控制仪中。
'''无限循环Java示例代码'''
<pre>
     for(int i=1;;i++){
	System.out.println(i);
     }
</pre>
*迭代器循环对容器类里面的每个元素执行一次操作。
'''迭代器循环Java示例代码'''
<pre>
       public static void main(String[] args) {
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
		arrayList.add(1);
		arrayList.add(2);
		arrayList.add(3);
		Iterator iterator = arrayList.iterator();
		while (iterator.hasNext()) {  //迭代器遍历查询，判断是否还有值可以显示
			System.out.println(iterator.next());
		}
	}
</pre>
======把检查放在循环结尾处，循环就会至少执行一次。======
*把检查放在循环开始处，那么它的循环体就不一定会执行。
*如果是放在中间检查，那么检查前面的那一部分至少执行一次，检查后面部分就不一定会执行到。
======循环次数不确定时用while循环。======
*while循环有do while（直到型循环）和while（当型循环）
**当你需要一个灵活的循环且该循环至少被执行一次，那么你就可是用一个在结尾处做条件检测的while循环。
======灵活度和检查位置决定选择循环的种类。======
*循环的种类列表如下：
{| class="wikitable"
! 语言
! 循环的种类
! 灵活度
! 检查位置
|-
| Visual Basic
| For-Next
| 严格
| 开始
|- 
| 
| While-Wend
| 灵活
| 开始
|- 
| 
| Do-Loop-While
| 灵活
| 开始或结尾
|- 
| 
| For-Each
| 严格
| 开始
|- 
| C,C++,C#,Java
| for
| 灵活
| 开始
|- 
| 
| While
| 灵活
| 开始
|- 
| 
| do-While
| 灵活
| 结尾
|- 
| 
| foreach
| 严格
| 开始
|}
======当循环条件检测在循环开始或结尾处时，我们就要用带退出的循环。======
*带退出的循环就是循环终止条件出现在循环中间而不是在开始或者结尾处。
**C++,C和Java中可以用break语句退出当前循环。在其他语言中也可以用goto实现。正常的带退出循环由循环头、循环体（包括终止条件）和循环尾组成。
**Java中使用循环语句时，只有循环条件表达式的值为false时，才能结束循环。有时，我们想提前中断循环，要实现这一点，只需要在循环语句块中添加break或continue语句。break（退出整个循环）、continue（退出本次循环，进入下一次循环）。“break;”语句：可以出现在while、do…while、for、switch语句体中。“continue;” 语句：只能出现在循环语句while、do…while、for中。
*'''坏代码'''
<pre> 
   // Compute scores and ratings.
   score = 0;
   GetNextRating( &ratingIncrement );
   rating = rating + ratingIncrement;
   While ( (score < targetScore ) && ( ratingIncrement != 0 ) ) {
        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement; 
        //7，8行与上面的3,4行重复，维护时会出现问题（上下两组代码需同步修改容易忘记）。解决办法写个带退出的条件。
    }
</pre>
*'''好代码'''
<pre> 
   // Compute scores and ratings.The code uses an infinite loop
   // and a break statement to emulate a loop-with-exit loop.
   score = 0;
   While ( true ) {
        GetNextRating( &ratingIncrement);
        rating = rating + ratingIncrement;

        if ( !( (score < targetScore ) && ( ratingIncrement != 0 ) ) ) { //写了退出循环的条件，容易维护。
            break;  //满足if条件时退出循环。
        }

        GetNextScore( &scoreIncrement )
        score = score + scoreIncrement;
    }
</pre>
======循环次数固定时用for循环。======
*用for循环来执行那些不需要循环内部控制的简单操作。
**使用for循环的好处是你在循环头处写好它之后就可以忘掉它了，无需在循环的内部做任何事情去控制它。
**不要在for循环里通过直接修改下标值得方式迫使它终止，这种情况应该用while循环。
====16.2 循环控制                （徐杰）====
====16.3 轻松创建循环——由内而外   （刘思）====
=====从简单情况开始并由内向外生成代码能轻松创建循环。=====
所谓由内而外就是从一种情况开始，用字面量（literal）来编写代码。然后缩进它，在外面加上一个循环然后用循环下标或计算表达式替换那些字面量。最后加上所需要的初始化。比如需要写一个能从列表中取得每个人的费率并累加的循环。
*首先，在注释里写下循环体要执行的操作步骤。先不考虑语法，下标等细节，把要做的事情先写下来。
 第1步：由内而外创建循环（伪代码示例）
 --get rate from table    (从表中取得费率)
 --add rate to total      (将费率加到总和上)
*然后，尽可能把循环体内注释转化成代码。
 第2步：由内而外创建循环（伪代码示例）
  rate = table[]     //table为存有费率数据的数组，现在table还没任何下标，
  totalRate = totalRate + rate //rate为表中取出的个人费率，totalRate为存储总费用
*接下来，往table数组里加入下标：
 第3步：由内而外创建循环（伪代码示例）
 rate = table[census.Age][census.Gender] //census存储个人信息的结构体
 totalRate = totalRate + rate
*接下来是给现有语句加上一层循环。缩进现有代码，并放在一个begin-end对里。
 第4步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census.Age][census.Gender]
  totalRate = totalRate + rate
 End For
*本列中，census变量随person而变，所以要适当推广（generalized）它。
 第5步：由内而外创建循环（伪代码示例）
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*最后，写出必要的初始化代码
 最后一步：由内而外创建循环（伪代码示例）
 totalRate = 0
 For person = firstPerson to lastPerson
  rate = table[census[person].Age][census[person].Gender]
  totalRate = totalRate + rate
 End For
*要点在于从具体事件入手，在同一时间只考虑一件事，以及从简单的部分开始创建循环。
====16.4 循环和数组的关系         （刘思）==== 
=====循环和数组之间有着密切的联系，选择好语言可免去繁琐的循环。=====
*编程是来解决问题的，有时候解决方案是特定于语言的。所选择的开发语言将很大程度上影响到你的解决方案。
JAVA示例：数组乘法
<pre>
 for (int row = 0; row < maxRows; row++){
        for (int row = 0; row < maxCols; column++){
	     product[row][column]=a[row][column]*b[row][column]
	}
 }
</pre>
APL示例：数组乘法
 product <- a * b
可见APL代码更加简单，更不容易出错。它只用了3个操作符，而相应的JAVA用了17个之多。
*所以编程之前应该研究继而选择更为适合的语言。比如APL和Fortran 90 以及其后续版本提供了强大的数组操作功能。


=== 第17章 不常见的控制结构===

====17.1 子程序中的多处返回       （郭思）==== 
　　程序可以通过return和exit在任何时候退出子程序。比如C++和Java中的return，VB中的Exit Sub和Exit Function。Java中的return一般就是在有返回值的方法中，用来返回方法指定类型的值，同时结束方法执行；也可以在返回值为void的方法中，用来终止方法运行。
=====使用return增强可读性=====
　　如果得到了想要的答案，就可以立即返回该值到调用方子程序，让读者更容易理解。
*'''''好代码'''''
<pre>
Comparison Compare(int value1,int value2){  //返回Comparison枚举类型
  if(value1<value2){
     return Comparison_LessThan;  //小于
  }
  if(value1>value2){
     return Comparison_GreaterThan;  //大于
  }
  return Comparison_Equal;  //相等
}
</pre>
=====用防卫子句（早返回或早退出）简化复杂的错误处理=====
　　当遇到复杂的错误处理，比如在执行某段正常代码之前要进行大量的错误条件检测时，如果用if...End if...循环嵌套的话，代码的缩进层次会过深，并且正常代码不容易查看。
*'''''坏代码'''''
<pre>
if file.validName() Then
   if file.Open() Then
      if encryptionKey.vaild() Then
         if file.Decrypt(encryptionKey) Then
            'lost of code //正常执行的代码;被遮蔽了
            ...
         End if
      End if
   End if
End if
</pre>
　　这时，我们可以在执行正常代码之前先检查错误条件，有错误则停止当前子程序的运行。这样，代码的布局清晰，画面美观。
*'''''好代码'''''
<pre>
if Not file.validName() Then Exit Sub
if Not file.Open() Then Exit Sub
if Not encryptionKey.vaild() Then Exit Sub
if Not file.Decrypt(encryptionKey) Then Exit Sub
'lost of code  //正常执行的代码
...
</pre>
=====减少子程序中return的数量=====
　　如果读子程序的后部时，没有意识到前面某个地方返回的可能性，就很难理解这个子程序。只有在可以增强可读性的时候使用return，尽可能少的使用return。
====17.2 递归                   （郭思）====
====17.3 goto                   （兰杰）====
=====要在特定场合下谨慎地使用goto=====

*goto的坏处
**还有goto的代码很难安排好格式，影响逻辑结构
**goto会破换编译器的优化特性，使流程变得难以分析
*goto的好处
**如果位置恰当，goto可以减少重复的代码
**某些情况下会让代码的运行速度更快，体积更小
**goto用在执行清理操作，可以减少忘记释放资源的可能

=====goto代码重写很容易出错=====

*'''''C++示例：看上去很容易就能重写为不使用goto是代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) ) {
      goto LOOP_EXIT;
    }
    Dosomething( data );
}  whlie ( data ！= -1);
LOOP_EXIT;
</pre>

*'''''去掉了goto的所谓等价代码'''''
<pre>
 GetData( inputFile, data );
while ( ( !eof(inputFile) ) && ( ( data ! = -1 ) ) ) { //检测到-1，退出循环而不执行Dosomething（）
   Dosomething( data );
   GetData( inputFile, data ); 
}
</pre>

*'''''去掉了goto的真正等价代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) )  {
      Dosomething( data );//检测到-1之前，执行Dosomething（）
   }
}while { ( data != -1 ) && ( !eof( inputFile ) ) );
</pre>

=====分配和清理时使用goto利大于弊=====
<pre>
*'''''Visual Basic示例：处理错误以及释放资源的带goto代码'''''
errorState = fileStatus_Sussess
fileIndex = 0
While { fileIndex < numFilesToPurge } //获得一个需要清除的文件列表时检测错误状态
       fileIndex = fileIndex + 1
	If Not ( FindFile ( fileList ( fileIndex),numFilesToPurge ) )Then
  	    errorState = FileStatus_FileFindError
   	GoTo END_PROC
     End If
	If Not OpenFile( fileToPurge ) Then   //打开文件列表时检测错误状态
       		errorState = FileStatus_FileOpenError
   	GoTo END_PROC
      End If  
	If Not OverWriteFile( fileToPurge ) Then  //覆盖其内容时检测错误状态
       		errorState = FileStatus_FileOverWriteError
   	GoTo END_PROC
      End If 
	If Not Erase( fileToPurge ) Then     //删除时检测错误状态
       		errorState = FileStatus_FileEraseError
   	GoTo END_PROC
       End If
    End While

END_PROC:     //这是goto的label
    DeletePurageFileList( fileList, numFileToPurge ) 

</pre>

当子程序需要为数据库连接、内存或临时文件执行分配和清理操作的时候，如果不用goto，
通常就需要重复写出清理资源的代码。维护重复代码带来的麻烦比使用goto的弊端大。




=====可以用if嵌套语句重写goto=====

*'''''Visual Basic示例：利用嵌套的if语句消除goto代码'''''
<pre>
   errorPurgeFileList( fileList, numFileTopurge )
   errorState = FileStatus_Success
   fileIndex = 0
   While ( fileIndex < numFilesToPurge And errorState = FileStatus_Success )
       fileIndex = fileIndex + 1
  If FindFile( fileList ( fileIndex),numFilesToPurge ) ) Then
      If  OpenFile( fileToPurge ) Then
          If OverWriteFile( fileToPurge ) Then
             If Not Erase( fileToPurge ) Then
                errorState = FileStatus_FileEraseError
          End If
      Else 
          errorState = FileStatus_FileOverWriteError
      End If
  Else
      errorState = FileStatus_FileOpenError
  End If
Else
    errorState = FileStatus_FileFindError
End If

End While
DeletePurageFileList( fileList, numFileToPurge )

</pre>
如示例这样嵌套，使嘚仅当一条if语句检测成功时才执行下一条if语句，这是标准的消除goto的编程方法。
这样做最大的缺点在于嵌套太深，必须把整个嵌套装入大脑才能理解。


====17.4 针对不常见控制结构的观点  （兰杰）====
=====对非传统的控制结构应持怀疑态度=====

*不加限制地使用goto
*能动态计算出goto跳转目标并且执行跳转
*通foto从一个子程序中部跳到另一个子程序中部
*根据行数或标号调用子程序，从而允许代码从子程序中间某个位置开始执行
*具备让应用程序动态生成代码并且执行这些代码的能力
这些想法看起来离奇，但曾经都被认为是可以接受的。很大程度上，软件开大这一领域实在限制程序员
对代码的使用中得到发展的。

=====不常见控制结构使用时应多加小心=====
*多个return可增加程序的可读性和可维护性，同时可以避免产生很深的嵌套逻辑。但是使用它的时候要多加小心，
如果在读子程序后期时，你没有意识到它从前面某个地方返回的可能性，想理解这个子程序就很困难。
*递归能够很优雅的解决一小部分问题。但对于大多数问题，它所带来的解将是极其复杂的，对它的使用也要倍加小心。
*在少数情况下，goto是编写可读性和可维护代码的最佳方法，但这种情况非常罕见。除非万不得以，不要使用goto。



=== 第18章 表驱动法===

====18.1 表驱动法使用总则         （梁运）====
=====不要使用复杂的逻辑代码=====
*当遇到想把字符、划分为字母、标点符号、和数字三类，使用复杂的逻辑链是错误的。
'''错误示例代码'''
<pre>
if(
   (('a'<=inputChar)&&( inputChar<='z'))||(('A'<=inputChar)&&( inputChar<='Z'))
  )
{
 charType=CharacterType.Letter;
}
else if ((inputchar==' ')||(inputChar==',')
	 ||(inputChar=='.')|| (inputChar=='!')
	 || (inputChar=='(')|| (inputChar==')') 
	 || (inputChar==':') || (inputChar==';')
	 || (inputChar=='?') || (inputChar=='-')
        )
{
 charType=CharacterType.Punctuation;
}
else if (('0'<= inputChar)&&( inputChar<='9'))
{
 charType= CharacterType.Digit;
}
</pre>
=====解决方法=====
*把每一个字符的类型保存在一个用字符编码访问的数组里。
'''正确示例代码'''
<pre>
charType= CharTypeTable[inputChar];
</pre>
====18.2 直接访问表              （梁运）====
====18.3 索引访问表              （黄佳欣）====
=====索引访问表心得1=====
*数据库检索方法索引访问介绍：
'''坏方法：'''<br>
直接通过检索条件检索这个表，遍历整个表，从而找到这条数据。<br>
'''好方法：'''<br>
用数据库表建立一个索引表（包含了这个表个表中一列或者
若干列值的集合，不是必须用主键，可以确定这条数据的唯一
性就可以）。<br>
例如：
SELECT NAME FROM TABLE_TEST WHERE ID = '10000';。<br>
没有索引:必须遍历整个表，直到ID等于10000的这一
行被找到为止；<br>
有索引:即可在索引中查找到这条数据的位置。由于索引是经过
某种算法优化过的，因而查找次数要少的多。
=====索引访问表心得2=====
*索引的优点:
占用的总内存量少
可以大大加快数据检索速度。
通过创建唯一索引，可以保证数据记录的唯一性。
更容易维护。
====18.4 阶梯访问表              （黄佳欣）====
=====阶梯访问表心得1=====
*基本思想：对数据进行区间划分，再该区间内的是一类数据，然后在该区间
内找到这个数据。
适用于无规则的数据。像分数等级划分，电费等级的划分。
=====阶梯访问表心得2=====
*阶梯的优点：
节约存储空间，加快数据检索速度（慢于索引）。
=====阶梯访问表心得3=====
*使用阶梯访问表时需要注意的一些细节：
留心端点<br>
考虑用二分查找取代顺序查找<br>
考虑用索引访问来取代阶梯技术<br>
把阶梯表查询操作提取成单独的子程序<br>
====18.5 表查询的其他示例         （黄佳欣）====
=====由内而外，创建循环体心得=====
'''坏方法：'''<br>
循环体的创建我们通常会从FOR循环开始想起，然后在写循环体。
写一个复杂的循环，这样的方法是耗时间，还容易出错的。<br>
'''好方法：'''<br>
先从循环体开始思考，先建立好循环的内部循环程序，最后加上for循环
，然后缩进代码。这样的方法在面对比较复杂的循环时，可以减少代码和
思维上的错误。保证循环的准确性和节约编码的时间。（不是必须要着
样做，对于比较简单的循环来说，一直顺手写也是很快。）
=====低效代码的优化心得1=====
*低效代码的发生只要是不必要的输入\输出。
像大量的磁盘、数据库、网络文件访问。在硬件设施保证的情况下可
以在内存中处理的文件就不需要这样费力了。
=====低效代码的优化心得2=====
*编程语言的原因。
编译型(C++、VB、C#)<字节型(JAVA)<解释型(PHP、Python)
，适当的编程语言可以大量的节约程序运行时间。
=====低效代码的优化心得3=====
*较常见原因。
参数运算，(a+1)>(a++)。
多余的逻辑运算：(&、&&)和(|、||).(&&和|| 有短路的功能，可以节约
逻辑运算的时间)
=== 第19章 一般控制问题===
====19.1 布尔表达式              （李腾飞）====
*在布尔表达式中要用标识符true和false，而不是0和1等数值，隐式地比较布尔值与true和false。
'''错误示例代码'''
<pre>
Dim printerError As Integer
Dim reportSelected As Integer
Dim summarySelected As Integer
...
If printerError = 0 Then InitializePrinter ()
If printerError = 1 Then NotifyUserOfError ()

If reportSelected = 1 Then PrintReport ()
If summarySelected = 1 Then PrintSummary ()

If printerError = 0 Then CleanupPrinter ()
</pre>
'''正确示例代码'''
<pre>
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()
</pre>
通过这样可以明确你在执行一个布尔判断，使用隐式比较能减少阅读代码时需要记住的项数。
====19.2 复合语句（语句块）       （李腾飞）====
====把括号对一起写出，用括号来把条件表达清楚====
*先写块的开始和结束部分，之后填充中间部分。
例如：
*先写
<pre>
for ( i = 0; i < maxLines; i++ )
</pre>
*再写
<pre>
for ( i = 0; i < maxLines; i++ ) { }
</pre>
*最后写
<pre>
for ( i = 0; i < maxLines; i++ ) {
   // whatever goes in here ...
}
</pre>
这种方法适用于所有的块结构，用语句块时一定要清楚的表达你的用意，无论块内的代码行数是1还是20.
====19.3 空语句                  （时昌彬）====
=====空语句并不多见，因此应突出这种用法=====
*空语句，即一条仅含有分号的语句
'''C++实例：传统的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））
;
</pre>
*空语句并不多见，因此应突出这种用法，方法之一是用一组空的括号来强调空语句。
'''C++实例：加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{ }
</pre>
*另外可以让空语句中的分号自占一行，并加以缩进来强调空语句。		
'''C++实例： 加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{
	;
}
</pre>
=====为空语句创建一个DoNothing（）预处理宏或者内联函数======
这条语句什么也不做，但却能毫无争议的表明“这里希望不做任何事情”的用意。
下面就是C++中如何使用#define来定义空语句。
'''C++实例： 用DoNothing（）来强调空语句'''
<pre>
#define DoNothing()
...
while (recordArray.Read( index++) != recordArray.EmptyRecord()){
	DoNothing();
}
</pre>
除了在空的while和for循环中使用DoNothing(),你也可以在switch语句中的无意义选项中使用它；加入DoNothing()表明你已经考虑了这种case，并且的确不需要对该case做什么操作。

====19.4 驯服危险的深层嵌套        （时昌彬）====
=====避免使用超过3到4层的嵌套=====
很少有人能够理解超过3层的if嵌套，很多研究人员建议避免使用超过3到4层的嵌套。
*把嵌套if转换成一组if-then-else语句
'''Java实例：坏代码'''
<pre>
if (10 < quantity){
	if(100 < quantity）{
		if(1000 < quantity){
			discount = 0.01;
    		}
		else{
			discount = 0.05;
		}
	}
	else{
		discount = 0.025;
	}
else{
	discount = 0.0
}
</pre>
出现多层嵌套的原因是其中的判断逻辑组织的很差，这些判断中有许多冗余。当判断了quantity是否大于1000的时候，
就不需要再去判断他是否大于100并且大于10。因此可以重新组织这段代码：
'''Java实例： 好代码'''
<pre>
if (1000 < quantity){
	discount = 0.01;
}
else if (100 < quantity){
	discount = 0.05;
}
else if (10 < quantity){
	discount = 0.025;
}
else{
discount = 0.0;
}
</pre>

=====把嵌套if转换成case语句======
你可以用case语句重写一些判断，特别是那些含有整数的判断，而不是去用一长串if和else。
'''Visual Basic实例：将嵌套if语句转换成case语句'''
<pre>
Select Case quantity
	Case 0 to 10
		discount = 0.0
	Case 11 to 100
		discount = 0.025
	Case 101 to 1000
		discount = 0.05
	Case Else
		discount = 0.10
End Select 
</pre>
有些语言中你无法使用这种方法，但是对那些可以使用case的语言来说，这是一种功能强大的技术。

====19.5 编程基础：结构化编程      （陈欢欢）====
*“结构化”包括结构化分析、结构化设计以及结构化混日子
**'''*除了都创建于“结构化”被广泛推崇的时代之外，这些状态各异的结构化方法学之间并没有多少相互联系'''
*核心思想很简单
**一个应用程序应该只采用一些单入单出的控制结构（也称单一入口、单一出口的控制结构）
***'''*单入单出的控制结构指一个代码块，只有一个执行开始点与执行结束点'''
*执行方式是有序的且有规则的
*结构化编程的三个组成部分:顺序、选择、迭代
*顺序
<pre>
Java示例：顺序
//a sequence of assignment statements
a=”1”;
b=”2”;
c=”3”;

//a sequence of calls to routines
System.out.println(a);
System.out.println(b);
System.out.println(c);
</pre>
*选择是一种有选择的执行语句的控制结构:if-then-else,case
<pre>
Java示例：选择
//selection in an if sttement
If(totalAmount>0.0){
  //do something
  ...
}
else{
  //do something
  ...
}

//selection in a case statement
switch(commandShortcutLetter){
   case ‘a’:
      PrintAnnualReport();
      break; 
   case ‘q’:
      PrintAnnualReport();
      break;  
   case ‘s’:
      PrintAnnualReport();
      break;
default:
DisplayInternalError(“Internal  Error 905:Call customer support”);
}
</pre>
*迭代——是一组语句多次执行的控制结构（也称循环）
<pre>
Visual Basic示例：迭代
‘ example of iteration using a For loop
For index=first To last
   DoSomething (index)
Next

‘ example of iteration using a while loop
index=first
While(index<=last)
   DoSomething (index)
   Index=index+1
Wend

‘ example of iteration using a loop-with-exit loop
index=first
Do
   If(index>last) Then Exit Do
   DoSomething(index)
   Index=index+1
Loop
</pre>
*结构化编程的中心论点——任何一个控制利用可以有顺序、选择和迭代三种结构构成

====19.6 控制结构与复杂度         （陈欢欢）====
*控制结构的作用是降低复杂度
*程序复杂度决定了理解程序所需要花费的精力
*控制流是影响复杂度的大因素之一
**'''*与控制流有关的复杂度非常重要——与不可靠的代码和频繁出现的错误息息相关'''
*度量复杂度——计算子程序的“决策点”的数量来衡量复杂度
<pre>
决策点的计算方式：
(1)决策点初始值为1；
(2)遇到一次if，while，repeat，for，and，or决策点就加1
(3)Case语句中的每一种情况加1
</pre>
<pre>
处理复杂度的度量结果
（1）0-5 子程序可能还不错
（2）6-10 得想办法简化子程序了
（3）10+ 把子程序的某一部分拆分成另一个子程序并调用它
</pre>
*将子程序提取到另一个子程序，不会降低整个程序的复杂度，只是降低在同一时间必须关注的复杂度水平
*其他度量方法——所用的数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码行数（跨度）、变量生存的代码行数（生存期）以及输入的输出的量