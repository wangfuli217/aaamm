=== 参加人员 ===

时昌彬  郭思  黄佳欣  兰杰  陈渊  何刚  刘思  徐杰  李腾飞  陈欢欢  梁运  共计11人


=== 第14章 组织直线型代码=== 

====14.1 必须有明确顺序的语句      （陈渊）====
14.1 必须有明确的语句顺序心得:
那么有明确语句顺序的代码好处在哪呢，下面通过一个有明确顺序的代码和没有明确顺序代码的实例，我们会一目了然的发现有明确顺序的代码的优点。<br>
<pre>
例1（有明确顺序）
date = ReadData();
results = =CalculateResultsFromData(date );
PrintResults(results );
</pre>
<pre>
例2（没有明确顺序）
revenue.ComputeMonthly();
revenue.ComputeQuarterly();
revenue.ComputeAnnual();
</pre>

从上面的两个例子可以很好地看出例的优势，通俗易懂，而且逻辑方面也层层相扣，大大提高了代码的正确性，可读性和可维护性。

那我我们所要做的就是讲自己写的代码有意识的携程有顺序条理清晰的的代码现在，通过一个例子的展现如何改进写的代码的可读性。<br>
<pre>
InitializeExpenseData
ComputeMarketingExpense
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary
</pre>

*加注释对不清晰的依赖关系进行说明<br>
<pre>
InitializeExpenseData//计算Expense数据
ComputeMarketingExpense//四个子程序访问了ExpenseData数据成员
ComputeSalesExpense
ComputeTravelExpense
ComputePersonnelExpense
DispalyExpenseSummary//调用了四个子程序访问了ExpenseData数据成员后的数据
</pre>

*'''加参数明确显示依赖关系（推荐）'''<br>
<pre>
expenData = InitializeExpenseData（expenData）;
marketingExpenData = ComputeMarketingExpense（expenData）;
salesExpenData = ComputeSalesExpense（expenData）;
travelExpenseData = ComputeTravelExpense（expenData）;
personnelExpenseData = ComputePersonnelExpense（expenData）;
DispalyExpenseSummary（marketingExpenData,salesExpenData,travelExpenseData,personnelExpenseData）;
</pre>

*用断言或者错误处理代码来检查依赖关系<br>
就是可以再在类的成员变量里将isExpenseDataInitialized设为false,然后再InitializeExpenseData（）中将isExpenseDataInitialized设为true,在下面四个函数对expenData进行操作之前，看看isExpenseDataInitialized是否为true,但是我觉得因为引入新的变量、新的初始化，就变得复杂也不是很好理解，还会增加错误，所以不是很推荐。

====14.2 顺序无关的语句           （陈渊）====

14.2 顺序无关的语句心得
其中最最重要的一点就是：要把相关的操作都放在一起。要让别人轻松的读懂你的代码，就要让你的程序易于自上而下的阅读，不能让读者去大量的代码中去搜寻他想要的信息，举一个例子:<br>
<pre>
MarketingData marketingData;
SalesData salesData;
TravelData travelData;

travelData.computeQuarterly();
salesData.computeQuarterly();
marketingData.computeQuarterly();

marketingData.computeAnnual();
salesData.computeAnnual();
travelData.computeAnnual();

salesData.Print();
travelData.Print();
marketingData.Print();
</pre>

上面的代码跳来跳去的让人看了很不舒服，如果放在一大堆的代码里，读者估计得花很长时间去搜寻他想要的信息如果想知道travelData是怎么来的，那他就得全局去搜，而且还会想，用到的地方是不是就仅仅只有这几个呢，给阅读带来了很大的不便，要是我们能做到把相关的操作放一起，那效果就不一样了。<br>
<pre>
MarketingData marketingData;
marketingData.computeQuarterly();
marketingData.computeAnnual();
marketingData.Print();

SalesData salesData;
salesData.computeQuarterly();
salesData.computeAnnual();
salesData.Print();

TravelData travelData;
travelData.computeQuarterly();
travelData.computeAnnual();
travelData.Print();
</pre>

如过我们改成了上面的代码，把相关的的语句组织到一起，放在一起，那么对代码的可读性、可维护性有了大大的提升

=== 第15章 使用条件语句===

====15.1 if语句                  （何刚）====
====15.2 case语句                （何刚）====


=== 第16章 控制循环===

====16.1 选择循环的种类           （徐杰）====
======常见的循环有计数循环、连续求值的循环、无限循环和迭代器循环。======
*计数循环执行的次数是一定的。
'''计数循环Java示例代码'''
<pre> 
   public static void main(String[] args) {
        int count = 0;//定义一个计数器变量
        for (int i = 1; i <= 1000; i++) {
            if (i % 3 == 1 && i % 5 == 3 && i % 7 == 5) {
                System.out.println(i);
                count++;//每次符合要求后计数器都+1
            }
        }
        System.out.println(count);
    }
</pre>
*连续求值的循环预先并不知道要执行多少次，它会在每次循环遍历时判断是否应该结束。
'''连续求值的循环Java示例代码'''
<pre>
    public static void main(String[] args) {
	for (int i = 1; i < 10; i = i + 1) {
		System.out.println(i);
	}
    }
</pre>
*无限循环一旦启动就会一直执行。多用在心中起搏器、微波炉和导航控制仪中。
'''无限循环Java示例代码'''
<pre>
     for(int i=1;;i++){
	System.out.println(i);
     }
</pre>
*迭代器循环对容器类里面的每个元素执行一次操作。
'''迭代器循环Java示例代码'''
<pre>
       public static void main(String[] args) {
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
		arrayList.add(1);
		arrayList.add(2);
		arrayList.add(3);
		Iterator iterator = arrayList.iterator();
		while (iterator.hasNext()) {  //迭代器遍历查询，判断是否还有值可以显示
			System.out.println(iterator.next());
		}
	}
</pre>
======把检查放在循环结尾处，循环就会至少执行一次。======
*把检查放在循环开始处，那么它的循环体就不一定会执行。
*如果是放在中间检查，那么检查前面的那一部分至少执行一次，检查后面部分就不一定会执行到。
======循环次数不确定时用while循环。======
*while循环有do while（直到型循环）和while（当型循环）
====16.2 循环控制                （徐杰）====
====16.3 轻松创建循环——由内而外   （刘思）====
====16.4 循环和数组的关系         （刘思）==== 
=====循环和数组之间有着密切的联系，但并不是天生就相互关联，选择好语言可免去繁琐的循环。=====
*编程是来解决问题的，有时候解决方案是特定于语言的。所选择的开发语言将很大程度上影响到你的解决方案。
JAVA示例：数组乘法
<pre>
 for (int row = 0; row < maxRows; row++){
        for (int row = 0; row < maxCols; column++){
	     product[row][column]=a[row][column]*b[row][column]
	}
 }
</pre>
APL示例：数组乘法
 product <- a * b
可见APL代码更加简单，更不容易出错。它只用了3个操作符，而相应的JAVA用了17个之多。
*所以编程之前应该研究继而选择更为适合的语言。比如APL和Fortran 90 以及其后续版本提供了强大的数组操作功能。


=== 第17章 不常见的控制结构===

====17.1 子程序中的多处返回       （郭思）==== 
　　程序可以通过return和exit在任何时候退出子程序。比如C++和Java中的return，VB中的Exit Sub和Exit Function。Java中的return一般就是在有返回值的方法中，用来返回方法指定类型的值，同时结束方法执行；也可以在返回值为void的方法中，用来终止方法运行。
=====使用return增强可读性=====
　　如果得到了想要的答案，就可以立即返回该值到调用方子程序，让读者更容易理解。
*'''''好代码'''''
<pre>
Comparison Compare(int value1,int value2){  //返回Comparison枚举类型
  if(value1<value2){
     return Comparison_LessThan;  //小于
  }
  if(value1>value2){
     return Comparison_GreaterThan;  //大于
  }
  return Comparison_Equal;  //相等
}
</pre>
=====用防卫子句（早返回或早退出）简化复杂的错误处理=====
　　当遇到复杂的错误处理，比如在执行某段正常代码之前要进行大量的错误条件检测时，如果用if...End if...循环嵌套的话，代码的缩进层次会过深，并且正常代码不容易查看。
*'''''坏代码'''''
<pre>
if file.validName() Then
   if file.Open() Then
      if encryptionKey.vaild() Then
         if file.Decrypt(encryptionKey) Then
            'lost of code //正常执行的代码;被遮蔽了
            ...
         End if
      End if
   End if
End if
</pre>
　　这时，我们可以在执行正常代码之前先检查错误条件，有错误则停止当前子程序的运行。这样，代码的布局清晰，画面美观。
*'''''好代码'''''
<pre>
if Not file.validName() Then Exit Sub
if Not file.Open() Then Exit Sub
if Not encryptionKey.vaild() Then Exit Sub
if Not file.Decrypt(encryptionKey) Then Exit Sub
'lost of code  //正常执行的代码
...
</pre>
=====减少子程序中return的数量=====
　　如果读子程序的后部时，没有意识到前面某个地方返回的可能性，就很难理解这个子程序。只有在可以增强可读性的时候使用return，尽可能少的使用return。
====17.2 递归                   （郭思）====
====17.3 goto                   （兰杰）====
=====goto使用心得=====
要在'''特定场合下谨慎地'''使用goto，而不是不问青红皂白的用

*goto的坏处
**还有goto的代码很难安排好格式，影响逻辑结构
**goto会破换编译器的优化特性，使流程变得难以分析
*goto的好处
**如果位置恰当，goto可以减少重复的代码
**某些情况下会让代码的运行速度更快，体积更小
**goto用在执行清理操作，可以减少忘记释放资源的可能
=====goto代码重写心得=====
goto代码重写很容易'''出错'''

*'''''C++示例：看上去很容易就能重写为不使用goto是代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) ) {
      goto LOOP_EXIT;
    }
    Dosomething( data );
}  whlie ( data ！= -1);
LOOP_EXIT;
</pre>

*'''''去掉了goto的所谓等价代码'''''
<pre>
 GetData( inputFile, data );
while ( ( !eof(inputFile) ) && ( ( data ! = -1 ) ) ) { //检测到-1，退出循环而不执行Dosomething（）
   Dosomething( data );
   GetData( inputFile, data ); 
}
</pre>

*'''''去掉了goto的真正等价代码'''''
<pre>
do{
   GetData( inputFile, data );
   if ( eof( inputFile ) )  {
      Dosomething( data );//检测到-1之前，执行Dosomething（）
   }
}while { ( data != -1 ) && ( !eof( inputFile ) ) );
</pre>
====17.4 针对不常见控制结构的观点  （兰杰）====
=====对不常见控制结构的心得=====
对非传统的控制结构应持'''怀疑态度'''

*不加限制地使用goto
*能动态计算出goto跳转目标并且执行跳转
*通foto从一个子程序中部跳到另一个子程序中部
*根据行数或标号调用子程序，从而允许代码从子程序中间某个位置开始执行
*具备让应用程序动态生成代码并且执行这些代码的能力
这些想法看起来离奇，但曾经都被认为是可以接受的。很大程度上，软件开大这一领域实在限制程序员
对代码的使用中得到发展的。


=== 第18章 表驱动法===

====18.1 表驱动法使用总则         （梁运）====
=====不要使用复杂的逻辑代码=====
*当遇到想把字符、划分为字母、标点符号、和数字三类，使用复杂的逻辑链是错误的。
'''错误示例代码'''
<pre>
if(
   (('a'<=inputChar)&&( inputChar<='z'))||(('A'<=inputChar)&&( inputChar<='Z'))
  )
{
 charType=CharacterType.Letter;
}
else if ((inputchar==' ')||(inputChar==',')
	 ||(inputChar=='.')|| (inputChar=='!')
	 || (inputChar=='(')|| (inputChar==')') 
	 || (inputChar==':') || (inputChar==';')
	 || (inputChar=='?') || (inputChar=='-')
        )
{
 charType=CharacterType.Punctuation;
}
else if (('0'<= inputChar)&&( inputChar<='9'))
{
 charType= CharacterType.Digit;
}
</pre>
=====解决方法=====
*把每一个字符的类型保存在一个用字符编码访问的数组里。
'''正确示例代码'''
<pre>
charType= CharTypeTable[inputChar];
</pre>
====18.2 直接访问表              （梁运）====
====18.3 索引访问表              （黄佳欣）====
=====索引访问表心得=====
*数据库检索方法索引访问介绍：
'''坏方法：'''<br>
直接通过检索条件检索这个表，遍历整个表，从而找到这条数据。<br>
'''好方法：'''<br>
用数据库表建立一个索引表（包含了这个表个表中一列或者
若干列值的集合，不是必须用主键，可以确定这条数据的唯一
性就可以）。<br>
例如：
SELECT NAME FROM TABLE_TEST WHERE ID = '10000';。<br>
没有索引:必须遍历整个表，直到ID等于10000的这一
行被找到为止；<br>
有索引:即可在索引中查找到这条数据的位置。由于索引是经过
某种算法优化过的，因而查找次数要少的多。
*索引的优点:
占用的总内存量少
可以大大加快数据检索速度。
通过创建唯一索引，可以保证数据记录的唯一性。
更容易维护。
====18.4 阶梯访问表              （黄佳欣）====
=====阶梯访问表心得=====
*基本思想：对数据进行区间划分，再该区间内的是一类数据，然后在该区间
内找到这个数据。
适用于无规则的数据。像分数等级划分，电费等级的划分。
*阶梯的优点：
节约存储空间，加快数据检索速度（慢于索引）。
====18.5 表查询的其他示例         （黄佳欣）====

=== 第19章 一般控制问题===
====19.1 布尔表达式              （李腾飞）====
*在布尔表达式中要用标识符true和false，而不是0和1等数值，隐式地比较布尔值与true和false。
'''错误示例代码'''
<per>
Dim printerError As Integer
Dim reportSelected As Integer
Dim summarySelected As Integer
...
If printerError = 0 Then InitializePrinter ()
If printerError = 1 Then NotifyUserOfError ()

If reportSelected = 1 Then PrintReport ()
If summarySelected = 1 Then PrintSummary ()

If printerError = 0 Then CleanupPrinter ()
</per>
'''正确示例代码'''
<per>
Dim printerError As Boolean
Dim reportSelected As ReportType
Dim summarySelected As Boolean
...
If ( Not printerError ) Then InitializePrinter ()
If ( printerError ) Then NotifyUserOfError ()

If ( reportSelected = ReportType_First ) Then PrintReport ()
If ( summarySelected ) Then PrintSummary ()

If ( Not printerError ) Then CleanupPrinter ()
</per>
通过这样可以明确你在执行一个布尔判断，使用隐式比较能减少阅读代码时需要记住的项数。
====19.2 复合语句（语句块）       （李腾飞）====
====把括号对一起写出，用括号来把条件表达清楚====
*先写块的开始和结束部分，之后填充中间部分。
例如：
*先写
<per>
for ( i = 0; i < maxLines; i++ )
</per>
*再写
<per>
for ( i = 0; i < maxLines; i++ ) { }
</per>
*最后写
<per>
for ( i = 0; i < maxLines; i++ ) {
   // whatever goes in here ...
}
</per>
这种方法适用于所有的块结构，用语句块时一定要清楚的表达你的用意，无论块内的代码行数是1还是20.
====19.3 空语句                  （时昌彬）====
=====空语句并不多见，因此应突出这种用法=====
*空语句，即一条仅含有分号的语句
'''C++实例：传统的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））
;
</pre>
*空语句并不多见，因此应突出这种用法，方法之一是用一组空的括号来强调空语句。
'''C++实例：加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{ }
</pre>
*另外可以让空语句中的分号自占一行，并加以缩进来强调空语句。		
'''C++实例： 加以强调的空语句'''
<pre>
while（ recordArray.Read（ index++ ）!= recordArray.EmptyRecord（））{
	;
}
</pre>
====19.4 驯服危险的深层嵌套        （时昌彬）====
=====避免使用超过3到4层的嵌套=====
很少有人能够理解超过3层的if嵌套，很多研究人员建议避免使用超过3到4层的嵌套。
*把嵌套if转换成一组if-then-else语句
'''Java实例：坏代码'''
<pre>
if (10 < quantity){
	if(100 < quantity）{
		if(1000 < quantity){
			discount = 0.01;
    		}
		else{
			discount = 0.05;
		}
	}
	else{
		discount = 0.025;
	}
else{
	discount = 0.0
}
</pre>
出现多层嵌套的原因是其中的判断逻辑组织的很差，这些判断中有许多冗余。当判断了quantity是否大于1000的时候，
就不需要再去判断他是否大于100并且大于10。因此可以重新组织这段代码：
'''Java实例： 好代码'''
<pre>
if (1000 < quantity){
	discount = 0.01;
}
else if (100 < quantity){
	discount = 0.05;
}
else if (10 <quantity){
	discount = 0.025;
}
else{
discount = 0.0;
}
</pre>
====19.5 编程基础：结构化编程      （陈欢欢）====
*“结构化”包括结构化分析、结构化设计以及结构化混日子
**'''*除了都创建于“结构化”被广泛推崇的时代之外，这些状态各异的结构化方法学之间并没有多少相互联系'''
*核心思想很简单
**一个应用程序应该只采用一些单入单出的控制结构（也称单一入口、单一出口的控制结构）
***'''*单入单出的控制结构指一个代码块，只有一个执行开始点与执行结束点'''
*执行方式是有序的且有规则的
*结构化编程的三个组成部分
**顺序
**选择
**迭代——是一组语句多次执行的控制结构（也称循环）
*结构化编程的中心论点——任何一个控制利用可以有顺序、选择和迭代三种结构构成

====19.6 控制结构与复杂度         （陈欢欢）====
*控制结构的作用是降低复杂度
*程序复杂度决定了理解程序所需要花费的精力
*控制流是影响复杂度的大因素之一
**'''*与控制流有关的复杂度非常重要——与不可靠的代码和频繁出现的错误息息相关'''
*度量复杂度——计算子程序的“决策点”的数量来衡量复杂度
**决策点初始值为1；
**遇到一次if，while，repeat，for，and，or决策点就加1
**Case语句中的每一种情况加1
*将子程序提取到另一个子程序，不会降低整个程序的复杂度，只是降低在同一时间必须关注的复杂度水平
*其他度量方法——所用的数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码行数（跨度）、变量生存的代码行数（生存期）以及输入的输出的量