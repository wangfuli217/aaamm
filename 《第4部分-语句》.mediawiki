=== 参加人员 ===

时昌彬  郭思  黄佳欣  兰杰  陈渊  何刚  刘思  徐杰  李腾飞  陈欢欢  梁运  共计11人


=== 第14章 组织直线型代码=== 

====14.1 必须有明确顺序的语句      （陈渊）====
14.1 必须有明确的语句顺序心得:
那么有明确语句顺序的代码好处在哪呢，下面通过一个有明确顺序的代码和没有明确顺序代码的实例，我们会一目了然的发现有明确顺序的代码的优点。<br>
例1（有明确顺序）<br>
date = ReadData();<br>
results = =CalculateResultsFromData(date );<br>
PrintResults(results );<br>

例2（没有明确顺序）<br>
revenue.ComputeMonthly();<br>
revenue.ComputeQuarterly();<br>
revenue.ComputeAnnual();<br>

从上面的两个例子可以很好地看出例的优势，通俗易懂，而且逻辑方面也层层相扣，大大提高了代码的正确性，可读性和可维护性。

那我我们所要做的就是讲自己写的代码有意识的携程有顺序条理清晰的的代码现在，通过一个例子的展现如何改进写的代码的可读性。<br>

InitializeExpenseData<br>
ComputeMarketingExpense<br>
ComputeSalesExpense<br>
ComputeTravelExpense<br>
ComputePersonnelExpense<br>
DispalyExpenseSummary<br>

一、加注释对不清晰的依赖关系进行说明<br>
//计算Expense数据<br>
InitializeExpenseData<br>
//四个子程序访问了ExpenseData数据成员<br>
ComputeMarketingExpense<br>
ComputeSalesExpense<br>
ComputeTravelExpense<br>
ComputePersonnelExpense<br>
//调用了四个子程序访问了ExpenseData数据成员后的数据<br>
DispalyExpenseSummary<br>

二、加参数明确显示依赖关系（推荐）<br>
expenData = InitializeExpenseData（expenData）;<br>
marketingExpenData = ComputeMarketingExpense（expenData）;<br>
salesExpenData = ComputeSalesExpense（expenData）;<br>
travelExpenseData = ComputeTravelExpense（expenData）;<br>
personnelExpenseData = ComputePersonnelExpense（expenData）;<br>
DispalyExpenseSummary（marketingExpenData,salesExpenData,travelExpenseData,personnelExpenseData）;<br>

三、用断言或者错误处理代码来检查依赖关系<br>
就是可以再在类的成员变量里将isExpenseDataInitialized设为false,然后再InitializeExpenseData（）中将isExpenseDataInitialized设为true,在下面四个函数对expenData进行操作之前，看看isExpenseDataInitialized是否为true,但是我觉得因为引入新的变量、新的初始化，就变得复杂也不是很好理解，还会增加错误，所以不是很推荐。


====14.2 顺序无关的语句           （陈渊）====


=== 第15章 使用条件语句===

====15.1 if语句                  （何刚）====
====15.2 case语句                （何刚）====


=== 第16章 控制循环===

====16.1 选择循环的种类           （徐杰）====
====16.2 循环控制                （徐杰）====
====16.3 轻松创建循环——由内而外   （刘思）====
====16.4 循环和数组的关系         （刘思）==== 


=== 第17章 不常见的控制结构===

====17.1 子程序中的多处返回       （郭思）==== 
====17.2 递归                   （郭思）====
====17.3 goto                   （兰杰）====
====17.4 针对不常见控制结构的观点  （兰杰）====


=== 第18章 表驱动法===

====18.1 表驱动法使用总则         （梁运）====
====18.2 直接访问表              （梁运）====
====18.3 索引访问表              （黄佳欣）====
====18.4 阶梯访问表              （黄佳欣）====
====18.5 表查询的其他示例         （黄佳欣）====

=== 第19章 一般控制问题===
====19.1 布尔表达式              （李腾飞）====
====19.2 复合语句（语句块）       （李腾飞）====
====19.3 空语句                  （时昌彬）====
====19.4 驯服危险的深层嵌套        （时昌彬）====
====19.5 编程基础：结构化编程      （陈欢欢）====
*“结构化”包括结构化分析、结构化设计以及结构化混日子
**'''*除了都创建于“结构化”被广泛推崇的时代之外，这些状态各异的结构化方法学之间并没有多少相互联系'''
*核心思想很简单
**一个应用程序应该只采用一些单入单出的控制结构（也称单一入口、单一出口的控制结构）
***'''*单入单出的控制结构指一个代码块，只有一个执行开始点与执行结束点'''
*执行方式是有序的且有规则的
*结构化编程的三个组成部分
**顺序
**选择
**迭代——是一组语句多次执行的控制结构（也称循环）
*结构化编程的中心论点——任何一个控制利用可以有顺序、选择和迭代三种结构构成

====19.6 控制结构与复杂度         （陈欢欢）====
*控制结构的作用是降低复杂度
*程序复杂度决定了理解程序所需要花费的精力
*控制流是影响复杂度的大因素之一
**'''*与控制流有关的复杂度非常重要——与不可靠的代码和频繁出现的错误息息相关'''
*度量复杂度——计算子程序的“决策点”的数量来衡量复杂度
**决策点初始值为1；
**遇到一次if，while，repeat，for，and，or决策点就加1
**Case语句中的每一种情况加1
*将子程序提取到另一个子程序，不会降低整个程序的复杂度，只是降低在同一时间必须关注的复杂度水平
*其他度量方法——所用的数据量、控制结构中的嵌套层数、代码行数、对同一变量的先后引用之间的代码行数（跨度）、变量生存的代码行数（生存期）以及输入的输出的量