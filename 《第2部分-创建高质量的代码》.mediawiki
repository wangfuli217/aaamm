=== 参加人员 ===
王程程  黄文文  李婷婷  陶晓鸣  刘炯  霍琦  戎祥  何茂森  董飞  李洋

=== 第5章 软件构建中的设计（王程程 霍琦）===
====5.1-5.2（王程程）====
====5.3-5.5（霍琪）====
关于启发式方法：
*在我眼里，启发式方法就是在解决问题时所采取的一种根据经验规则进行发现的方法，然后选择有效可行的方法。它不是很细节的，系统的方法，而是在一定认知范围内，能迅速解决问题的一种形式。
*启发式方法具有尝试错误的特点，所以可能会失败。其具体做法可以一步一步向前探寻。对每一步的结果都进行检查评价。这种探试有两种情况，一种是一步一步往深里探索，直到找出满意的方案为止。另一种是从尽可能多的备择方案中逐步进行筛选，直到找出满意方案为止。如在解决新的问题时，我可以自己根据问题本身采取新的计划框架，也可以在之前类似问题的解决方案上加以修改借用，显然后者更有效率更为可行。
=== 第6章 可以工作的类（李洋 陶晓明）===
====6.1类的基础·抽象数据类型（ADTs）（李洋）====
====6.1.1.明确类的定义====
*类是（一组'''数据'''）和''''子程序'''的集合，并且这些数据和子程序共同拥有一组类聚的、明确定义的职责。
*''成为高效程序员的一个关键点在于，当你开发程序任何一部分的代码时，都能安全的忽视程序中尽可能多的其余部分。''
====6.1.2.ADT的含义和益处====
*ADT（abstract data type）是指一些数据以及对这些数据进行的一些操作的集合。
*使用ADT主要的好处：
**可以隐藏实现细节
**改动不会影响到ADT外程序的其余部分
**让程序的正确性更显而易见，且更具自我说明性
**无须在程序内到处传递数据

====6.4-6.5（陶晓鸣）====
=== 第7章 高质量的子程序（刘炯 黄文文 董飞）===
====7.1-7.2（刘炯）====
====7.3-7.4（陶晓鸣）====
====7.5-7.7（董飞）====
=====7.5 如何使用子程序参数（董飞）=====

======不要把子程序的参数用作工作变量======
*'''坏代码'''
<pre> 
int Sample (int inputVal){
      inputVal = inputVal * CurrentMultiplier ( inputVal );
      return inputVal;     //此处的inputVal已经不再是当初传入的值了
}
</pre>
*'''好代码'''
<pre>
int Sample (int inputVal){
      int workingVal = inputVal;  //引入新的变量workingVal，消除了误用inputVal的可能  
      workingVal = workingVal * CurrentMultiplier ( workingVal );
      ...           //在此处或者其他地方还可以使用inputVal最初传入的值
      return workingVal;
}
</pre>
======子程序的参数按照一定的规则命名======
  如果你觉得把输入，修改，输出参数区分开很重要的话，那么就建立一种命名规则来对他们进行区分。可以为这给这些参数的名字加上Input_，Modify_，或Output_来当前缀。
======在接口中对参数的假定进行注释说明======
  如果你假定了传递给子程序的参数具有某种特性，那么就要对这种假定加以说明。
  应该对这些接口参数的假定进行说明：
   1.参数要被仅用于输入的、要被修改的、还是仅用于输出的；
   2.表示数量的参数的单位（如：千米、米、厘米）；
   3.状态代码和错误值的含义； 
   4.所能接受的数值的范围；
   5.不该出现的特定数值；
=== 第8章 防御式编程（戎祥 何茂森 李婷婷）===
====8.1-8.3（戎祥）====
=8.1-8.3心得 （戎祥）=
*1.检查所有来源于外部数据的值心得
====对于JAVA中传值我想对于有点JAVA基础的人都会知道的，因此我们在大学时候传值通常都是这样的：====
'''''void method1()

{int x=0;this.change(x);

System.out.println(x);
}'''''

'''''void change(int i)
{
i=1;
}'''''

可能在那时候我们会觉得这毫无问题，但是现在我们进入工作接触到业务了，那么我们在传参的时候就不能这么不小心了

比如说，我们程序中定义了一个字段，写数据库的时候规定它的大小位10位数，这时候我们在接下来的开发中我们就得小心了

不能传入大于十位的，或者说传入了不属于它类型的参数，因此这些都是我们今后在调用某个方法或者传参是必须要注意的。

--------------------------------------------------------------------------------------------------------
*2.决定如何处理错误的输入心得
===记得以前看过一本《JAVA编程思想》它里面讲了JAVA的基本理念就是“结构不佳的代码不能运行”，

我们发现错误的思想或者错误的时机是在编译阶段，也就是在你试图运行之前。但是我们在编译的时候

并不是能找出所有的错误的，所以余下的问题要在代码里解决，比如我们常遇到的try和catch

try{



}catch(){

}
但是我刚才所说的往往我们心里想的是这些都是可有可无的，写不写无所谓，但是如果我以后写的时候

再不注意这个细节我觉得我迟早会遇到麻烦的，所以养成加保险的习惯一定会对我们有所帮助的，切记切记

--------------------------------------------------------------------------------------------------------
*3断言心得
====断言我以前没怎么听说过，刚才我看了一下，大致的了解了一下，它是一个检测代码，通常是一个子程序或宏，

感觉挺有意思的，比如说客户要求该工程文件记录数不能超过50000，那么程序中可以包含一个断点记录小于50000

的断言====

'''''assert denominator !0 : "denominator is unexpectedly equal to 0."'''''

上述断言声明denominator 不会等于0.其中第一个参数，denominator ！=0，是个布尔表达式，其结果为true或者false

第二个参数是当第一个参数为false的时候，即断言为假的时候要打印消息

==由于以下涉及到宏留着明天慢慢看==


====8.4-8.5（李婷婷）====
====8.6-8.8（何茂森）====
=====8.6 辅助调试代码（何茂森）=====
======2.尽早引入辅助调试的代码。======
在程序开发的前期，越早引入辅助调试的代码，其能够提供的帮助也就越大。
======3.计划移除调试辅助的代码。======
例如C++的开发环境中，使用预处理器来控制调试用的代码：
<pre>
#define DEBUG
...
#if defined(DEBUG)
// 调试代码
...
#end if
</pre>
======3.编写自己的预处理器。======
如果某种语言没有包含一个预处理器，可以自己去写一个用于包含或排除调试代码的预处理器。例如JAVA里可以写一个预编译器来处理//#BEGIN DEBUG和//#END DEBUG等关键字