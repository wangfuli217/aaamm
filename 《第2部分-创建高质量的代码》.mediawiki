=== 参加人员 ===
王程程  黄文文  李婷婷  陶晓鸣  刘炯  霍琦  戎祥  何茂森  董飞  李洋

=== 第5章 软件构建中的设计（王程程 霍琦）===
====5.1-5.2（王程程）====
====5.3-5.5（霍琪）====
关于启发式方法：
*在我眼里，启发式方法就是在解决问题时所采取的一种根据经验规则进行发现的方法，然后选择有效可行的方法。它不是很细节的，系统的方法，而是在一定认知范围内，能迅速解决问题的一种形式。
*启发式方法具有尝试错误的特点，所以可能会失败。其具体做法可以一步一步向前探寻。对每一步的结果都进行检查评价。这种探试有两种情况，一种是一步一步往深里探索，直到找出满意的方案为止。另一种是从尽可能多的备择方案中逐步进行筛选，直到找出满意方案为止。如在解决新的问题时，我可以自己根据问题本身采取新的计划框架，也可以在之前类似问题的解决方案上加以修改借用，显然后者更有效率更为可行。

关于信息的抽象，封装和继承
*对于大多信息来说都是一种人为对事物认知的抽象，抽象的好处在于可以忽略无关的东西，取其主题表达的含义或作用。例如，门是一块长方形材料加上把手以及一定特定组织方式的抽象。
*基类是一种抽象，他有着派生类共同的特性，而某些独有的特性则可以通过继承方式给其他类进行使用。一个好的接口也是一种抽象，其关注的是接口本身，而不是类的内部工作方式。我们可以在子程序接口的层次上，在类接口的层次上进行抽象，就像在门把手的层次和门的层次上进行抽象一样，是开发更为效率和稳定。
*封装能帮助管理一些复杂的方法，其不只是让你能用简化的视图看复杂的内部，同时还不能让你看到复杂内部的细节。
*继承的好处在于它能很好的辅佐抽象的概念。例如，门从一种层次上看是各种分子，另一层次看是用来挡住盗贼的东西，用在不同的类方法中也有不同的代表属性。继承能简化编程的工作，例如一个子程序能依赖门的基本属性，另一个子程序能处理依赖特定种类门的特定操作。
*多态顾名思义是一个属性或动作的多种实行方式和实行状态。如bite()这个咬的方法，man这个类有bite（）这个动作方法，dog这个类也有bite（）这个动作方法，但两者显然是有区别的。

设计中启发式方法的总结：
*1寻找现实世界的对象
 2形成一致的抽象
 3封装实现细节
 4在可能的情况下继承
 5信息隐藏
 6找出容易改变的区域
 7保存松散耦合（还在研究中。。。。）
 8探寻通用的设计模式

关于设计策略心得：
*自上而下策略和自下而上策略的最关键的区别在于，前者是一种分解策略，后者是一种合成策略；前者从一般性的问题出发，把该问题分解成可控的部分。后者从可控的部分出发，去构造一个通用的方案。这两种方法都有各自的强项和弱项。

=== 第6章 可以工作的类（李洋 陶晓明）===
====6.1 类的基础·抽象数据类型（ADTs）（李洋）====
*明确类的定义
**类是（一组'''数据'''）和'''子程序'''的集合，并且这些数据和子程序共同拥有一组类聚的、明确定义的职责。
**''成为高效程序员的一个关键点在于，当你开发程序任何一部分的代码时，都能安全的忽视程序中尽可能多的其余部分。''
*ADT的含义和益处
**ADT（abstract data type）是指一些数据以及对这些数据进行的一些操作的集合。
**使用ADT主要的好处：
***可以隐藏实现细节
***改动不会影响到ADT外程序的其余部分
***让程序的正确性更显而易见，且更具自我说明性
***无须在程序内到处传递数据
====6.2 良好的类接口（李洋）====
*什么是良好的类接口
**类接口的抽象能力非常有价值，因为接口中的每个子程序都在朝着这个一致的目标而工作。
**类的接口要展现一直的抽象层次，好的办法是把类看作一种用来实现ADT的机制，且每一个类仅实现唯一一个ADT。
*坏的例子：
 class EmployeeCensus：public ListContainer{
 public：
 void AddEmployee( Employee employee )；
 void RemoveEmployee( Employee employee )；
 Employee NextItemInList()；
 Employee FirstItem()；
 Employee LastItem()；
 }
*好的例子：
 class Program{
 public：
 void InitializeUserInterface()；
 void ShutdownUserInterface()；
 void InitializeReports()；
 void ShutdownReports()；
 }
*类应提供成对的服务
**再设计一个类的时候，要检查每一个公用子程序，决定是否需要一个与其互补的操作（例如开关，新建删除等）。
**不要盲目的添加创建相反的操作，但是一定要考虑是否需要。
*尽可能让接口可编程，而不是表达语义
**每一个接口都由一个可编程（programmatic）的部分和一个语义（semantic）部分组成。语义部分应通过注释说明，但要尽可能让接口不依赖于这些说明，因为一个接口中任何无法通过编译器强制实施的部分，就是一个可能被误用的部分，要想办法吧语义接口的元素转换为编程接口的元素。
*谨防在修改时破坏接口的抽象
**以下，前部分代码的抽象很清晰，但是在雇工检查邮政编码、电话号码和职位的子程序之间并不存在什么逻辑上的关系，那些暴露了SQL语句查询细节的子程序所处的抽象层也比Employee类要低得多，他们破坏了该类的抽象。
*坏的例子
 class Employee {
 public:
   FullName GetName() const;
   Address GetAddress() const;
   PhoneNumber GetPhoneNumber() const;
   bool IsJobClassifcationValid( JobClassifcation JobClass );
   bool IsZipCodeValid( Address address );
   bool IsPhoneNameValid( PhoneNumber phoneNumber );
   SqlQuery GetQueryTOCreateNewEmployee() const;
   SqlQuery GetQueryToModifyEmployee() const;
   SqlQuery GetQueryToRetrieveEmployee() const;
 private:
 }
*剔除类中不相关的信息
**当你发现某个类中一半子程序使用着该类的一半数据，另一半子程序使用着另一半数据，那么请把其中之一剔除，并明确类的定义。
*尽可能降低可访问性(良好的封装)
**让可访问性（accessibility）尽可能低是促成封装的原则之一。如果能确定暴露一个子程序不会让抽象变得不一致的话，这么做就很可能是可行的。如果不能确定，那么多隐藏通常比少隐藏要好！
*不要公开暴露成员信息
**暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。
**以下第一种暴露，调用方代码可以自由地使用该类的数据，而该类甚至不知道这些数据什么时候被改动过。第二种暴露仅仅暴露了方法，但整体还是包装好的，别人无法得知这些数据如何用于底层实现的。
*不好的暴露
 float x;
 float y;
 float z;
*可行的暴露
 float GetX();
 float GetY();
 float GetZ();
*要留意过于紧密的耦合关系
**耦合指的是两个类之间关联的紧密程度，通常，这种关联越松越好。
**如何降低类的耦合关系；
***尽可能的限制类和成员的可访问性以减少暴露；
***避免使用友元类，其会增加同一时刻要考虑到的代码量；
***在基类中把数据声明为private而不是protected，可以降低派生类和基类的耦合程度；
***避免在类的公开接口中暴露成员数据；
***不要因为一个程序里仅使用公用子程序，就把他归入公开接口；
***要对从语义上破坏封装保持警惕。
====6.3 有关设计和实现的问题（李洋）====
*包含和继承的比较
**包含是（Containment）“有一个······”的关系，它表示一个类含有一个基本数据元素或对象。
**继承是（Inheritance）“是一个······”的关系；它表示一个类是另一个类的一种特化（specialization）。
**包含是一个非常简单的概念，与包含相比，继承需要更多的技巧，而且更容易出错，但并不是意味着继承比包含更好。相反，包含才是面向对象编程的主力技术。
*如何使用继承
**通过使用关键字extends，子类可以继承父类所有的方法和属性，但是无法使用 private(私有) 的方法和属性。
**下述实例可以使用instanceof语句来证明前者是否为后者的继承类。
*实例
 public class Dog extends Mammal{
   public static void main(String args[]){
      Animal a = new Animal();
      Mammal m = new Mammal();
      Dog d = new Dog();
      System.out.println(m instanceof Animal);
      System.out.println(d instanceof Mammal);
      System.out.println(d instanceof Animal);
    }
 }
*数据类型尽量不使用protected类型
**当你从一个对象继承时，你就拥有了能够访问该对象中protected子程序和protected数据的特权，这很可能会暴露封装的成员数据，因此说继承很可能会破坏封装。
**好的解决方式是让所有数据都是private型，而不是可能受到访问的protected类型。
*重写（Override）的概念和使用
**重写是子类对父类的允许访问的方法的'''实现过程'''进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！ 
**重写的好处在于子类可以根据需要，定义特定于自己的行为。
*重写实例：
 class Animal{
    public void move(){
       System.out.println("动物可以移动");
    }
 }
 class Dog extends Animal{
    public void move(){
       System.out.println("狗可以跑和走");
    }
 }
 public class TestDog{
    public static void main(String args[]){
       Animal a = new Animal(); // Animal 对象
       Animal b = new Dog(); // Dog 对象
       a.move();// 执行 Animal 类的方法
       b.move();//执行 Dog 类的方法
    }
 }
*使用多态避免大量的类型检查
**多态是同一个行为具有多个不同表现形式或形态的能力，多态存在必备的条件是：继承、重写、父类引用指向子类对象。
**多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理，更容易理解的是能够避免大量的类型检查。
*多态实例：
 public class Test {
     public static void main(String[] args) {
       show(new Cat());
       show(new Dog());                
   }   
     public static void show(Animal a)  {
       a.eat();  
         // 类型判断
         if (a instanceof Cat)  {  // 猫做的事情 
             Cat c = (Cat)a;  
             c.work();  
         } else if (a instanceof Dog) { // 狗做的事情 
             Dog c = (Dog)a;  
             c.work();  
         }  
     }  
 }
 abstract class Animal {  
     abstract void eat();  
 }  
 class Cat extends Animal {  
     public void eat() {  
         System.out.println("吃鱼");  
     }  
     public void work() {  
         System.out.println("抓老鼠");  
     }  
 }    
 class Dog extends Animal {  
     public void eat() {  
         System.out.println("吃骨头");  
     }  
     public void work() {  
         System.out.println("看家");  
     }  
 } 
*避免继承体系过深
**大多数人在脑中应付两到三层的继承时就会出现麻烦，混淆数据类型等。所以应该尽量把继承的深度控制在五层以内。

====6.4-6.5（陶晓鸣）====
=== 第7章 高质量的子程序（刘炯 黄文文 董飞）===
====7.1-7.2（刘炯）====
====7.1高质量的子程序心得（刘炯）====
创建子程序的正当理由：<br /> 
使用子程序可以有效的降低程序的复杂度，避免大规模的重复；<br /> 
缩小代码规模，后期便于修改，如果在程序中的十几处地方都出现了相同的代码，那么测试也就要重复好几次；<br /> 
改善性能，使用子程序可以只在一个地方优化代码，可以方便查出那些地方的代码运行效率低下。<br /> 
例如有一个程序中有很多地方用到下面这个计算：<br /> 
*'''''原代码'''''
 int num1,num2,num3,maxNum;
 scanf("%d%d%d",&num1,&num2,&num3);
 maxNum=num1;            
 if(maxNum<num2)        
     maxNum=num2;
 if(maxNum<num3)        
     maxNum=num3;
     printf("%d\n",maxNum); 
这个就是一个从三个数字中取得最大值的程序，但是，他原本可以更清楚些，所以我创建了一个子程序，并取了一个能看懂的名字：
*'''''使用子程序代码'''''
 getmaxNum（num1,num2,num3）｛
    int num1,num2,num3,maxNum;
    maxNum=num1;            
    if(maxNum<num2)        
        maxNum=num2;
    if(maxNum<num3)        
        maxNum=num3;
 ｝
在用这个子程序取代了之前代码之后，程序中的那几行代码就成了下面这样：
 maxNum = getmaxNum（num1,num2,num3）； 
这行代码更具有可读性
====7.2在子程序上的设计（刘炯）==== 
在子程序的设计上有一个专业性的名字“内聚性”，对于子程序而言，内聚性指的是子程序中各个操作之间联系的紧密程度，而我们的目标是让一个子程序只把一件事做好，不再做其他任何事情，这样做的好处就是得到了更高的可靠性，而内聚性还有几个层次，接下来分别讨论。
*顺序上的内聚性和通信上的内聚性：<br />
假设某个子程序需要按照给定出生年份来计算出员工的年龄和退休时间，假设员工55岁退休，对于这个按理可以用两种方法编写,如果子程序先计算员工的年龄，再根据他的年龄计算退休时间，那么它就具有顺序的内聚性，具体如下：<br />
 void getageandRetirementtime （int datetime，int age，int Retirementtime）｛
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (age - 55)；
 ｝
而如果子程序先计算员工的年龄，然后再重新计算他的退休时间，两次计算只是碰巧使用了相同的出生年份，那么这个子程序就只具有通信上的内聚性，具体代码如下：<br />
 void getageandRetirementtime （int datetime，int age，int Retirementtime）｛
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (timeinfo->tm_year + 1900 - datetime - 55)；
 ｝
这两个子函数包含两个特定的计算，他们需要共享数据，而且只有全部执行才可以完成一项完整的功能。<br />
*过程上的内聚性：<br />
顾名思义，过程上的内聚性就是只子程序的执行是按照一定的顺序进行的，比如说有一个登录画面的小窗口，你需要输入帐号，密码，验证码三条信息之后才可以登录成功，而在后台对于程序来说，首先会根据你输入的位置，取得你输入的帐号，密码，验证码，然后再与数据库存贮的个人信息比对，如果相符则登录成功，这个子程序就具有了过程上的内聚性。<br />
*逻辑上的内聚性：<br />
这个内聚性主要是致一个子程序有很多操作，根据传入的参数不同结果有所不同，例如某个子程序的功能是输入学生的考试成绩，成绩>=90，输出成绩优秀，如果>=80，输出成绩良好，如果>=70，输出成绩中等，如果>=60，输出成绩及格，否则输出不及格，具体如下：<br />
 void outputgrades（ int score ）{
 char * s[]={"excellent","fine","medium","fail"}
 if( score >= 90 )
 return s[0]；
 else if( score>=80 )
 return s[1]；
 else if( score>=60 )
 return s[2];
 else 
 return s[3];
 }
这个程序操作很多，他最大的特点是操作都在if else语句中，但是结果只能有一个，这个就具有逻辑上的内聚性。<br />
====7.3-7.4（陶晓鸣）====
====7.3子程序的名字的心得（陶晓鸣）====
子程序的命名一般遵循以下几个原则:
▪可以表示子程序的功能<br />
▪不使用表意不清的动词<br />
  例如DealWithOutPut()，根本不能直接告诉别人这个子程序是用来处理怎样一个业务的。<br />
▪不简单的通过sum1、sum2、sum3、等数字来命名子程序<br />
  一个project会有很多的子程序都以数字命名，会使得工程乱的一塌糊涂，其结果就是对开发，维护人员造成很大的困扰。<br />
▪子程序的名字长度要适中<br />
▪函数的命名要对其返回值有说明<br />
  customerId.Next(),studentId.total(),都可以很明确的表明函数的输出结果。<br />
▪子程序表示一个过程，子程序名应当要给定相应的宾语<br />
  很简单的一个例子，PrinterDocument(),对象宾语Document，动作Printer。<br />
▪起名要相互对仗<br />
	add/remove<br />
	open/close<br />
	min/max<br />
	first/last<br />
▪遵循项目给定的命名原则<br />
	这个在我们实际的项目中经常会遇到，每个项目都会有自己的一套命名规则，遵循这个命名规则，可以使各个class之间的联系更加显而易见。<br />
====7.4子程序的长度问题（陶晓鸣）====
最佳的子程序的长度<br />
通过研究表明100至200行的有序代码是最佳的子程序长度。不同的项目考虑到不同子程序的内聚性、嵌套的层次、变量的数量、注释的多少以及一些跟复杂度相关的考虑事项，每个子程序的长短会有所不同。但是国外多项研究表明了，太短的代码，每行代码的成本会比最佳长度代码的每行成本高；太长的代码每行代码所含的错误会比最佳长度代码多，并且100至200行的代码的修改率是最低的。<br />
所以我们在开发的过程中一定要注意每个子程序代码的长度，以达到成本最低化，代码最优化，错误最低化。

====7.5-7.7（董飞）====
====7.5 如何使用子程序参数 （董飞）====
*不要把子程序的参数用作工作变量
*'''坏代码'''
<pre> 
int Sample (int inputVal){
      inputVal = inputVal * CurrentMultiplier ( inputVal );
      return inputVal;     //此处的inputVal已经不再是当初传入的值了
}
</pre>
*'''好代码'''
<pre>
int Sample (int inputVal){
      int workingVal = inputVal;  //引入新的变量workingVal，消除了误用inputVal的可能  
      workingVal = workingVal * CurrentMultiplier ( workingVal );
      ...           //在此处或者其他地方还可以使用inputVal最初传入的值
      return workingVal;
}
</pre>
*子程序的参数按照一定的规则命名
如果你觉得把输入，修改，输出参数区分开很重要的话，那么就建立一种命名规则来对他们
进行区分。可以为这给这些参数的名字加上Input_，Modify_，或Output_来当前缀。
*在接口中对参数的假定进行注释说明
如果你假定了传递给子程序的参数具有某种特性，那么就要对这种假定加以说明。<br/>
应该对这些接口参数的假定进行说明：
#参数要被仅用于输入的、要被修改的、还是仅用于输出的；
#表示数量的参数的单位（如：千米、米、厘米）；
#状态代码和错误值的含义； 
#所能接受的数值的范围；
#不该出现的特定数值；
*按照输入-修改-输出的顺序排列参数
不要随机的排列参数，应该先把仅作为输入的参数列出，然后是既作为输入又作为输出的参数，最后是仅作为输出的参数。这种排列方法暗示了子程序的内部操作所发生的顺序，先是输入数据，然后修改数据，最后是输出结果。
*把状态或出错变量放在最后
按照习惯做法，状态变量和那些用于指示发生错误的变量应该放在参数表的最后它们只是附属于程序的主要功能，而且他们是仅用于输出的参数。
*把子程序的参数个数限制在7个以内
对于通常人来说，我们很难记住7个以上单位的信息。所以说为了避免混淆，我们应该把参数的个数控制在7个以内。如果你发现自己一直需要传递很多参数，这就说明子程序之间的耦合太过紧密了。那么你就应该重新设计子程序，降低其间的耦合度。
====7.6使用函数时要特别考虑的问题（董飞）====
*不要反回指向局部数据的引用或指针
当子程序执行结束，其局部数据流都出了作用域，那么任何指向局部数据的引用或指针也随之失效。如果一个对象需要返回有关其内部数据的信息，那就应该把这些信息保存为类的数据成员
*检查函数所有可能的返回路径
在编写函数时，先在脑海中执行每一条执行路径。确保在所有可能的情况下该函数都会返回值。最好在函数开头用一个默认值来初始化返回值。
====7.7宏子程序和内联子程序（董飞）====
*把宏表达式整个包含在括号内
*'''不能正确展开的宏'''
<pre>
#defin Cube(a) {a}*{a}*{a}   //如果在使用Cube()的表达式里含有比乘法运算符优先级更高的运算符，那么{a}*{a}*{a}就会失效
</pre>
*'''可以正确展开的宏'''
<pre>
#defin Cube(a) {{a}*{a}*{a}}
</pre>
*把含有多条语句的宏用大括号括起来
一个宏可以含有多条语句，如果你把它只当做一条语句就会出错，因为它和常规函数的执行方式是不同的。当使用for循环调用宏的时候，如果宏里的语句没有用大括号括起来，for循环只会调用宏的第一条语句。
*'''无法工作含有多条语句的宏'''
<pre>
#define LookupEntry(key,index)
  index = (key-10)/5;
  index = min(index,MAX_INDEX);
  index = max(index,MIN_INDEX);
  ...
for(entryCount = 0;entryCount<numEntries;entryCount++)
  LookupEntry(entryCount，tableIndex[entryCount]);
</pre>
在上面的代码中，for循环语句中只有宏的第一部分代码被执行。即“index = (key-10)/5；”被执行。
*'''可以工作含有多条语句的宏'''
<pre>
#define LookupEntry(key,index){
  index = (key-10)/5;
  index = min(index,MAX_INDEX);
  index = max(index,MIN_INDEX);
}
 ...
for(entryCount = 0;entryCount<numEntries;entryCount++)
  LookupEntry(entryCount，tableIndex[entryCount]);
</pre>
*用给子程序命名的方法给宏命名
C++语言中给宏命名的方式是全部使用大写字母。如果当我们遇到能用子程序来代替宏的时候，那么给宏命名的时候我们就应该采用给子程序命名的规则。这样当你想用子程序代替宏的时候，除了需要修改相关的子程序外，其他的不需要改动。
*建类时要提供成对的方法
如果我们创建了一个向表中插入数据的方法，那么很可能也需要一个删除表中数据的方法。所以当建类的时候要检查每一个公用子程序，然后决定是否需要提供与其相反的操作。也不要盲目的去创建相反的操作，应该看看你是否真的需要它。
*'''例子'''
<pre>
public class Man{
  private String name;
  public void setName(String name) {
    this.name = name;
}
  public void getName(String name) {
    return name;
}
}
</pre>
*不要公开暴露成员数据
我们都知道封装是面向对象的重要原则，并尽可能的隐藏对象内部的细节。如果你不知道某个子程序的可访问性应该设为private,public还是protected那么建议你采用最严格且可执行的访问级别。
*不要建只有一个实例的类
一个类中只有一个实例很有可能是你把类和对象混淆了，这时你应该重新建一个对象而不是重新建一个类。
=== 第8章 防御式编程（戎祥 何茂森 李婷婷）===
====8.1-8.3（戎祥）====
====检查所有来源于外部数据的值心得====
对于JAVA中传值我想对于有点JAVA基础的人都会知道的，因此我们在大学时候传值通常都是这样的：
 void method1()

 {int x=0;this.change(x);
 System.out.println(x);
 }

 void change(int i)
 {
 i=1;
 }

可能在那时候我们会觉得这毫无问题，但是现在我们进入工作接触到业务了，那么我们在传参的时候就不能这么不小心了

比如说，我们程序中定义了一个字段，写数据库的时候规定它的大小位10位数，这时候我们在接下来的开发中我们就得小心了

不能传入大于十位的，或者说传入了不属于它类型的参数，因此这些都是我们今后在调用某个方法或者传参是必须要注意的。

--------------------------------------------------------------------------------------------------------
====决定如何处理错误的输入心得====
记得以前看过一本《JAVA编程思想》它里面讲了JAVA的基本理念就是“结构不佳的代码不能运行”，

我们发现错误的思想或者错误的时机是在编译阶段，也就是在你试图运行之前。但是我们在编译的时候

并不是能找出所有的错误的，所以余下的问题要在代码里解决，比如我们常遇到的try和catch

 try{



 }catch(){

 }
但是我刚才所说的往往我们心里想的是这些都是可有可无的，写不写无所谓，但是如果我以后写的时候

再不注意这个细节我觉得我迟早会遇到麻烦的，所以养成加保险的习惯一定会对我们有所帮助的，切记切记

--------------------------------------------------------------------------------------------------------
====断言心得====
断言我以前没怎么听说过，刚才我看了一下，大致的了解了一下，它是一个检测代码，通常是一个子程序或宏，

感觉挺有意思的，比如说客户要求该工程文件记录数不能超过50000，那么程序中可以包含一个断点记录小于50000

的断言

 assert denominator !0 : "denominator is unexpectedly equal to 0.“

上述断言声明denominator 不会等于0.其中第一个参数，denominator ！=0，是个布尔表达式，其结果为true或者false

第二个参数是当第一个参数为false的时候，即断言为假的时候要打印消息


====断言的心得====
断言在使用的时候所需要注意的有以下几点

*用错误处理代码赖处理预期会发生的情况，用断言处理绝不应该发生的情况

*避免把需要执行的代码放到断言中，例如：

*'''''坏代码'''''

<pre>
Debug.Assert(PerformAction() ) ' Couldn't perform action
</pre>

*'''''好代码'''''

<pre>
actionPerformed = PerformAction()

Debug.Assert(actionPerformed) ' Couldn't perform action
</pre>

----------------------------------------------------------------------------------------------------------
====错误处理技术的心得====

上诉断言是用来处理代码中不应该发生的错误，而下列的方法是用来处理预料中可能要发生的错误：

*返回中立值

*换用下一个正确的数据

*返回与前次相同的数据

*还用最接近的合法值

*返回一个错误码
-------------------------------------------------------------------------------------------
====6.1抽象数据类型（戎祥）====
====抽象数据类型的心得====
首先官方一点解释一下：<br/>
是指一些数据以及对这些数据所进行的操作的集合。我想这么解释大家可能有点蒙圈。<br/>
还记得大学时候老师解释了什么叫做抽象：<br/>
比如你的领导让你去买烟，只是说了句买烟，剩下的全交给你，那么领导的这句话就叫做抽象<br/>
底下的要做的事比如什么牌子的烟，哪里产的，什么规格的这些都靠你自己去定义那么这个过程就叫做抽象的实现<br/>
抽象有点类似与Java中的接口，接口与抽象的方便性我相信大家有目共睹的<br/>
写个简单的抽象类的例子<br/>
*'''''抽象类原代码'''''
 abstract class Instrument{
 private int i;
 public abstract void play(Note n);
 }
*'''''实现类原代码'''''
 class Wind extends Instrument {
 public void play(Note n) {
 print{"Wind.play()" +n};
 }
与之相似但又不似的便是接口了他们之间虽然功能都是差不多的，但是要求却不同:<br/>
====接口与实现类的差别====
*从语法定义层面看abstract class 和 interface<br/> 
*abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。<br/> 
*接口中的方法默认都是 public,abstract 类型的。<br/>
*接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值<br/>
====6.2良好的封装心得（C6518 戎祥）====
封装是一个比抽象更强的概念，我的理解是：抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度<br/>
而封装则强制阻止你看到细节——即便你想这么做。<br/>
那封装有哪些好处呢：<br>
*尽可能地限制类和成员的可访问性
*不要公开暴露成员数据（举个例子）
*'''''坏代码'''''
 int x;
 int y;
 int z;
*'''''好代码'''''
 int Getx();
 int Gety();
 int Getz();
 void Setx(int x);
 void Sety(int y);
 void Setz(int z);

上诉中坏代码他就破坏了封装性<br/>
*避免把私用的实现细节放入类的接口中
----------------------------------------------------------------------------------------------------------------
====应该避免的类心得（C6518 戎祥）====
建类我想对于大家来说都是非常简单的一件事，但是建一个好类一个又实用的类你却知道多少呢，所以我整理了一下<br/>
*避免创建万能的类
如果一个类把功夫都花在用get,set方法上向其它索要数据的话，请考虑是否应该把这些功能阻止到其它类中去<br/>
*消除无关紧要的类
要是一个类只含有数据没有其它行为的话，你也得考虑是否值得建一个类。<br/>
*避免用动词命名的类
--------------------------------------------------------------------------------------------------------------------
====创建子程序的心得（C6518 戎祥）====
下面列出了一些创建子程序的正当理由：<br/>
*降低复杂度(直接调用该子程序无需了解内部细节)
*引入中间，易懂的抽象
'''''坏代码'''''
 if(node<>NULL)then
  while(node.next<>NULL)do
   node = node.next
   leafName = node.name
  end while
 else
  leafName = ""
'''''好代码'''''
 leafName = GetLeafName( node )
*避免代码重复（把相同的部分提取出来，放入一个基类）
-----------------------------------------------------------------------------------------------------------------
====如何使用子程序参数（C6518 戎祥）====
我挑个Java的例子看了一下,就是不要把子程序的参数用做工作变量<br/>
'''''坏代码'''''
 int Test(int inputVal){
    inputVal = inputVal*CurrentMultiplier(inputVal)
    inputVal = inputVal+CurrentMultiplier(inputVal )
    ...
    return inputVal ;
 }

'''''好代码'''''
 int Test(int inputVal){
    int workingVal = inputVal 
    workingVal = inputVal*CurrentMultiplier(workingVal )
    workingVal = inputVal+CurrentMultiplier(workingVal )
    ...
    return workingVal ;
 }
引入 workingVal 这个变量便很好的区分了inputVal 这个变量，避免错误时间错误调用<br/>
----------------------------------------------------------------------------------------------------------
====使用函数时需要考虑的问题心得（C6518 戎祥）====
*什么时候使用函数
如果一个子程序的主要用途就是返回其名字所指的返回值那么就使用函数<br/>
*设置函数的返回值
在coding的时候一定要清楚自己写这个函数的目的，一定要在自己脑海里走一遍，确保在所有可能情况下都是这个返回值<br/>

====8.4-8.5（李婷婷）====
----
====8.4 异常（何茂森）====
*异常简介
异常是把代码中的错误或者发生的异常事件传递给调用异常的方法的一种特殊的手段

*异常的用途
异常的用途主要是通知程序的其他部分，发生了某些不可忽视的错误

*使用异常的注意点

::避免使用空的catch语句。

<pre>
java反例：
try{
   ...
   //很多的代码
   ...
}catch(AnException exception){
}
</pre>
空的异常语句只能说明要么是try里面的内容不对，无故抛出了异常，要么是catch里的代码不对，不能有效的处理异常，应该做类似下面的修改：
<pre>
java正例：
try{
   ...
   //很多的代码
   ...
}catch(AnException exception){
   LogError("Unexpected exception");
}
</pre>
当然，上述的catch语句里面也只是简单的进行了一个错误日志的打印，没有深层次的去处理异常，仍然有待改善。

::避免在构造函数里抛出异常

在构造函数里面抛出异常会使异常的处理变得很复杂，有时候会造成资源的泄露。

::在恰当的层次抛出异常

对于抛出的异常，其实可以将其看作是程序接口的一部分，和其他的数据类型一样进行处理，但是如果异常的层次和子程序接口的程序不一致的话，会破坏程序的封装性，也使程序变得更加难以管理。
例如下面这段java异常的代码：
<pre>
java反例：
class Employee{
    	...
    	public TaxId GetTaxId() throws EOFException{
		...
	}
	...
}
</pre>
上面的这段抛出异常的程序里面，EOFException异常是结束文件的异常，其抽象层次比较低，这种时候，子程序的调用方就不与Employee耦合，而是与抛出EOFException异常的代码相耦合，应做如下修改：
<pre>
java正例：
class Employee{
    	...
    	public TaxId GetTaxId() throws EmployeeDataNotAvailable{
		...
	}
	...
}
</pre>
上述EmployeeDataNotAvailable异常是与Employee相一致的异常，这样的程序才更加容易管理，也有更好的封装性

::异常中应该加入有关异常发生的信息

加入异常发生的信息能够帮助开发人员了解这个异常，并找出相关的对策，避免异常的发生 。

----
====8.6 辅助调试代码（何茂森）====
*尽早引入辅助调试的代码。
在程序开发的前期，越早引入辅助调试的代码，其能够提供的帮助也就越大。
*计划移除调试辅助的代码。
例如C++的开发环境中，使用预处理器来控制调试用的代码：
<pre>
#define DEBUG
...
#if defined(DEBUG)
// 调试代码
...
#end if
</pre>
*编写自己的预处理器。
如果某种语言没有包含一个预处理器，可以自己去写一个用于包含或排除调试代码的预处理器。例如JAVA里可以写一个预编译器来处理//#BEGIN DEBUG和//#END DEBUG等关键字
----

====8.7确定在产品代码中该保留多少防御式代码心得（何茂森）====
*保留检查重要错误的代码
重要的错误往往会引发软件的重大事故，需要重点关注，对于这部分错误需要着着重关注，此部分检查错误的代码也应保留下来一应对后续出现的问题。

*去掉检查细微错误的代码
某些错误可能对整个软件几乎没有影响，或者是影响微乎其微，对于这种错误的检查代码可以不用保留在工程内部，以减少工程代码的冗余。

*去掉可能导致程序硬性崩溃的代码
程序开发阶段可以允许有错误，也可以允许有引起程序硬性崩溃的代码，但是当程序走向产品的时候，不允许有这样的代码出现，必须将其移除程序之内。

*保留可以让程序稳妥崩溃的代码
如果你的程序里有能够检测出潜在严重错误的代码，那么可以保留某些可以让程序稳妥崩溃的代码，这些代码在程序的后期能够给开发者提供某些关键信息，以改善程序，使得后续的程序可以获得更高的质量。
*为技术支持人员纪录错误信息
可以考虑在产品代码中保留一些辅助调试代码，这些代码能够帮助技术人员纪录错误信息，使最终产品有更好的质量。
----
====8.8对防御式编程采取防御的姿态心得====
*不可过度的采取防御式编程
如果在每个能想到的地方都采取防御式编程的话，会使程序变得臃肿而缓慢，也增加了软件的复杂度，因此需要因地制宜地调整防御式编程的优先级。
*防御式编程核对表
针对不同的防御式编程，可参照P211页的防御式编程核对表（cc2e.com/0868），根据该表区分一般事宜/异常/安全事宜，并以此来调整辅助代码的数量
*防御式编程的优点
防御式编程可以让错误更容易被发现，更容易修改，减少错误对产品代码的破坏，同时也能在一定程度上保证程序的稳定性。