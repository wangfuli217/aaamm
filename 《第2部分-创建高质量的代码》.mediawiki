=== 参加人员 ===
王程程  黄文文  李婷婷  陶晓鸣  刘炯  霍琦  戎祥  何茂森  董飞  李洋

=== 第5章 软件构建中的设计（王程程 霍琦）===
====5.1-5.2（王程程）====
====5.3-5.5（霍琪）====
关于启发式方法：
*在我眼里，启发式方法就是在解决问题时所采取的一种根据经验规则进行发现的方法，然后选择有效可行的方法。它不是很细节的，系统的方法，而是在一定认知范围内，能迅速解决问题的一种形式。
*启发式方法具有尝试错误的特点，所以可能会失败。其具体做法可以一步一步向前探寻。对每一步的结果都进行检查评价。这种探试有两种情况，一种是一步一步往深里探索，直到找出满意的方案为止。另一种是从尽可能多的备择方案中逐步进行筛选，直到找出满意方案为止。如在解决新的问题时，我可以自己根据问题本身采取新的计划框架，也可以在之前类似问题的解决方案上加以修改借用，显然后者更有效率更为可行。

关于信息的抽象，封装和继承
*对于大多信息来说都是一种人为对事物认知的抽象，抽象的好处在于可以忽略无关的东西，取其主题表达的含义或作用。例如，门是一块长方形材料加上把手以及一定特定组织方式的抽象。
*基类是一种抽象，他有着派生类共同的特性，而某些独有的特性则可以通过继承方式给其他类进行使用。一个好的接口也是一种抽象，其关注的是接口本身，而不是类的内部工作方式。我们可以在子程序接口的层次上，在类接口的层次上进行抽象，就像在门把手的层次和门的层次上进行抽象一样，是开发更为效率和稳定。
*封装能帮助管理一些复杂的方法，其不只是让你能用简化的视图看复杂的内部，同时还不能让你看到复杂内部的细节。
*继承的好处在于它能很好的辅佐抽象的概念。例如，门从一种层次上看是各种分子，另一层次看是用来挡住盗贼的东西，用在不同的类方法中也有不同的代表属性。继承能简化编程的工作，例如一个子程序能依赖门的基本属性，另一个子程序能处理依赖特定种类门的特定操作。
*多态顾名思义是一个属性或动作的多种实行方式和实行状态。如bite()这个咬的方法，man这个类有bite（）这个动作方法，dog这个类也有bite（）这个动作方法，但两者显然是有区别的。

=== 第6章 可以工作的类（李洋 陶晓明）===
====6.1类的基础·抽象数据类型（ADTs）（李洋）====
====6.1.1.明确类的定义====
*类是（一组'''数据'''）和''''子程序'''的集合，并且这些数据和子程序共同拥有一组类聚的、明确定义的职责。
*''成为高效程序员的一个关键点在于，当你开发程序任何一部分的代码时，都能安全的忽视程序中尽可能多的其余部分。''
====6.1.2.ADT的含义和益处====
*ADT（abstract data type）是指一些数据以及对这些数据进行的一些操作的集合。
*使用ADT主要的好处：
**可以隐藏实现细节
**改动不会影响到ADT外程序的其余部分
**让程序的正确性更显而易见，且更具自我说明性
**无须在程序内到处传递数据
====6.2 良好的类接口（李洋）====
====6.2.1 什么是良好的类接口====
*类接口的抽象能力非常有价值，因为接口中的每个子程序都在朝着这个一致的目标而工作。
*类的接口要展现一直的抽象层次，好的办法是把类看作一种用来实现ADT的机制，且每一个类仅实现唯一一个ADT。
*坏的例子：
 class EmployeeCensus：public ListContainer{
 public：
 void AddEmployee( Employee employee )；
 void RemoveEmployee( Employee employee )；
 Employee NextItemInList()；
 Employee FirstItem()；
 Employee LastItem()；
 }
*好的例子：
 class Program{
 public：
 void InitializeUserInterface()；
 void ShutdownUserInterface()；
 void InitializeReports()；
 void ShutdownReports()；
 }
====6.4-6.5（陶晓鸣）====
=== 第7章 高质量的子程序（刘炯 黄文文 董飞）===
====7.1-7.2（刘炯）====
====7.1高质量的子程序心得（刘炯）====
创建子程序的正当理由：<br /> 
使用子程序可以有效的降低程序的复杂度，避免大规模的重复；<br /> 
缩小代码规模，后期便于修改，如果在程序中的十几处地方都出现了相同的代码，那么测试也就要重复好几次；<br /> 
改善性能，使用子程序可以只在一个地方优化代码，可以方便查出那些地方的代码运行效率低下。<br /> 
例如有一个程序中有很多地方用到下面这个计算：<br /> 
*'''''原代码'''''
 int num1,num2,num3,maxNum;
 scanf("%d%d%d",&num1,&num2,&num3);
 maxNum=num1;            
 if(maxNum<num2)        
     maxNum=num2;
 if(maxNum<num3)        
     maxNum=num3;
     printf("%d\n",maxNum); 
这个就是一个从三个数字中取得最大值的程序，但是，他原本可以更清楚些，所以我创建了一个子程序，并取了一个能看懂的名字：
*'''''使用子程序代码'''''
 getmaxNum（num1,num2,num3）｛
    int num1,num2,num3,maxNum;
    maxNum=num1;            
    if(maxNum<num2)        
        maxNum=num2;
    if(maxNum<num3)        
        maxNum=num3;
 ｝
在用这个子程序取代了之前代码之后，程序中的那几行代码就成了下面这样：
 maxNum = getmaxNum（num1,num2,num3）； 
这行代码更具有可读性
====7.2在子程序上的设计（刘炯）==== 
在子程序的设计上有一个专业性的名字“内聚性”，对于子程序而言，内聚性指的是子程序中各个操作之间联系的紧密程度，而我们的目标是让一个子程序只把一件事做好，不再做其他任何事情，这样做的好处就是得到了更高的可靠性，而内聚性还有几个层次，接下来分别讨论。
顺序上的内聚性和通信上的内聚性：<br />
假设某个子程序需要按照给定出生年份来计算出员工的年龄和退休时间，假设员工55岁退休，对于这个按理可以用两种方法编写,如果子程序先计算员工的年龄，再根据他的年龄计算退休时间，那么它就具有顺序的内聚性，具体如下：<br />
 void getageandRetirementtime （int datetime）｛
    int age，Retirementtime；
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (age - 55)；
 ｝
而如果子程序先计算员工的年龄，然后再重新计算他的退休时间，两次计算只是碰巧使用了相同的出生年份，那么这个子程序就只具有通信上的内聚性，具体代码如下：<br />
 void getageandRetirementtime （int datetime）｛
    int age，Retirementtime；
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (timeinfo->tm_year + 1900 - datetime - 55)；
 ｝
这两个子函数包含两个特定的计算，他们需要共享数据，而且只有全部执行才可以完成一项完整的功能。<br />
====7.3-7.4（陶晓鸣）====
====7.5-7.7（董飞）====
====7.5 如何使用子程序参数心得 （董飞）====
=====不要把子程序的参数用作工作变量=====
*'''坏代码'''
<pre> 
int Sample (int inputVal){
      inputVal = inputVal * CurrentMultiplier ( inputVal );
      return inputVal;     //此处的inputVal已经不再是当初传入的值了
}
</pre>
*'''好代码'''
<pre>
int Sample (int inputVal){
      int workingVal = inputVal;  //引入新的变量workingVal，消除了误用inputVal的可能  
      workingVal = workingVal * CurrentMultiplier ( workingVal );
      ...           //在此处或者其他地方还可以使用inputVal最初传入的值
      return workingVal;
}
</pre>
=====子程序的参数按照一定的规则命名=====
如果你觉得把输入，修改，输出参数区分开很重要的话，那么就建立一种命名规则来对他们
进行区分。可以为这给这些参数的名字加上Input_，Modify_，或Output_来当前缀。
=====在接口中对参数的假定进行注释说明=====
如果你假定了传递给子程序的参数具有某种特性，那么就要对这种假定加以说明。<br/>
应该对这些接口参数的假定进行说明：
*1.参数要被仅用于输入的、要被修改的、还是仅用于输出的；
*2.表示数量的参数的单位（如：千米、米、厘米）；
*3.状态代码和错误值的含义； 
*4.所能接受的数值的范围；
*5.不该出现的特定数值；
=====按照输入-修改-输出的顺序排列参数=====
不要随机的排列参数，应该先把仅作为输入的参数列出，然后是既作为输入又作为输出的参数，最后是仅作为输出的参数。这种排列方法暗示了子程序的内部操作所发生的顺序，先是输入数据，然后修改数据，最后是输出结果。
=====把状态或出错变量放在最后=====
按照习惯做法，状态变量和那些用于指示发生错误的变量应该放在参数表的最后它们只是附属于程序的主要功能，而且他们是仅用于输出的参数。
=====把子程序的参数个数限制在7个以内=====
对于通常人来说，我们很难记住7个以上单位的信息。所以说为了避免混淆，我们应该把参数的个数控制在7个以内。如果你发现自己一直需要传递很多参数，这就说明子程序之间的耦合太过紧密了。那么你就应该重新设计子程序，降低其间的耦合度。
=== 第8章 防御式编程（戎祥 何茂森 李婷婷）===
====8.1-8.3（戎祥）====
====检查所有来源于外部数据的值心得====
对于JAVA中传值我想对于有点JAVA基础的人都会知道的，因此我们在大学时候传值通常都是这样的：
 void method1()

 {int x=0;this.change(x);
 System.out.println(x);
 }

 void change(int i)
 {
 i=1;
 }

可能在那时候我们会觉得这毫无问题，但是现在我们进入工作接触到业务了，那么我们在传参的时候就不能这么不小心了

比如说，我们程序中定义了一个字段，写数据库的时候规定它的大小位10位数，这时候我们在接下来的开发中我们就得小心了

不能传入大于十位的，或者说传入了不属于它类型的参数，因此这些都是我们今后在调用某个方法或者传参是必须要注意的。

--------------------------------------------------------------------------------------------------------
====决定如何处理错误的输入心得====
记得以前看过一本《JAVA编程思想》它里面讲了JAVA的基本理念就是“结构不佳的代码不能运行”，

我们发现错误的思想或者错误的时机是在编译阶段，也就是在你试图运行之前。但是我们在编译的时候

并不是能找出所有的错误的，所以余下的问题要在代码里解决，比如我们常遇到的try和catch

 try{



 }catch(){

 }
但是我刚才所说的往往我们心里想的是这些都是可有可无的，写不写无所谓，但是如果我以后写的时候

再不注意这个细节我觉得我迟早会遇到麻烦的，所以养成加保险的习惯一定会对我们有所帮助的，切记切记

--------------------------------------------------------------------------------------------------------
====断言心得====
断言我以前没怎么听说过，刚才我看了一下，大致的了解了一下，它是一个检测代码，通常是一个子程序或宏，

感觉挺有意思的，比如说客户要求该工程文件记录数不能超过50000，那么程序中可以包含一个断点记录小于50000

的断言

 assert denominator !0 : "denominator is unexpectedly equal to 0.“

上述断言声明denominator 不会等于0.其中第一个参数，denominator ！=0，是个布尔表达式，其结果为true或者false

第二个参数是当第一个参数为false的时候，即断言为假的时候要打印消息


====断言的心得====
断言在使用的时候所需要注意的有以下几点

*用错误处理代码赖处理预期会发生的情况，用断言处理绝不应该发生的情况

*避免把需要执行的代码放到断言中，例如：

*'''''坏代码'''''

<pre>
Debug.Assert(PerformAction() ) ' Couldn't perform action
</pre>

*'''''好代码'''''

<pre>
actionPerformed = PerformAction()

Debug.Assert(actionPerformed) ' Couldn't perform action
</pre>

----------------------------------------------------------------------------------------------------------
====错误处理技术的心得====

上诉断言是用来处理代码中不应该发生的错误，而下列的方法是用来处理预料中可能要发生的错误：

*返回中立值

*换用下一个正确的数据

*返回与前次相同的数据

*还用最接近的合法值

*返回一个错误码
-------------------------------------------------------------------------------------------
===6.1抽象数据类型（戎祥）===
====抽象数据类型的心得====
首先官方一点解释一下：<br/>
是指一些数据以及对这些数据所进行的操作的集合。我想这么解释大家可能有点蒙圈。<br/>
还记得大学时候老师解释了什么叫做抽象：<br/>
比如你的领导让你去买烟，只是说了句买烟，剩下的全交给你，那么领导的这句话就叫做抽象<br/>
底下的要做的事比如什么牌子的烟，哪里产的，什么规格的这些都靠你自己去定义那么这个过程就叫做抽象的实现<br/>
抽象有点类似与Java中的接口，接口与抽象的方便性我相信大家有目共睹的<br/>
写个简单的抽象类的例子<br/>
*'''''抽象类原代码'''''
 abstract class Instrument{
 private int i;
 public abstract void play(Note n);
 }
*'''''实现类原代码'''''
 class Wind extends Instrument {
 public void play(Note n) {
 print{"Wind.play()" +n};
 }
与之相似但又不似的便是接口了他们之间虽然功能都是差不多的，但是要求却不同:<br/>
===接口与实现类的差别===
*从语法定义层面看abstract class 和 interface<br/> 
*abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。<br/> 
*接口中的方法默认都是 public,abstract 类型的。<br/>
*接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值<br/>



====8.4-8.5（李婷婷）====

====8.6 辅助调试代码（何茂森）====
*尽早引入辅助调试的代码。
在程序开发的前期，越早引入辅助调试的代码，其能够提供的帮助也就越大。
*计划移除调试辅助的代码。
例如C++的开发环境中，使用预处理器来控制调试用的代码：
<pre>
#define DEBUG
...
#if defined(DEBUG)
// 调试代码
...
#end if
</pre>
*编写自己的预处理器。
如果某种语言没有包含一个预处理器，可以自己去写一个用于包含或排除调试代码的预处理器。例如JAVA里可以写一个预编译器来处理//#BEGIN DEBUG和//#END DEBUG等关键字
----

====8.7确定在产品代码中该保留多少防御式代码心得（何茂森）====
*保留检查重要错误的代码
重要的错误往往会引发软件的重大事故，需要重点关注，对于这部分错误需要着着重关注，此部分检查错误的代码也应保留下来一应对后续出现的问题。

*去掉检查细微错误的代码
某些错误可能对整个软件几乎没有影响，或者是影响微乎其微，对于这种错误的检查代码可以不用保留在工程内部，以减少工程代码的冗余。

*去掉可能导致程序硬性崩溃的代码
程序开发阶段可以允许有错误，也可以允许有引起程序硬性崩溃的代码，但是当程序走向产品的时候，不允许有这样的代码出现，必须将其移除程序之内。

*保留可以让程序稳妥崩溃的代码
如果你的程序里有能够检测出潜在严重错误的代码，那么可以保留某些可以让程序稳妥崩溃的代码，这些代码在程序的后期能够给开发者提供某些关键信息，以改善程序，使得后续的程序可以获得更高的质量。
*为技术支持人员纪录错误信息
可以考虑在产品代码中保留一些辅助调试代码，这些代码能够帮助技术人员纪录错误信息，使最终产品有更好的质量。
