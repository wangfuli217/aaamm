=== 参加人员 ===
王程程  黄文文  李婷婷  陶晓鸣  刘炯  霍琦  戎祥  何茂森  董飞  李洋

=== 第5章 软件构建中的设计（王程程 霍琦）===
====5.1-5.2（王程程）====
====5.3-5.5（霍琪）====
关于启发式方法：
*在我眼里，启发式方法就是在解决问题时所采取的一种根据经验规则进行发现的方法，然后选择有效可行的方法。它不是很细节的，系统的方法，而是在一定认知范围内，能迅速解决问题的一种形式。
*启发式方法具有尝试错误的特点，所以可能会失败。其具体做法可以一步一步向前探寻。对每一步的结果都进行检查评价。这种探试有两种情况，一种是一步一步往深里探索，直到找出满意的方案为止。另一种是从尽可能多的备择方案中逐步进行筛选，直到找出满意方案为止。如在解决新的问题时，我可以自己根据问题本身采取新的计划框架，也可以在之前类似问题的解决方案上加以修改借用，显然后者更有效率更为可行。
=== 第6章 可以工作的类（李洋 陶晓明）===
====6.1类的基础·抽象数据类型（ADTs）（李洋）====
====1.明确类的定义====
*类是（一组'''数据'''）和''''子程序'''的集合，并且这些数据和子程序共同拥有一组类聚的、明确定义的职责。
*''成为高效程序员的一个关键点在于，当你开发程序任何一部分的代码时，都能安全的忽视程序中尽可能多的其余部分。''

====6.4-6.5（陶晓鸣）====
=== 第7章 高质量的子程序（刘炯 黄文文 董飞）===
====7.1-7.2（刘炯）====
====7.3-7.4（陶晓鸣）====
====7.5-7.7（董飞）====
=====7.5 如何使用子程序参数=====

======不要把子程序的参数用作工作变量======
*'''坏代码'''
<pre> 
int Sample (int inputVal){
      inputVal = inputVal * CurrentMultiplier ( inputVal );
      return inputVal;     //此处的inputVal已经不再是当初传入的值了
}
</pre>
*'''好代码'''
<pre>
int Sample (int inputVal){
      int workingVal = inputVal;  //引入新的变量workingVal，消除了误用inputVal的可能  
      workingVal = workingVal * CurrentMultiplier ( workingVal );
      ...           //在次处或者其他地方还可以使用inputVal最初传入的值
      return workingVal;
}
</pre>
======子程序的参数按照一定的规则命名======
  如果你觉得把输入，修改，输出参数区分开很重要的话，那么就建立一种命名规则来对他们进行区分。可以为这给这些参数的名字加上Input_，Modify_，或Output_来当前缀。
======在接口中对参数的假定进行注释说明======
  如果你假定了传递给子程序的参数具有某种特性，那么就要对这种假定加以说明。
  应该对这些接口参数的假定进行说明：
   1.参数要被仅用于输入的、要被修改的、还是仅用于输出的；
   2.表示数量的参数的单位（如：千米、米、厘米）；
   3.状态代码和错误值的含义； 
   4.所能接受的数值的范围；
   5.不该出现的特定数值；
=== 第8章 防御式编程（戎祥 何茂森 李婷婷）===
====8.1-8.3（戎祥）====
====8.4-8.5（李婷婷）====
====8.6-8.8（何茂森）====
=====8.6 辅助调试代码（何茂森）=====
1.尽早引入辅助调试的代码。
在程序开发的前期，越早引入辅助调试的代码，其能够提供的帮助也就越大。
2.计划移除调试辅助的代码。
例如C++的开发环境中，使用预处理器来控制调试用的代码：
<pre>
#define DEBUG
...
#if defined(DEBUG)
// 调试代码
...
#end if
</pre>
3.编写自己的预处理器。
如果某种语言没有包含一个预处理器，可以自己去写一个用于包含或排除调试代码的预处理器。例如JAVA里可以写一个预编译器来处理//#BEGIN DEBUG和//#END DEBUG等关键字