=== 参加人员 ===
王程程  黄文文  李婷婷  陶晓鸣  刘炯  霍琦  戎祥  何茂森  董飞  李洋

=== 第5章 软件构建中的设计（王程程 霍琦）===
====5.1-5.2（王程程）====
====5.3-5.5（霍琪）====
====5.3 设计构造块：启发式方法 ====
关于启发式方法：
*在我眼里，启发式方法就是在解决问题时所采取的一种根据经验规则进行发现的方法，然后选择有效可行的方法。它不是很细节的，系统的方法，而是在一定认知范围内，能迅速解决问题的一种形式。
*启发式方法具有尝试错误的特点，所以可能会失败。其具体做法可以一步一步向前探寻。对每一步的结果都进行检查评价。这种探试有两种情况，一种是一步一步往深里探索，直到找出满意的方案为止。另一种是从尽可能多的备择方案中逐步进行筛选，直到找出满意方案为止。如在解决新的问题时，我可以自己根据问题本身采取新的计划框架，也可以在之前类似问题的解决方案上加以修改借用，显然后者更有效率更为可行。

关于信息的抽象，封装和继承
*对于大多信息来说都是一种人为对事物认知的抽象，抽象的好处在于可以忽略无关的东西，取其主题表达的含义或作用。例如，门是一块长方形材料加上把手以及一定特定组织方式的抽象。
*基类是一种抽象，他有着派生类共同的特性，而某些独有的特性则可以通过继承方式给其他类进行使用。一个好的接口也是一种抽象，其关注的是接口本身，而不是类的内部工作方式。我们可以在子程序接口的层次上，在类接口的层次上进行抽象，就像在门把手的层次和门的层次上进行抽象一样，是开发更为效率和稳定。
*封装能帮助管理一些复杂的方法，其不只是让你能用简化的视图看复杂的内部，同时还不能让你看到复杂内部的细节。
*继承的好处在于它能很好的辅佐抽象的概念。例如，门从一种层次上看是各种分子，另一层次看是用来挡住盗贼的东西，用在不同的类方法中也有不同的代表属性。继承能简化编程的工作，例如一个子程序能依赖门的基本属性，另一个子程序能处理依赖特定种类门的特定操作。
*多态顾名思义是一个属性或动作的多种实行方式和实行状态。如bite()这个咬的方法，man这个类有bite（）这个动作方法，dog这个类也有bite（）这个动作方法，但两者显然是有区别的。

关于信息的有效隐藏：
*信息隐藏最核心的在于：隐藏（类或方法）的复杂度，程序员在关注代码时，不需要具体了解一个类内部的所有错综的结构和体系，只需要注意类的接口的作用，来调用类。隐藏变化源，当需要变化或修改一个工程时，其代码变化的影响范围就会被限制。（其中变化的或修改的可以是数据类型如int,char,bool等，文件结构，算法）
*对于一个良好的类来说，一些类中的重要信息特性（可能包含多种数据类型或结构体）应该被隐藏起来，而一些标准化的全局信息对外可见；对于类的接口来说，尽可能少得暴露内部的工作机制是关键，设计接口是一个迭代的过程，在多种渠道方法试验之后采取最稳定有效的方案。
*简洁明了的例子：用变量存储某一信息（ID，手机号等）。对于初学者而言，可能定义一个变量int id;然后id = id ++。对于没经验的程序员有可能会考虑去年一些，如果索取的id值是非连续的或者要通过一个断言来判断id值不会超过最大实际范围，那么在程序中有id++出现的地方可能需要多次被修改。id++其实也暴露了自己创建ID的方法，很不安全，一旦程序涉及多线程的话可能由于某个机制导致整个工程崩溃（因为类也属于线程）。相反可创建一个对象方法，把创建ID的方法隐藏起来，如id = Newid(),当需要对ID进行变化时，只要修改Newid()的子程序即可。此外关于隐藏ID的类型，如用typedef来重新定义ID类型，这类似于定义一个宏define全局变量，以便日后修改类型的方便，减少改动所影响的代码量。
*把类和结构体放在头文件中可以做到关键代码的隐藏，但是完全隐藏的话还需去除其他信息，在头文件中除了类和结构体指针再无其他东西。
*在test.h头文件中：
 class B;
 class A{
      int i;
      B* b;
      friend int getI(A*);
  public :
      void initialize();
      void cleanup;
 };
**在Class A的定义中声明一个B的指针变量，编译器知道如何传递一个地址，这地址大小是一定的，如果试图传递整个对象编译器就必须知道B的全部定义以确定他的大小和如何传递他，声明一个B b变量显然不够隐藏。
*cpp文件
 class B{
 public :
   int i;
 };

 int getI(A* a){
    a ->i = 5;
    a ->b ->i += a ->i;
    return a ->b ->i;
 }

 void A::initialize(){
    b = new B();
    b-> i = 5;
 }

 void A::cleanup(){
     delete b;
 }

*main 函数
 #include <iostream>
 #include "test.h"
 using namespace std;

  int main(){
     A aa;
     aa.initialize();
     cout << getI(&aa);
     aa.cleanup;
     return 0;
 }

关于找出代码易变的问题：
*找出变化点，抽象出来，把变化隐藏起来（和信息的隐藏挂钩），使变化的影响降到最低。一个好的代码或者工程能适应各种来自外界变化所引起的干扰。
*关于找出变化的自我心得：首先找出系统中对用户有用的最小集，作为围绕点，因为这部分是最不容易变化的地方，然后慢慢的一步步扩展这个地方，循序渐进，这些后来增加的地方就是潜在可能变化的地方。打个比方：又拿ID的例子，当所确定ID的需要的类型时（如int型），这是围绕ID作为原始点，在考虑其他变量如工号，出勤次数等变量时，对于它们而言就是潜在的变化量，因为它们的类型有可能由int变为char或者double等等。


关于设计策略心得：
*自上而下策略和自下而上策略的最关键的区别在于，前者是一种分解策略，后者是一种合成策略；前者从一般性的问题出发，把该问题分解成可控的部分。后者从可控的部分出发，去构造一个通用的方案。这两种方法都有各自的强项和弱项。

=== 第6章 可以工作的类（李洋 陶晓明）===
====6.1 类的基础·抽象数据类型（ADTs）（李洋）====
*明确类的定义
**类是（一组'''数据'''）和'''子程序'''的集合，并且这些数据和子程序共同拥有一组类聚的、明确定义的职责。
**''成为高效程序员的一个关键点在于，当你开发程序任何一部分的代码时，都能安全的忽视程序中尽可能多的其余部分。''
*ADT的含义和益处
**ADT（abstract data type）是指一些数据以及对这些数据进行的一些操作的集合。
**使用ADT主要的好处：
***可以隐藏实现细节
***改动不会影响到ADT外程序的其余部分
***让程序的正确性更显而易见，且更具自我说明性
***无须在程序内到处传递数据
====6.2 良好的类接口（李洋）====
*什么是良好的类接口
**类接口的抽象能力非常有价值，因为接口中的每个子程序都在朝着这个一致的目标而工作。
**类的接口要展现一直的抽象层次，好的办法是把类看作一种用来实现ADT的机制，且每一个类仅实现唯一一个ADT。
*坏的例子：
 class EmployeeCensus：public ListContainer{
 public：
 void AddEmployee( Employee employee )；
 void RemoveEmployee( Employee employee )；
 Employee NextItemInList()；
 Employee FirstItem()；
 Employee LastItem()；
 }
*好的例子：
 class Program{
 public：
 void InitializeUserInterface()；
 void ShutdownUserInterface()；
 void InitializeReports()；
 void ShutdownReports()；
 }
*类应提供成对的服务
**再设计一个类的时候，要检查每一个公用子程序，决定是否需要一个与其互补的操作（例如开关，新建删除等）。
**不要盲目的添加创建相反的操作，但是一定要考虑是否需要。
*尽可能让接口可编程，而不是表达语义
**每一个接口都由一个可编程（programmatic）的部分和一个语义（semantic）部分组成。语义部分应通过注释说明，但要尽可能让接口不依赖于这些说明，因为一个接口中任何无法通过编译器强制实施的部分，就是一个可能被误用的部分，要想办法吧语义接口的元素转换为编程接口的元素。
*谨防在修改时破坏接口的抽象
**以下，前部分代码的抽象很清晰，但是在雇工检查邮政编码、电话号码和职位的子程序之间并不存在什么逻辑上的关系，那些暴露了SQL语句查询细节的子程序所处的抽象层也比Employee类要低得多，他们破坏了该类的抽象。
*坏的例子
 class Employee {
 public:
   FullName GetName() const;
   Address GetAddress() const;
   PhoneNumber GetPhoneNumber() const;
   bool IsJobClassifcationValid( JobClassifcation JobClass );
   bool IsZipCodeValid( Address address );
   bool IsPhoneNameValid( PhoneNumber phoneNumber );
   SqlQuery GetQueryTOCreateNewEmployee() const;
   SqlQuery GetQueryToModifyEmployee() const;
   SqlQuery GetQueryToRetrieveEmployee() const;
 private:
 }
*剔除类中不相关的信息
**当你发现某个类中一半子程序使用着该类的一半数据，另一半子程序使用着另一半数据，那么请把其中之一剔除，并明确类的定义。
*尽可能降低可访问性(良好的封装)
**让可访问性（accessibility）尽可能低是促成封装的原则之一。如果能确定暴露一个子程序不会让抽象变得不一致的话，这么做就很可能是可行的。如果不能确定，那么多隐藏通常比少隐藏要好！
*不要公开暴露成员信息
**暴露成员数据会破坏封装性，从而限制你对这个抽象的控制能力。
**以下第一种暴露，调用方代码可以自由地使用该类的数据，而该类甚至不知道这些数据什么时候被改动过。第二种暴露仅仅暴露了方法，但整体还是包装好的，别人无法得知这些数据如何用于底层实现的。
*不好的暴露
 float x;
 float y;
 float z;
*可行的暴露
 float GetX();
 float GetY();
 float GetZ();
*要留意过于紧密的耦合关系
**耦合指的是两个类之间关联的紧密程度，通常，这种关联越松越好。
**如何降低类的耦合关系；
***尽可能的限制类和成员的可访问性以减少暴露；
***避免使用友元类，其会增加同一时刻要考虑到的代码量；
***在基类中把数据声明为private而不是protected，可以降低派生类和基类的耦合程度；
***避免在类的公开接口中暴露成员数据；
***不要因为一个程序里仅使用公用子程序，就把他归入公开接口；
***要对从语义上破坏封装保持警惕。
====6.3 有关设计和实现的问题（李洋）====
*包含和继承的比较
**包含是（Containment）“有一个······”的关系，它表示一个类含有一个基本数据元素或对象。
**继承是（Inheritance）“是一个······”的关系；它表示一个类是另一个类的一种特化（specialization）。
**包含是一个非常简单的概念，与包含相比，继承需要更多的技巧，而且更容易出错，但并不是意味着继承比包含更好。相反，包含才是面向对象编程的主力技术。
*如何使用继承
**通过使用关键字extends，子类可以继承父类所有的方法和属性，但是无法使用 private(私有) 的方法和属性。
**下述实例可以使用instanceof语句来证明前者是否为后者的继承类。
*实例
 public class Dog extends Mammal{
   public static void main(String args[]){
      Animal a = new Animal();
      Mammal m = new Mammal();
      Dog d = new Dog();
      System.out.println(m instanceof Animal);
      System.out.println(d instanceof Mammal);
      System.out.println(d instanceof Animal);
    }
 }
*数据类型尽量不使用protected类型
**当你从一个对象继承时，你就拥有了能够访问该对象中protected子程序和protected数据的特权，这很可能会暴露封装的成员数据，因此说继承很可能会破坏封装。
**好的解决方式是让所有数据都是private型，而不是可能受到访问的protected类型。
*重写（Override）的概念和使用
**重写是子类对父类的允许访问的方法的'''实现过程'''进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！ 
**重写的好处在于子类可以根据需要，定义特定于自己的行为。
*重写实例：
 class Animal{
    public void move(){
       System.out.println("动物可以移动");
    }
 }
 class Dog extends Animal{
    public void move(){
       System.out.println("狗可以跑和走");
    }
 }
 public class TestDog{
    public static void main(String args[]){
       Animal a = new Animal(); // Animal 对象
       Animal b = new Dog(); // Dog 对象
       a.move();// 执行 Animal 类的方法
       b.move();//执行 Dog 类的方法
    }
 }
*使用多态避免大量的类型检查
**多态是同一个行为具有多个不同表现形式或形态的能力，多态存在必备的条件是：继承、重写、父类引用指向子类对象。
**多态可以使程序有良好的扩展，并可以对所有类的对象进行通用处理，更容易理解的是能够避免大量的类型检查。
*多态实例：
 public class Test {
     public static void main(String[] args) {
       show(new Cat());
       show(new Dog());                
   }   
     public static void show(Animal a)  {
       a.eat();  
         // 类型判断
         if (a instanceof Cat)  {  // 猫做的事情 
             Cat c = (Cat)a;  
             c.work();  
         } else if (a instanceof Dog) { // 狗做的事情 
             Dog c = (Dog)a;  
             c.work();  
         }  
     }  
 }
 abstract class Animal {  
     abstract void eat();  
 }  
 class Cat extends Animal {  
     public void eat() {  
         System.out.println("吃鱼");  
     }  
     public void work() {  
         System.out.println("抓老鼠");  
     }  
 }    
 class Dog extends Animal {  
     public void eat() {  
         System.out.println("吃骨头");  
     }  
     public void work() {  
         System.out.println("看家");  
     }  
 } 
*避免继承体系过深
**大多数人在脑中应付两到三层的继承时就会出现麻烦，混淆数据类型等。所以应该尽量把继承的深度控制在五层以内。
*什么是构造函数？
**构造函数是其主要功能是用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用。在java中一般被称为构造器，有时也称为构造方法。
**构造器使用的注意点：
***构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）；
***每个类可以有一个以上的构造器；
***构造器可以有0个、1个或1个以上的参数；
***构造器没有返回值。
*如何使用构造器：
 public class A{  
     public A(){  
        System.out.println("调用了无参的构造函数");
   }  
     public A(String mess){  
        System.out.println("调用了有参的构造函数\n"+  
           "参数内容为："+mess);  
   }  
 }  
 public class Test{  
     public static void main(String [] args){  
        A a_1=new A();//调用无参的构造函数  
        A a_2=new A("Hello");//调用有参的构造函数  
    }  
 }
*用私用构造函数去实现单件。
**单件就是一个类在它的作用域内,能且只能生成一个对象,并且所有用它定义的对象都是操作那这一个对象!
**如果可能，应该在所有构造器中初始化所有的数据成员。
*实例：
 class testSingleton{
     static testSingleton instance;//类的单例
     private testSingleton{};//私有的构造函数
     public static testSingleton getInstance()//返回 单例
   {
        if(instance == null)
        instance = new testSingleton();
        return instance;
    }
 }
*继承如何和构造函数一起使用
**使用super调用父类构造函数的语句必须是子类构造函数的第一条语句。
**如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果同时父类没有不带参数的构造器，则java编译器将会报错。
**以上两点要在同时使用继承和构造函数时特别注意。
*正确代码:()
 public class A{  
     public A(){  
        System.out.println("调用了A的无参构造函数");  
     }  
     public A(String mess){  
        System.out.println("调用了A的有参的构造函数\n"+  
           "参数内容为："+mess);  
     }  
 }  
 public class B extends A{  
     public B(){  
        System.out.println("调用了B的无参构造函数");  
     }  
     public B(String mess){  
        super(mess);  
        System.out.println("调用了B的有参构造函数\n"+  
           "参数内容为："+mess);  
     }  
 }
 public class B extends A{  
     public B(){  
        System.out.println("调用了B的无参构造函数");  
     }  
     public B(String mess){  
        super(mess);  
        System.out.println("调用了B的有参构造函数\n"+  
           "参数内容为："+mess);  
     }  
 }  
*代码输出结果：
 调用了A的无参构造函数
 调用了B的无参构造函数
 调用了A的有参的构造函数
 参数内容为：你好
 调用了B的有参构造函数
 参数内容为：你好
*优先采用深层复本
**复本的动机是为了改善性能，再设计复杂对象时要优先采用深层复本，除非论证可行之后，才能采用浅层复本（以下第四点说明理由）。
**Java对象的'''浅层复本'''是指Java对象A本身被clone成新对象B,但A的属性没有被clone处理，只是把A的各个属性所指的对象赋值到B对应的属性上，A与B的相同属性都引用到同一个对象。
**Java对象的'''深层复本'''是指Java对象A本身被clone成新对象B，同时A的属性也是被clone成新对象，赋值到A的各个属性上去，A与B的相同属性都引用到不同的对象； 
**如果Java对象的属性都是只读类的话，如原始数据类型、数据封装类、String、BigDecimal、BigInteger等，那么浅层复制与深层复制达到的效果是一样的。如果属性有Date或其他自定的数据类，那么线层复制，B的修改可能导致A的改变。数据就串了。
====6.4-6.5（陶晓鸣）====
====6.4创建类的原因（C6514 陶晓鸣）====
*学习编码这么久，对于创建类大家应该都很熟悉，但是有没有想过我们为什么要创建类？或者说我们在什么情况下要创建类？下面我们说说创建类的几点原因：<br />
**为一个现实或者抽象的对象建模<br />
***java最主要的特征就是面向对象，我们可以把一个现实的对象用代码的形式为它建模。而建模的最好方式就是为它创建一个实体类，在实体类中包含对象的所有属性数据，然后可以通过创建一些action类来为它的行为建模。这也是我们在平时工作中最经常遇到的创建类的原因。<br />
***当然我们对于一切抽象的对象，也可以用同样的方法来为它建模。<br />
***例如，我们要做一个房地产买卖的项目。其中每一处房产都是一个现实的对象，我们可以通过创建类的方式，将它的属性如房产地址（address）、房屋面积（floor_space）、房屋编号（project_cd）等数据放入一个实体类中。而每一次的交易记录则都是一个抽象的对象，创建抽象的实体类，其中包括了交易的时间（trade_time）、交易金额（trade_money）、卖方、买方等信息。<br />
*降低了程序的复杂度以及程序之间的耦合度<br />
**就像上面的例子，将房屋的信息都包含到一个类当中去，我们只要使用这个类就可以调用到类中的所有信息，而不需要去考虑在这个类其内部的工作原理。自然，将一个对象数据的处理都放入到一个类中的处理，我们在去修正其中某个数据时，不需要去考虑这个数据对其他类产生的影响。这也就降低了程序之间的耦合度。<br />
*隐藏实现细节<br />
*减少变动影响的范围<br />
*隐藏全局数据<br />
*让代码更易于重用（C6514 陶晓鸣）<br />
**NASA的软件工程实验室研究表明，在形成了一定的代码基础的前提下，面向功能的设计思想比面向对象的设计思想的代码重用率少得多。所以面向对象的设计思想更加适用于现代的商业代码的开发。这也是我们创建类的重要原因之一<br />
*为程序族做准备<br />
**什么叫程序族呢？就是功能相类似的项目所形成的程序。在已经开发过一个相类似的项目的基础上，再开发另一个程序，我们只要在原有的程序上修改一些实体类，或者一些再加一些action类就可以了。这样可以大大地减少我们开发成本，从而创造更多的利润。<br />
====6.5具体编程语言相关问题—JAVA方法的覆盖（C6514 陶晓鸣）====
*1）子类方法的名称、参数签名和返回类型必须与父类方法的名称、参数签名和返回类型一致，修饰符可以相同也可以不同，但子类的访问权限不能低于父类的访问权限。<br />
**实例：
class Aball {
    Aball() {
    }
    public void method() {
    }
}
public class ExtendsMethod extends Aball {
    ExtendsMethod() {
    }
    public void method() {//覆盖父类的方法
    }
    public int method(int i) {//重载类中的方法
       i++;
       return i;
    }
}  
*2）父类的私有方法不能被子类覆盖。<br />
**实例：
class Aball {
    Aball() {
    }
    private String method() {
       return "Aball";
    }
    void print() {
       System.out.println(method());
    }
}
public class ExtendsMethod extends Aball {
    ExtendsMethod() {
    }
    public String method() {// 覆盖父类的方法
       return "ExtendsMethod";
    }
    public static void main(String[] args) {
       Aball sub1 = new Aball();
       ExtendsMethod sub2 = new ExtendsMethod(); 
       sub1.print();
       sub2.print();
    }
}
**结果为：
Aball<br />
Aball<br />
**执行sub2.print()方法时，因为print()方法在Aball类中定义，因此Aball方法会调用在Aball类中定义的private类型的method()方法。<br />
把Aball类的method()方法改为public类型，期他代码不变，则运行结果为：<br />
Aball<br />
ExtendsMethod<br />
原因是由于ExtendsMethod中的method()方法覆盖了Aball类中的method()方法，执行sub2.print()时，JVM会调用当前ExtendsMethod实例的method()方法。<br />
*3）父类的抽象方法可以被子类通过两种途径覆盖：一是子类实现父类的抽象方法；二是子类重新声明父类的抽象方法。（C6514 陶晓鸣）<br />
**实例：<br />
abstract class Aball {
    Aball() {
    }
    abstract void method();
    abstract void print();
}
 public abstract class ExtendsMethod extends Aball {
    ExtendsMethod() {
    }
    public void method() {// 实现method()方法，并扩大访问权限
    } 
    // 重新声明print()方法，并扩大访问权限，但不实现
    public abstract void print();
}
*4）父类的非抽象方法可以被覆盖为抽象方法。<br />
**实例：<br />
abstract class Aball {
    Aball() {
    }
    void method() {
    }
    void print() {
    }
}
public abstract class ExtendsMethod extends Aball {
    ExtendsMethod() {
    }
    public void method() {// 覆盖父类的method()方法
    }
    // 覆盖父类的print()方法
    public abstract void print();
}

=== 第7章 高质量的子程序（刘炯 黄文文 董飞）===
====7.1-7.2（刘炯）====
====7.1高质量的子程序心得（刘炯）====
创建子程序的正当理由：<br /> 
使用子程序可以有效的降低程序的复杂度，避免大规模的重复；<br /> 
缩小代码规模，后期便于修改，如果在程序中的十几处地方都出现了相同的代码，那么测试也就要重复好几次；<br /> 
改善性能，使用子程序可以只在一个地方优化代码，可以方便查出那些地方的代码运行效率低下。<br /> 
例如有一个程序中有很多地方用到下面这个计算：<br /> 
*'''''原代码'''''
 int num1,num2,num3,maxNum;
 scanf("%d%d%d",&num1,&num2,&num3);
 maxNum=num1;            
 if(maxNum<num2)        
     maxNum=num2;
 if(maxNum<num3)        
     maxNum=num3;
     printf("%d\n",maxNum); 
这个就是一个从三个数字中取得最大值的程序，但是，他原本可以更清楚些，所以我创建了一个子程序，并取了一个能看懂的名字：
*'''''使用子程序代码'''''
 getmaxNum（num1,num2,num3）｛
    int num1,num2,num3,maxNum;
    maxNum=num1;            
    if(maxNum<num2)        
        maxNum=num2;
    if(maxNum<num3)        
        maxNum=num3;
 ｝
在用这个子程序取代了之前代码之后，程序中的那几行代码就成了下面这样：
 maxNum = getmaxNum（num1,num2,num3）； 
这行代码更具有可读性
====7.2在子程序上的设计（刘炯）==== 
在子程序的设计上有一个专业性的名字“内聚性”，对于子程序而言，内聚性指的是子程序中各个操作之间联系的紧密程度，而我们的目标是让一个子程序只把一件事做好，不再做其他任何事情，这样做的好处就是得到了更高的可靠性，而内聚性还有几个层次，接下来分别讨论。
*顺序上的内聚性和通信上的内聚性：<br />
假设某个子程序需要按照给定出生年份来计算出员工的年龄和退休时间，假设员工55岁退休，对于这个按理可以用两种方法编写,如果子程序先计算员工的年龄，再根据他的年龄计算退休时间，那么它就具有顺序的内聚性，具体如下：<br />
 void getageandRetirementtime （int datetime，int age，int Retirementtime）｛
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (age - 55)；
 ｝
而如果子程序先计算员工的年龄，然后再重新计算他的退休时间，两次计算只是碰巧使用了相同的出生年份，那么这个子程序就只具有通信上的内聚性，具体代码如下：<br />
 void getageandRetirementtime （int datetime，int age，int Retirementtime）｛
    time_t nowyear;
    struct tm *timeinfo;
    time( &nowyear );  //获取时间
    timeinfo = localtime( &nowyear ); //转换时间格式
    age = timeinfo->tm_year + 1900 - datetime;
    Retirementtime = timeinfo->tm_year + 1900 + (timeinfo->tm_year + 1900 - datetime - 55)；
 ｝
这两个子函数包含两个特定的计算，他们需要共享数据，而且只有全部执行才可以完成一项完整的功能。<br />
*过程上的内聚性：<br />
顾名思义，过程上的内聚性就是只子程序的执行是按照一定的顺序进行的，比如说有一个登录画面的小窗口，你需要输入帐号，密码，验证码三条信息之后才可以登录成功，而在后台对于程序来说，首先会根据你输入的位置，取得你输入的帐号，密码，验证码，然后再与数据库存贮的个人信息比对，如果相符则登录成功，这个子程序就具有了过程上的内聚性。<br />
*逻辑上的内聚性：<br />
这个内聚性主要是致一个子程序有很多操作，根据传入的参数不同结果有所不同，例如某个子程序的功能是输入学生的考试成绩，成绩>=90，输出成绩优秀，如果>=80，输出成绩良好，如果>=70，输出成绩中等，如果>=60，输出成绩及格，否则输出不及格，具体如下：<br />
 void outputgrades（ int score ）{
 char * s[]={"excellent","fine","medium","fail"}
 if( score >= 90 )
 return s[0]；
 else if( score>=80 )
 return s[1]；
 else if( score>=60 )
 return s[2];
 else 
 return s[3];
 }
这个程序操作很多，他最大的特点是操作都在if else语句中，但是结果只能有一个，这个就具有逻辑上的内聚性。<br />
====使用子程序参数的问题(C6516刘炯20160811)====
*参数的顺序
对于子程序的参数来说，严格的顺序应该是输入-修改-输出这样排列参数，好处就是便于阅读和理解，这样的顺序也是子程序内部操作发生的顺序的顺序，举一个例子说明：
 void Strcpy(char* Dest, const char *Src)
 {
     assert((Dest!= NULL)&&(Src!=NULL));
     while((*Dest = *Src)!='\0')
     {
         Dest++;
         Src++;
     }
 }
这个程序的目的是将第一个参数的字符串拷贝到第二个参数，对于这个程序而言，参数的顺序是不可以改变的，而且也是按照执行的顺序排列的。
*参数的使用
正常来说，只要写到子程序的参数都是要在程序操作中使用的，如果不使用就不应该书写，这样的目的是为了降低程序执行的错误率，但如果有很好的理由，可以继续留着，对于一些状态和出错变量应该放在最后一个参数上，因为主要是用来输出的，是一种潜规则，例如有还是上面的Strcpy 函数，加上一个需求，如果参数是空，我就报错退出，可以改为一下
 define error NG 
 void Strcpy(char* Dest, const char *Src,char error)
 {
     if( (Dest!= NULL)&&(Src!=NULL) )
         while((*Dest = *Src)!='\0')
        {
             Dest++;
             Src++;
         }
      else 
      cout<<error<<endl;     
 }
*检查参数的类型
在使用参数的时候，如果是数字类型的，应该也别考虑参数的类型，比如
'''''错误示例'''''
 void gethalf ( int a )
 {
     a = a/2;
     return a;
 }
对于上面这个程序而言，没有考虑到函数的执行目的，执行结果有可能是浮点型，导致结果不准确,输入参数和输出参数相同，对于数据型来书容易出错
'''''正确示例'''''
 void gethalf ( int a，double b )  // 为了结果的准确性，就牺牲一下空间了
 {
     b = a/2;
     return b;
 }

====7.3-7.4（陶晓鸣）====
====7.3子程序的名字的心得（陶晓鸣）====
子程序的命名一般遵循以下几个原则:
▪可以表示子程序的功能<br />
▪不使用表意不清的动词<br />
  例如DealWithOutPut()，根本不能直接告诉别人这个子程序是用来处理怎样一个业务的。<br />
▪不简单的通过sum1、sum2、sum3、等数字来命名子程序<br />
  一个project会有很多的子程序都以数字命名，会使得工程乱的一塌糊涂，其结果就是对开发，维护人员造成很大的困扰。<br />
▪子程序的名字长度要适中<br />
▪函数的命名要对其返回值有说明<br />
  customerId.Next(),studentId.total(),都可以很明确的表明函数的输出结果。<br />
▪子程序表示一个过程，子程序名应当要给定相应的宾语<br />
  很简单的一个例子，PrinterDocument(),对象宾语Document，动作Printer。<br />
▪起名要相互对仗<br />
	add/remove<br />
	open/close<br />
	min/max<br />
	first/last<br />
▪遵循项目给定的命名原则<br />
	这个在我们实际的项目中经常会遇到，每个项目都会有自己的一套命名规则，遵循这个命名规则，可以使各个class之间的联系更加显而易见。<br />
====7.4子程序的长度问题（陶晓鸣）====
最佳的子程序的长度<br />
通过研究表明100至200行的有序代码是最佳的子程序长度。不同的项目考虑到不同子程序的内聚性、嵌套的层次、变量的数量、注释的多少以及一些跟复杂度相关的考虑事项，每个子程序的长短会有所不同。但是国外多项研究表明了，太短的代码，每行代码的成本会比最佳长度代码的每行成本高；太长的代码每行代码所含的错误会比最佳长度代码多，并且100至200行的代码的修改率是最低的。<br />
所以我们在开发的过程中一定要注意每个子程序代码的长度，以达到成本最低化，代码最优化，错误最低化。

====7.5-7.7（董飞）====
====7.5 如何使用子程序参数 （董飞）====
*不要把子程序的参数用作工作变量
*'''坏代码'''
<pre> 
int Sample (int inputVal){
      inputVal = inputVal * CurrentMultiplier ( inputVal );
      return inputVal;     //此处的inputVal已经不再是当初传入的值了
}
</pre>
*'''好代码'''
<pre>
int Sample (int inputVal){
      int workingVal = inputVal;  //引入新的变量workingVal，消除了误用inputVal的可能  
      workingVal = workingVal * CurrentMultiplier ( workingVal );
      ...           //在此处或者其他地方还可以使用inputVal最初传入的值
      return workingVal;
}
</pre>
*子程序的参数按照一定的规则命名
如果你觉得把输入，修改，输出参数区分开很重要的话，那么就建立一种命名规则来对他们
进行区分。可以为这给这些参数的名字加上Input_，Modify_，或Output_来当前缀。
*在接口中对参数的假定进行注释说明
如果你假定了传递给子程序的参数具有某种特性，那么就要对这种假定加以说明。<br/>
应该对这些接口参数的假定进行说明：
#参数要被仅用于输入的、要被修改的、还是仅用于输出的；
#表示数量的参数的单位（如：千米、米、厘米）；
#状态代码和错误值的含义； 
#所能接受的数值的范围；
#不该出现的特定数值；
*按照输入-修改-输出的顺序排列参数
不要随机的排列参数，应该先把仅作为输入的参数列出，然后是既作为输入又作为输出的参数，最后是仅作为输出的参数。这种排列方法暗示了子程序的内部操作所发生的顺序，先是输入数据，然后修改数据，最后是输出结果。
*把状态或出错变量放在最后
按照习惯做法，状态变量和那些用于指示发生错误的变量应该放在参数表的最后它们只是附属于程序的主要功能，而且他们是仅用于输出的参数。
*把子程序的参数个数限制在7个以内
对于通常人来说，我们很难记住7个以上单位的信息。所以说为了避免混淆，我们应该把参数的个数控制在7个以内。如果你发现自己一直需要传递很多参数，这就说明子程序之间的耦合太过紧密了。那么你就应该重新设计子程序，降低其间的耦合度。
====7.6使用函数时要特别考虑的问题（董飞）====
*不要反回指向局部数据的引用或指针
当子程序执行结束，其局部数据流都出了作用域，那么任何指向局部数据的引用或指针也随之失效。如果一个对象需要返回有关其内部数据的信息，那就应该把这些信息保存为类的数据成员
*检查函数所有可能的返回路径
在编写函数时，先在脑海中执行每一条执行路径。确保在所有可能的情况下该函数都会返回值。最好在函数开头用一个默认值来初始化返回值。
====7.7宏子程序和内联子程序（董飞）====
*把宏表达式整个包含在括号内
*'''不能正确展开的宏'''
<pre>
#defin Cube(a) {a}*{a}*{a}   //如果在使用Cube()的表达式里含有比乘法运算符优先级更高的运算符，那么{a}*{a}*{a}就会失效
</pre>
*'''可以正确展开的宏'''
<pre>
#defin Cube(a) {{a}*{a}*{a}}
</pre>
*把含有多条语句的宏用大括号括起来
一个宏可以含有多条语句，如果你把它只当做一条语句就会出错，因为它和常规函数的执行方式是不同的。当使用for循环调用宏的时候，如果宏里的语句没有用大括号括起来，for循环只会调用宏的第一条语句。
*'''无法工作含有多条语句的宏'''
<pre>
#define LookupEntry(key,index)
  index = (key-10)/5;
  index = min(index,MAX_INDEX);
  index = max(index,MIN_INDEX);
  ...
for(entryCount = 0;entryCount<numEntries;entryCount++)
  LookupEntry(entryCount，tableIndex[entryCount]);
</pre>
在上面的代码中，for循环语句中只有宏的第一部分代码被执行。即“index = (key-10)/5；”被执行。
*'''可以工作含有多条语句的宏'''
<pre>
#define LookupEntry(key,index){
  index = (key-10)/5;
  index = min(index,MAX_INDEX);
  index = max(index,MIN_INDEX);
}
 ...
for(entryCount = 0;entryCount<numEntries;entryCount++)
  LookupEntry(entryCount，tableIndex[entryCount]);
</pre>
*用给子程序命名的方法给宏命名
C++语言中给宏命名的方式是全部使用大写字母。如果当我们遇到能用子程序来代替宏的时候，那么给宏命名的时候我们就应该采用给子程序命名的规则。这样当你想用子程序代替宏的时候，除了需要修改相关的子程序外，其他的不需要改动。
*建类时要提供成对的方法
如果我们创建了一个向表中插入数据的方法，那么很可能也需要一个删除表中数据的方法。所以当建类的时候要检查每一个公用子程序，然后决定是否需要提供与其相反的操作。也不要盲目的去创建相反的操作，应该看看你是否真的需要它。
*'''例子'''
<pre>
public class Man{
  private String name;
  public void setName(String name) {
    this.name = name;
}
  public void getName(String name) {
    return name;
}
}
</pre>
*不要公开暴露成员数据
我们都知道封装是面向对象的重要原则，并尽可能的隐藏对象内部的细节。如果你不知道某个子程序的可访问性应该设为private,public还是protected那么建议你采用最严格且可执行的访问级别。
*不要建只有一个实例的类
一个类中只有一个实例很有可能是你把类和对象混淆了，这时你应该重新建一个对象而不是重新建一个类。
=== 第8章 防御式编程（戎祥 何茂森 李婷婷）===
====8.1-8.3（戎祥）====
====检查所有来源于外部数据的值心得====
对于JAVA中传值我想对于有点JAVA基础的人都会知道的，因此我们在大学时候传值通常都是这样的：
 void method1()

 {int x=0;this.change(x);
 System.out.println(x);
 }

 void change(int i)
 {
 i=1;
 }

可能在那时候我们会觉得这毫无问题，但是现在我们进入工作接触到业务了，那么我们在传参的时候就不能这么不小心了

比如说，我们程序中定义了一个字段，写数据库的时候规定它的大小位10位数，这时候我们在接下来的开发中我们就得小心了

不能传入大于十位的，或者说传入了不属于它类型的参数，因此这些都是我们今后在调用某个方法或者传参是必须要注意的。

--------------------------------------------------------------------------------------------------------
====决定如何处理错误的输入心得====
记得以前看过一本《JAVA编程思想》它里面讲了JAVA的基本理念就是“结构不佳的代码不能运行”，

我们发现错误的思想或者错误的时机是在编译阶段，也就是在你试图运行之前。但是我们在编译的时候

并不是能找出所有的错误的，所以余下的问题要在代码里解决，比如我们常遇到的try和catch

 try{



 }catch(){

 }
但是我刚才所说的往往我们心里想的是这些都是可有可无的，写不写无所谓，但是如果我以后写的时候

再不注意这个细节我觉得我迟早会遇到麻烦的，所以养成加保险的习惯一定会对我们有所帮助的，切记切记

--------------------------------------------------------------------------------------------------------
====断言心得====
断言我以前没怎么听说过，刚才我看了一下，大致的了解了一下，它是一个检测代码，通常是一个子程序或宏，

感觉挺有意思的，比如说客户要求该工程文件记录数不能超过50000，那么程序中可以包含一个断点记录小于50000

的断言

 assert denominator !0 : "denominator is unexpectedly equal to 0.“

上述断言声明denominator 不会等于0.其中第一个参数，denominator ！=0，是个布尔表达式，其结果为true或者false

第二个参数是当第一个参数为false的时候，即断言为假的时候要打印消息


====断言的心得====
断言在使用的时候所需要注意的有以下几点

*用错误处理代码赖处理预期会发生的情况，用断言处理绝不应该发生的情况

*避免把需要执行的代码放到断言中，例如：

*'''''坏代码'''''

<pre>
Debug.Assert(PerformAction() ) ' Couldn't perform action
</pre>

*'''''好代码'''''

<pre>
actionPerformed = PerformAction()

Debug.Assert(actionPerformed) ' Couldn't perform action
</pre>

----------------------------------------------------------------------------------------------------------
====错误处理技术的心得====

上诉断言是用来处理代码中不应该发生的错误，而下列的方法是用来处理预料中可能要发生的错误：

*返回中立值

*换用下一个正确的数据

*返回与前次相同的数据

*还用最接近的合法值

*返回一个错误码
-------------------------------------------------------------------------------------------
====6.1抽象数据类型（戎祥）====
====抽象数据类型的心得====
首先官方一点解释一下：<br/>
是指一些数据以及对这些数据所进行的操作的集合。我想这么解释大家可能有点蒙圈。<br/>
还记得大学时候老师解释了什么叫做抽象：<br/>
比如你的领导让你去买烟，只是说了句买烟，剩下的全交给你，那么领导的这句话就叫做抽象<br/>
底下的要做的事比如什么牌子的烟，哪里产的，什么规格的这些都靠你自己去定义那么这个过程就叫做抽象的实现<br/>
抽象有点类似与Java中的接口，接口与抽象的方便性我相信大家有目共睹的<br/>
写个简单的抽象类的例子<br/>
*'''''抽象类原代码'''''
 abstract class Instrument{
 private int i;
 public abstract void play(Note n);
 }
*'''''实现类原代码'''''
 class Wind extends Instrument {
 public void play(Note n) {
 print{"Wind.play()" +n};
 }
与之相似但又不似的便是接口了他们之间虽然功能都是差不多的，但是要求却不同:<br/>
====接口与实现类的差别====
*从语法定义层面看abstract class 和 interface<br/> 
*abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。<br/> 
*接口中的方法默认都是 public,abstract 类型的。<br/>
*接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值<br/>
====6.2良好的封装心得（C6518 戎祥）====
封装是一个比抽象更强的概念，我的理解是：抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度<br/>
而封装则强制阻止你看到细节——即便你想这么做。<br/>
那封装有哪些好处呢：<br>
*尽可能地限制类和成员的可访问性
*不要公开暴露成员数据（举个例子）
*'''''坏代码'''''
 int x;
 int y;
 int z;
*'''''好代码'''''
 int Getx();
 int Gety();
 int Getz();
 void Setx(int x);
 void Sety(int y);
 void Setz(int z);

上诉中坏代码他就破坏了封装性<br/>
*避免把私用的实现细节放入类的接口中
----------------------------------------------------------------------------------------------------------------
====应该避免的类心得（C6518 戎祥）====
建类我想对于大家来说都是非常简单的一件事，但是建一个好类一个又实用的类你却知道多少呢，所以我整理了一下<br/>
*避免创建万能的类
如果一个类把功夫都花在用get,set方法上向其它索要数据的话，请考虑是否应该把这些功能阻止到其它类中去<br/>
*消除无关紧要的类
要是一个类只含有数据没有其它行为的话，你也得考虑是否值得建一个类。<br/>
*避免用动词命名的类
--------------------------------------------------------------------------------------------------------------------
====创建子程序的心得（C6518 戎祥）====
下面列出了一些创建子程序的正当理由：<br/>
*降低复杂度(直接调用该子程序无需了解内部细节)
*引入中间，易懂的抽象
'''''坏代码'''''
 if(node<>NULL)then
  while(node.next<>NULL)do
   node = node.next
   leafName = node.name
  end while
 else
  leafName = ""
'''''好代码'''''
 leafName = GetLeafName( node )
*避免代码重复（把相同的部分提取出来，放入一个基类）
-----------------------------------------------------------------------------------------------------------------
====如何使用子程序参数（C6518 戎祥）====
我挑个Java的例子看了一下,就是不要把子程序的参数用做工作变量<br/>
'''''坏代码'''''
 int Test(int inputVal){
    inputVal = inputVal*CurrentMultiplier(inputVal)
    inputVal = inputVal+CurrentMultiplier(inputVal )
    ...
    return inputVal ;
 }

'''''好代码'''''
 int Test(int inputVal){
    int workingVal = inputVal 
    workingVal = inputVal*CurrentMultiplier(workingVal )
    workingVal = inputVal+CurrentMultiplier(workingVal )
    ...
    return workingVal ;
 }
引入 workingVal 这个变量便很好的区分了inputVal 这个变量，避免错误时间错误调用<br/>
----------------------------------------------------------------------------------------------------------
====使用函数时需要考虑的问题心得（C6518 戎祥）====
*什么时候使用函数
如果一个子程序的主要用途就是返回其名字所指的返回值那么就使用函数<br/>
*设置函数的返回值
在coding的时候一定要清楚自己写这个函数的目的，一定要在自己脑海里走一遍，确保在所有可能情况下都是这个返回值<br/>
------------------------------------------------------------------------------------------------------------------
===使用变量的一般事项（C6518 戎祥）===
====10.2轻松掌握变量定义====
*隐式声明
**VB语言就可以支持隐式变量声明。当你在VB中使用一个未声明的变量的时候，编译器会自动为你声明变量。
**隐式声明可谓优缺参半，缺点在于当你想要明白某个变量的值为什么不正确的时候会很麻烦，因为你VB没有像JAVA一样对变量会预先声明。
**以下建议处理隐式声明的问题：
***关闭隐式声明（通过编译器关闭）
***声明全部的变量（主动声明变量）
***遵循某种命名规则（Num，No避免这样的变量）
***检查变量名（通过第三方工具生成的交叉引用列表）
-----------------------------------------------------------------------------------------------------------------
====10.3变量初始化原则====
*掌握一些能避免出现变量初始化问题的方法
**不恰当的变量初始化一般都是源于变量的默认初始值与你的预期不同，避免以下行为：
***从未对变量赋值
***变量的值已经过期，该变量在某个地方曾经被赋过值，但是该值已经不再有效
***变量一部分被赋值，而另一部分没有赋值。
**下面是处理方案：
***在申明变量的时候初始化
***在靠近变量第一次使用的位置初始化它
***在可能的情况下使用final或者const（java里可以申明为final）
***在类的构造函数里初始化该类的数据成员（如子程序的变量应该在每一个子程序内部初始化）
***检查输入参数的合法性
***理想情况下，在靠近第一次使用变量的位置申明和定义该变量，举个java例子：
****好的例子
 int accountIndex = 0;  //code using accountIndex
 ...
 doubule total =0.0;   //total在靠近首次使用的地方被申明和初始化
 ...
 boolean done - false;  //done也在靠近首次使用的地方声明和初始化
 ...
-----------------------------------------------------------------------------------------------------------------
====10.4作用域====
*Java中是这么解释的，作用域决定了在其内定义的变量名的可见性和声明周期，有点官方，举个例子：
**java例子：
 {
  int x =12;
   {
    int q = 96;
   }
 }   //x和q它们的作用域仅在它们定义时的大括号范围里
*尽可能缩短变量的存活时间
**存活时间是指一个变量存在期间所跨越语句的总数。
***测量变量的生存时间java例子：'
 1 recoderdIndex = 0;
 2 total = 0;
 3 done = false;
   ...
 26 while (recordIndex < recordCount) {
 27...
 28  recordIndex = recordIndex+1;
     ...
 64 while(!done){
    ...
 69 if(total>projectedTotal) {
 70    done = true;
                             }  
 下面是正确的例子
 25 recordIndex = 0;
 26 while (recordIndex < recordCount) {
 27 ...
 28 recordIndex = recordIndex+1;

 62 total = 0;
 63 done = false;
 64 while(!done){
       ...
 69 if(total>projectedTotal) {
 70  done = true;
                             }

----------------------------------------------------------------------------------------------------------------
====10.5 持续性====
*持续性是对一项数据的生命周期的另一种描述，持续性具有多种形态：
**特定代码或子程序的生命周期（例如java中的for循环）
**只要你允许它就会持续下去（Java中只要你new一个变量就会一直持续到它成为垃圾被回收）
**程序的生命周期（Java中的static变量）
**永远持续（例如用户属性的变量就可以单独定义到一个类中，需要用的时候再调用）
*避免上述问题的措施：
**在程序中加入调试代码。如果变量取值不合理，就会发出警报信息通知你是否有不正确的初始化
**例如C中你删除一个个指针后再把他的值设为null
**养成在使用所有数据之前声明和初始化的习惯（要特别小心某项数据的使用位置与初始化位置相去甚远）
---------------------------------------------------------------------------------------------------------------
====10.6 绑定时间====
*把变量和它的值绑定在一起的时间
**通常采用晚的绑定时间会越有利，你把你的时间定义的越晚，你的代码里就包含了越多的灵活性，举个例子：
 titleBar,color = 0xFF;   //0xFF是蓝色的十六进制的值
 下面这个例子是时间稍微靠后的例子：
 private static final int COLOR_BLUE = 0xFF;
 private static final int TITLE_BAR_COLOR = 0xFF;
 ...
 titleBar.color = TITLE_BAR_COLOR ;
 最后一个例子是晚期绑定的例子
 titleBar.color = ReadTitleBarColor(); //ReadTitleBarColor()是一个能在程序运行期间读入数值的子程序。
*对变量数值相绑定时间的总结：
**编码时（使用神秘数值）
**编译时（使用具名常量）
**加载时（Java属性文件等外部数据源中读取数据）
**对象实例化时（每次窗体创建的时候读取数据）
**即时（每次重绘的时候读取数据）
------------------------------------------------------------------------------------------------------------------
====10,7 数据类型和控制结构之间的关系====
*数据类型和控制结构关系：
**序列型数据翻译为程序中的顺序语句（序列型数据：一些按照特定顺序使用数据的数据组成。顺序语句：如果你在一行中写有五条语句，每条语句都负责处理一想不同的数据）
**选择型数据翻译为程序中的if和case语句
**迭代型数据翻译成程序中的for,repeat,while等循环结构

====8.4-8.5（李婷婷）====
----
====8.4 异常（工号C6519 何茂森）====
*异常简介
异常是把代码中的错误或者发生的异常事件传递给调用异常的方法的一种特殊的手段

*异常的用途
异常的用途主要是通知程序的其他部分，发生了某些不可忽视的错误

*使用异常的注意点

::避免使用空的catch语句。

<pre>
java反例：
try{
   ...
   //很多的代码
   ...
}catch(AnException exception){
}
</pre>
空的异常语句只能说明要么是try里面的内容不对，无故抛出了异常，要么是catch里的代码不对，不能有效的处理异常，应该做类似下面的修改：
<pre>
java正例：
try{
   ...
   //很多的代码
   ...
}catch(AnException exception){
   LogError("Unexpected exception");
}
</pre>
当然，上述的catch语句里面也只是简单的进行了一个错误日志的打印，没有深层次的去处理异常，仍然有待改善。

::避免在构造函数里抛出异常

在构造函数里面抛出异常会使异常的处理变得很复杂，有时候会造成资源的泄露。

::在恰当的层次抛出异常

对于抛出的异常，其实可以将其看作是程序接口的一部分，和其他的数据类型一样进行处理，但是如果异常的层次和子程序接口的程序不一致的话，会破坏程序的封装性，也使程序变得更加难以管理。
例如下面这段java异常的代码：
<pre>
java反例：
class Employee{
    	...
    	public TaxId GetTaxId() throws EOFException{
		...
	}
	...
}
</pre>
上面的这段抛出异常的程序里面，EOFException异常是结束文件的异常，其抽象层次比较低，这种时候，子程序的调用方就不与Employee耦合，而是与抛出EOFException异常的代码相耦合，应做如下修改：
<pre>
java正例：
class Employee{
    	...
    	public TaxId GetTaxId() throws EmployeeDataNotAvailable{
		...
	}
	...
}
</pre>
上述EmployeeDataNotAvailable异常是与Employee相一致的异常，这样的程序才更加容易管理，也有更好的封装性

::异常中应该加入有关异常发生的信息

加入异常发生的信息能够帮助开发人员了解这个异常，并找出相关的对策，避免异常的发生 。

::确保异常处理的一致性

有一种方法可以确保异常处理的一致性，那就是创建一个集中的异常报告机制。例如：
<pre>
public class TestException {
    TestException(int i) throws ExceptionA,ExceptionB,ExceptionC{
        switch(i)
        {
        case 1 : throw new ExceptionA();
        case 2 : throw new ExceptionB();
        case 3 : throw new ExceptionC();
        default : {int a[]={0,}; a[1]=1;};
        }
     }
 }
class ExceptionA extends Exception{};
class ExceptionB extends Exception{};
class ExceptionC extends Exception{};
</pre>
上述代码中，将ExceptionA/ExceptionB/ExceptionC集中到一起进行处理，这就是一个很好的集中处理的例子。
这个机制为与异常有关的信息如异常的种类/每个异常该如何被处理等信息提供一个集中的存储，能够很好的保证异常的一致性。

::把项目中对异常的处理标准化
标准化的异常处理将有利于异常的管理，针对异常处理的标准化，可以在以下几个方面进行考虑：
#考虑创建针对项目的特定异常类来作为本项目中所有可能抛出的异常的基类，这样就能是其他的异常集中起来标准化
#规定在何种场合下允许代码使用throw-catch语句进行局部处理
#规定在何种场合下允许代码抛出不在局部进行处理的异常
#确定是否使用集中的异常报告机制
#规定是否允许在构造函数中使用异常

::考虑异常的替换方案

针对某些异常，其影响程度并不是很高，此时可以考虑使用其他的处理方法来代替此异常，比如重新建立一个类来处理此处发生的错误，此处可参考本章前面的8.3节《错误处理技术》。

----
====8.6 辅助调试代码（工号C6519 何茂森）====
*尽早引入辅助调试的代码。
在程序开发的前期，越早引入辅助调试的代码，其能够提供的帮助也就越大。
*计划移除调试辅助的代码。
例如C++的开发环境中，使用预处理器来控制调试用的代码：
<pre>
#define DEBUG
...
#if defined(DEBUG)
// 调试代码
...
#end if
</pre>
*编写自己的预处理器。
如果某种语言没有包含一个预处理器，可以自己去写一个用于包含或排除调试代码的预处理器。例如JAVA里可以写一个预编译器来处理//#BEGIN DEBUG和//#END DEBUG等关键字
----

====8.7确定在产品代码中该保留多少防御式代码心得（工号C6519 何茂森）====
*保留检查重要错误的代码
重要的错误往往会引发软件的重大事故，需要重点关注，对于这部分错误需要着着重关注，此部分检查错误的代码也应保留下来一应对后续出现的问题。

*去掉检查细微错误的代码
某些错误可能对整个软件几乎没有影响，或者是影响微乎其微，对于这种错误的检查代码可以不用保留在工程内部，以减少工程代码的冗余。

*去掉可能导致程序硬性崩溃的代码
程序开发阶段可以允许有错误，也可以允许有引起程序硬性崩溃的代码，但是当程序走向产品的时候，不允许有这样的代码出现，必须将其移除程序之内。

*保留可以让程序稳妥崩溃的代码
如果你的程序里有能够检测出潜在严重错误的代码，那么可以保留某些可以让程序稳妥崩溃的代码，这些代码在程序的后期能够给开发者提供某些关键信息，以改善程序，使得后续的程序可以获得更高的质量。
*为技术支持人员纪录错误信息
可以考虑在产品代码中保留一些辅助调试代码，这些代码能够帮助技术人员纪录错误信息，使最终产品有更好的质量。
----
====8.8对防御式编程采取防御的姿态心得（工号C6519 何茂森）====
*不可过度的采取防御式编程
如果在每个能想到的地方都采取防御式编程的话，会使程序变得臃肿而缓慢，也增加了软件的复杂度，因此需要因地制宜地调整防御式编程的优先级。
*防御式编程核对表
针对不同的防御式编程，可参照P211页的防御式编程核对表（cc2e.com/0868），根据该表区分一般事宜/异常/安全事宜，并以此来调整辅助代码的数量
*防御式编程的优点
防御式编程可以让错误更容易被发现，更容易修改，减少错误对产品代码的破坏，同时也能在一定程度上保证程序的稳定性。
----