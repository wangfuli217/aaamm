=== 参加人员 ===
邵志超  王西亚  徐超  段宗超  闫玲玲  徐钰颖  范子高  肖秀丽  葛川川  钟红飞  李勇  甘建伟  宋文喆

=== 第10章 使用变量的一般事项（葛川川 徐超 宋文喆 肖秀丽）===
====10.1数据认知（葛川川）====
=====积累数据类型的必要性=====
*1数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。
*2如果知道变量确实总是存储特定类型的数据，声明了这种特定类型的变量，以更高的效率处理这个数据。例如，存储人名的变量最好表示成 String 数据类型，因为名字总是由字符组成。
充分利用内存并提高处理效率
====10.1数据认知心得（宋文喆）====
=====能提高安全性的数据变量=====
*1我们常用的private和static，private只有在定义类的时候才能在类中引用，其他类不能直接访问，而static修饰的对象数据在全局是唯一的，一改都改。所以在实际开发中可以活用这些变量来提高代码的安全性。
*2以下有个static容易出错的例子：
   static int a;
   public static void main (String[]args){
   static int a;
   System.out.println(a);
   }
这里把a设为了全局变量，在main()函数中 static int a;然后调用时，a对象的内存空间已存在了，所以就会在这报错，staic 作用是共享同一块内存空间。
====10.2轻松掌握变量定义（葛川川）====
=====使隐式声明不出错=====
隐式声明:当你使用一个未声明的变量的时候，编译器会自动为你声明该变量（1取决于你的编译器设置2编程语言支持隐式声明）
*1关闭隐式声明
*2声明全部变量
*3遵循某种命名规则
*4检查变量名
====10.2轻松掌握变量定义（宋文喆）====
*隐式声明容易出错，尽量少使用
*'''''例子'''''
   window. y = "hello"; 
   function test(){ 
   y = "OH, NO!!!"; //隐式声明使变量变成了全局变量
   } 
   test(); 
   alert(window.y); //输出的"OH, NO!!!"而不是想要的"hello"
*尽量使用显示声明以及合理的命名规范，能够增强代码的可读性


====10.2轻松掌握变量定义心得（李勇）====
*隐式变量声明是个危险的特性之一，那么避免该现象的发生，可关闭隐式声明，即强迫在使用前先做出声明。
*要声明全部的变量，可以预防一些错误。
*遵循建立有规则的命名，并检查变量名。有助于你声明了的但还没使用的变量。

====10.3变量初始化原则心得（邵志超）====
*变量初始化原则的详细说明：变量的初始化在之后的逻辑代码中有关数据的操作时起着很关键的作用，一般的代码编写时都是在定义声明变量的同时赋予其初始值：如下列举的几种类型变量的初始化；
    String s={"a","abc"," ","实践"}; 
    int[]a={1,23,42};
    （double）float b=3.14d;//有可能在某些工具中默认是double类型的精度要求
  //code using s,a,b....
理想情况下是：声明初始化的变量最好是满足就近原则（java代码为例）
*也存在关键字 final ，static，所修饰的常量，这种类型的变量的初始化一般是某些公有固定属性或是成员的固定私有属性的定义。
*具名常量的初始化 
const blue =3;
const red =4;
Type prefix
be (blue) as String;
rd (red) as int ;
End Type
将对应的变量值赋予别名，在之后的方法中调用时可以根据别名找到对应的变量值，更改变量值时也很方便，只需要在定义时修改对应要求的数值即可。

====10.3变量初始化原则（甘建伟）====
*在声明变量的时候进行初始化：可以很好的防止变量初始化错误的问题。
 int listIndex = 1; //初始化listIndex值为‘1’；若为初始化则系统初始化默认值‘0’；
 boolear flag = true;//boolean类型默认初始值为false，引用类型默认初始值为null；
*在靠近变量第一次使用的位置定义该变量。
 int a = 0;
 int b = 1;//对‘a’和‘b’进行定义
 a = a + b;//使用到了‘a’和‘b’；
*对计数器和累加器要记得重置其值。
'''''坏代码'''''
 int i = 0;
 for(int j = 10;i < j;i++);
 for(int z= 5;i < z;z--){
  System.out.println(z);
 }
'''''可行代码'''''
 int i = 0;
 for(int j = 10;i < j;i++);
 i = 0;
 for(int z= 5;i < z;z--){
  System.out.println(z);
 }

====10.3变量初始化原则心得（宋文喆）====
=====初始化变量应养成的习惯=====
*1在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。（何桑举过的例子，可以减少内存的使用）
*2直到变量即将被使用时再为其赋值。
*3把相关语句放在一起。
*4把相关语句组提取成单独的子程序。
*'''''坏代码'''''
   int a = 0;
   double b = 0;
   boolean c = false;
   // other code 
   // code using a
   ...
   // code using b
   ...
   // code using c
   ...      //此时c有可能已经被修改了
   while(!c)   
   ...
*'''''好代码'''''
   int a = 0; 
   // code using a
   ...
   double b= 0;
   // code using b
   ...
   boolean c= false;
   // code using c
   while (!c)
   ...         //符合就近原则的初始化

====10.4 作用域（徐超）====

=====变量引用局部化的好处=====
*衡量变量不同的引用点的靠近程度的一个概念是“跨度”
'''''java示例：'''''

 a = 0;
 b = 0;
 c = 0;
 a = b + c;

在上例中，对a的第一次引用和第二次引用之间存在两行代码，因此a的跨度是2；以此类推，b的跨度是1，c的跨度是0。当变量集中在一起时，使得代码阅读者每次只关注一部分代码；反之当变量的距离比较远，就要来回翻阅，如果在其中有新代码加入，很容易使阅读代码的人忘记了该变量的值。
所以把变量引用点集中起来主要好处就是提高了程序的可读性。

=====缩短变量“存活”时间的好处=====
*减小攻击窗口
存活时间是指一个变量存在期间所跨越的语句总数，开始于引用该变量的第一条语句，结束于引用其的最后一条语句。保持变量短的存活时间的好处是减小攻击窗口，当你修改一个变量位置之间的区域，该变量发生错误的可能性大大降低。

*减少初始化错误
修改程序时，经常会把直线型代码改为循环，这时把初始化的代码和循环部分放在一起，可以减少因修改代码而导致初始化错误的可能性。

*降低代码的理解难度
假设一个变量在第1行被赋值，到第50行才再次引用，那么该变量在第1-45行范围内一直被使用；如果该变量在第1行被赋值后，第2行就引用了，那么在关注这个变量时，只需关注很少的一部分代码，阅读者也更容易理解代码。

*易拆分
当变量的多次引用靠的非常近，那么把相关代码拆分重构成子程序时，难度大大降低。

=====减小作用域的做法=====
*在循环开始前就对变量进行初始化
这种做法的好处是，在你修改循环时，会很容易记住要对循环的初始化代码进行修改，并且当需要在循环之外再加一层循环时，这样的初始化对循环的每一个执行都是有效的。

*在变量即将使用时为其赋值
这种做法的好处是，很方便就找出这个变量的赋值处。
 C++良好示例：良好的变量声明与初始化
 int receiptIndex = 0;
 float dailyReceipts = TodaysReceipts();
 double totalReceipts = TotalReceipts( dailyReceipts );

*相关的语句集中到一起
这样做的好处是，更容易方便的寻找它们。
 C++坏例子：使用两套变量——让人困惑的做法
 void SummarizeData( ... ) {
  ...
  GetOldData( oldData, &numOldData );
  GetNewData( newData, &numNewData );
  totalOldData = Sum( oldData, numOldData );
  totalNewData = Sum( newData, numNewData );
  PrintOldDataSummary( oldData, totalOldData, numOldData );
  PrintNewDataSummary( newData, totalNewData, numNewData );
  SavaOldDataSummary( totalOldData, numOldData );
  SavaNewDataSummary( totalNewData, numNewData );
 }
在上例中，需同时关注6个变量。

 C++好例子：使用两套变量——更容易理解的做法
  void SummarizeData( ... ) {
  GetOldData( oldData, &numOldData );
  totalOldData = Sum( oldData, numOldData );
  PrintOldDataSummary( oldData, totalOldData, numOldData);
  SaveOldDataSummary( totalOldData, numOldData );
  ...
  GetNewData( newData, &numNewData );
  totalNewData = Sum( newData, numNewData );
  PrintNewDataSummary( newData, totalNewData, numNewData);
  SaveNewDataSummary( totalNewData, numNewData ); 
  ...
 }
这段代码就更容易理解。

*相关语句拆分、提取组成成单独的子程序
其他条件相同，一个较短子程序中的变量通常比较长子程序中变量的跨度和存活时间要短，那么把一组相关语句拆分组成小的子程序，自然作用域也会缩小。

*变量的作用域由小变大
减少作用域的方法之一就是尽量将变量局部化。但是与扩充变量的作用域相比，减少变量的作用域是非常困难的。所以在一开始考虑变量的作用域时，先将其局限于某个特定循环，然后是某个子程序，其次成为某个类的private变量，protected变量，再其次对package可见，最后才是全局变量。

====10.5 持续性（徐超）====

=====持续性的多种形态=====

*特定代码段或子程序的生命周期
:;例：某一个for循环中声明的变量

*只要你允许，它就会持续下去
:;例：Java中，用new创建的变量会持续到被垃圾站回收

*程序的生命周期
:;例：大多数的全局变量

*永远持续
:;例：储存在数据库中，程序多次执行后仍然存在的数据

=====持续性的相关问题=====

变量的生命周期具有难以预料性，有时候变量过期，但有时候又会有旧的值存在变量中。解决上述问题，有如下好的做法：
*程序中加入调试代码或断言
:这样如果变量取值不合理，就会发出警告信息。

*准备抛弃变量时给它们赋“不合理的数值”
:例：在删除指针后，可以给它赋值为null。

*编写代码时要假设数据不具有持续性
:例：某个变量在你退出子程序时具有某个特定值，那当你下次进入该子程序时，就不要假定该变量仍具有该值。该例不适用于某些语言中确保变量在子程序多次调用间维持其值的特性，例如C++和Java中的static。

*在使用数据之前给予其声明和初始化
:当发现某项数据与初始化位置相距较远，就需要格外注意该数据。


====10.5持续性（葛川川）====
=====避免数据持续性出错=====
*加入调试代码或直接检查关键变量的合理取值，如果变量未合理取值，程序发警告信息告知。
*自己测试，准备抛弃变量时给他赋上不合理的值，判断结果。
*当数据没有持续性，去编写代码。
*使用数据之间声明和初始化。
=====变量的生命周期=====
*坏方法：变量实际生命周期比你想象的要短，访问计算机里保存的旧数据，导致你误认为用对了数据。
*好方法：在程序中加调试代码，判断关键变量的合理性，使用数据前做好声明和初始化。

====10.6绑定时间（葛川川）====
=====降低复杂度并满足软件需求=====
*绑定时间↑ 灵活性↑ 代码复杂度↑ 出错率↑
合理利用具名常量，引入足够的灵活性来满足软件需求，不增加需求范围以外的任何灵活性及相应的复杂度
绑定时间三种如下：
1在编写代码时绑定其值的变量
2在编译时绑定其值的变量
3在运行时绑定其值的变量

====10.6 绑定时间（徐超）====
*绑定时间的定义
**变量与其值绑定在一起的时间
*绑定时间对灵活性和复杂性的影响
**一般情况下，绑定时间越晚，代码的灵活性越高
 绑定时间最早的Java示例：在编写代码时，变量绑定值
 titleBar.color = 0xFF;//0xFF is hex value for color blue

 绑定时间稍后的Java示例：在编译时，变量绑定值
 private static final int COLOR_BLUE = 0xFF;
 private static final int TITLE_BAR_COLOR = COLOR_BLUE;
 ...
 titleBar.color = TITLE_BAR_COLOR;

 绑定时期较晚的Java示例：在运行时，变量绑定值
 titleBar.color = ReadTitleBarColor();

第一个例子中，0xFF是硬编码程序中的值，在编写代码时就会被绑定到变量上。硬编码技术较差，如果要对该值进行修改，那么新值无法与那些必须和它一样的值保持一致；第二个例子中，TITLE_BAR_COLOR是一个具名常量，在编译时，它会被替换为一个数值，它比0xFF反映出的信息要多，可读性强，并且对其一处的改动能对所有位置都生效，同时在运行期，还不会影响性能；第三个例子中，ReadTitleBarColor()能在运行期间读取数值，而且只需通过修改ReadTitleBarColor()子程序读取数据的原内容，就可以改变titleBar.color，该代码可读性与灵活性更强。

*绑定时间越早，复杂性越低，反之复杂性越高
**一般来说，绑定时间越早灵活性越差，但复杂度也会越低；代码灵活性越强，代码也会越复杂，相应的出错几率也会增加。成功软件的开发需要代码的复杂程度降到最低，对程序员也就有相应的要求。一个程序高手，会根据代码需求，相应的来改变代码的灵活性，同时，不会有需求之外的任何操作。


====10.7数据类型和控制结构之间的关系（肖秀丽）====
=====复杂数据类型的简单表述=====
*三类数据（序列型数据、选择型数据、迭代型数据），控制结构（顺序语句、if和case、循环结构）将其变成简单的构造块后，组合起来。

====10.7数据类型和控制结构之间的关系（工号C6428 葛川川）====
数据类型和控制结构之间以一种定义明确的方式相互结合。
*序列型数据翻译为程序中的顺序语句（工号C6428 葛川川）
例如：在一行中写了五条语句，分别处理五项不同的数据，这就是顺序语句。如果要读取数据中的某些数据，程序就会从这些序列型数据中读取一系列语句，顺序读取全部数据，耗时。
*选择型数据翻译为程序中的if和case语句（工号C6428 葛川川）
选择型数据指的是一组数据，这组数据在任一特定时刻有且仅有一项被使用，更快的找到你想要的数据。
*迭代型数据翻译为程序中的if和case、循环结构（工号C6428 葛川川）
迭代型数据是需要反复进行操作的同类型的数据，用再对应数据上更快捷。

了解三类数据（序列型数据、选择型数据、迭代型数据）的特点，将其变成简单的构造块后，组合起来，来高效描述更复杂的数据




====10.8为变量指定单一用途（肖秀丽）====
=====数据，变量规范=====
*每个变量只用于单一用途
 避免让代码具有隐含含义
 确保使用了所以已声明的变量

====10.8 为变量指定单一用途（徐超）====
*每一个变量都只用于一种用途（工号C6374 徐超）
不好的C++示例：一种变量用于两种用途
 //Compute roots of a quadratic equation.
 //This code assumes that (b*b-4*a*c) is positive.
 temp = Sqrt( b*b - 4*a*c );
 root[0] = ( -b + temp ) / ( 2 * a );
 root[1] = ( -b - temp ) / ( 2 * a );
 ...
 //swap the roots
 temp = root[0];
 root[0] = root[1];
 root[1] = temp;

好的C++示例：两个变量用于两种用途
 //Compute roots of a quadratic equation.
 //This code assumes that (b*b-4*a*c) is positive.
 discriminant = Sqrt( b*b - 4*a*c );
 root[0] = ( -b + discriminant ) / ( 2 * a );
 root[1] = ( -b - discriminant ) / ( 2 * a );
 ...
 //swap the roots
 oldRoot = root[0];
 root[0] = root[1];
 root[1] = oldRoot;
第一个例子中，两个位置中用了同一个变量temp，看上去似乎有关联，但实际上一点联系都没有，这种做法增加了阅读者的理解难度；但在第二个例子中，两个位置用了不同的变量，分别对应不同的用途，这就让代码的可读性大大提高。

*不要让代码有隐藏的含义（工号C6374 徐超）
**有些变量具有隐藏的含义，例如：变量pageCount的取值表示纸张的数量，正常情况下它是一个整数；但是当pageCount取值为-1时，它表明有错误发生，整数类型客串了布尔类型的含义。在这种情况下，即使自己对两种用途都很了解，但是别人会不清楚其中含义。
**所以，不要让代码具有隐藏含义，用多个变量来对应多个不同的含义，这样代码就很清楚，也很容易被理解。

*所有已声明的变量，都要确保被使用（工号C6374 徐超）
**有研究表明，已经声明过但没有被使用的变量，它的数量和错误率呈正相关趋势。所以一定要养成一个习惯，那就是检查代码，去确认所有声明过的变量都已经被使用。
**也有一些编译器和工具会有帮助，例如lint，它会对未用到的变量给出警告。

=== 第11章 变量名的力量（段宗超 甘建伟 李勇）===
====11.1选择好变量名的注意事项（段宗超）====
如何建议一个好的变量名
*一个好的变量名是可读的，易记的和恰如其分的。
*为变量命名时最重要的是该名字要完全，准确地描述出该变量所代表的事物。
就如同“当前日期”这一变量，用currentDate或todayDate就比用date要好，我们可以直接读出前两个变量名所表示出来的意思，而date所表示出来的意思不够准确。
*用最适合的名字长度。
太短的变量名无法传递足够的信息，太长的变量名如numberOfPeopleOnTheChinaOlympicTeam，虽然我们可以很明白的读出这个变量名所代表的意思，但是这样的变量名太长不易书写和记录，同时也会使程序的视觉结构变得模糊不清。
====11.1选择好变量名的注意事项（葛川川）====
变量名的选择
*坏方法：x xx xxx 看到这些变量名，无法读。
*好方法：
**为变量指定一些专门名称，不要使用例如 "value", "equals", "data" 这样的变量名
**变量名要使用有意义的名称，通过变量名能大概反映出其具体的用途
**不要在变量名前加 前缀，例如 o_, obj_, m_ 之类
**服从公司命名规范，在命名时使用一致的做法
**服从 编程语言本身的规范，不要使用不连贯的小写和大写混合名称
**不要在同一个类的不同上下文中重用相同的变量名
**不要在一个方法内用同一个变量做不同的用途
**不要使用非 ASCII字符的变量，例如中文变量
**不要使用太长的变量名，例如50个字符，这很难阅读，而且可能超出一些 编译器的限制
**确定并坚持使用固定的一种 自然语言的命名方式，例如不要使用拼音和英文混合的命名方式
**类名使用帕斯卡命名方式，如：VelocityResponseWriter

====11.1 选择好变量名的注意事项（徐超）====
*变量名的好坏对代码阅读性的影响(工号C6374 徐超)
**假设一段代码，基于一个余额和一组新的开销，然后计算出支付总额。来看下面两个例子:
 Java示例：不好的变量名
 x = x - xx;
 xxx = fido + SalesTax( fido );
 x = x + LateFee( x1, x ) + xxx;
 x = x + Interest( x1, x );

 Java示例：良好的变量名
 balance = balance - lastPayment;
 monthlyTotal = newPurchases + SalesTax( newPurchases );
 balance = balance + LateFee( customerID, balance ) + monthlyTotal;
 balance = balance + Interest( customerID, balance );
第一个例子很难看出这段代码要表现的东西，尤其是变量名，根本不知道其代表的含义；相比较而言，第二段代码的变量名就清楚的表达了其含义，使代码的阅读性大大提高。
*变量名一定要准确地表现变量所代表的含义（工号C6374 徐超）
**比较实用的一种方法就是，直接用文字来表达变量所代表的事物。这种名字阅读性强，没有歧义，很容易与其他事物区分开来，而且容易记忆。例如“中国奥林匹克代表团人数”，可能会命名为“numberOfPeopleOnTheChinaOlympicTeam”;再例如“运动场中座椅数量”，可能会命名为“numberOfSeatsInTheStadium”。上述两个例子都很容易理解，但是会发现有一个问题，就是名字长度太长。所以还要注意下面一点。
*变量名的长度一定要适中（工号C6374 徐超）
**变量名太短无法表达其含义，太长的名字又不便于书写，而且影响代码的视觉效果。据研究发现，变量名的平均长度在10到16个字符时，调试程序花费的气力最小。所以，变量名的命名不仅要确保含义清晰，还要注意长度适中，不会对代码造成坏的影响。

=====变量命名要保持一致性（宋文喆）=====
*命名变量使用的单词要保持一致性
为了避免不必要的麻烦，实际命名中应该将有Total，Sum，Average，Max，Min，Record，String，Pointer等这一类的表示计算结果的变量放在最后，保持变量名的一致性从而增强代码的可读性。  <br>
坏例子：totalRevenue（总收入）和expenseTotal（总支出）  <br>
虽然这样的命名都将变量的意思表达出来了，但是实际编程中很可能不小心同时使用而导致代码出错。
*活用对仗词保持命名变量一致性
对仗词使用要准确，要严格按照命名规则命名，如first/last这样的对仗词就很容易理解，应当避免使用与常用语言相去甚远又难记忆的对仗词。
*命名变量使用的单词除了第一个单词的首字母外，其他字母要大写
坏例子：seatcount，teammembercount  <br>
好例子：seatCount，teamMenberCount  <br>
两个例子放在一起可以明显的看出，坏例子的可读性很差，而好例子表达变量的意思一目了然。
====11.2为特定类型的数据命名（段宗超）====
本节主要介绍了循环变量、状态变量、临时变量、布尔变量、枚举类型和具名常量的命名细节。
*循环变量
在计算机语言中，循环会被用到很多，如果这个循环变量只在当前循环中使用，就可以使用i,j和k这些约定俗成的变量名。当这个变量要在循环外使用或者这个循环不只几行，我们就得取一
个比更i有意义的变量名。
*状态变量
状态变量用于描述程序的状态，将标记（flag）看作为一个状态变量，被标记的名字中不应该含有flag。
*临时变量
临时变量用于储存计算的中间结果，常被赋予temp，x等一些模糊的名字，当我们程序中有多个临时变量时，就得警惕我们是否懂得了这个变量所代表的含义。
*布尔变量
布尔变量是有两种逻辑状态的变量，它包含两个值：真和假。所以在给布尔变量命名的时候，就得考虑到变量名的准确性。以下是一些经典的布尔变量名：done、error、found、success和ok。
*枚举变量
使用枚举类型时，通过使用组前缀来明确表示该类型的成员都属于一个组，例如plant_Earth和plant_Mars，我们就可以很清晰的明白这两个变量名都是星球。
*常量
为常量命名时，应该根据该常量所表示的具体含义来命名。
====11.3命名规则的力量（段宗超）====
命名规则有何好处：
*要求你更多地按规矩行事
*有助于在项目之间传递知识
*有助于在新项目中更快速地学习代码
*有助于减少名字更生
*弥补程序语言的不足之处
*强调变量相关之间的关系

何时采用命名规则：
*多个程序员合作开发一个项目时
当多个程序员开发一个项目时，建立命名规则让合作更加轻松，有利于提高代码质量。
*将一个程序转交给另一位程序员进行维护和修改的时候
就目前来说，上述事件是不可避免的，为了让自己的代码能够为其他人读懂，建立命名规则是很有必要的。
*leader评估所写代码的时候
当我们所coding的代码需要交由上级review的时候，好的命名规则让代码清晰易懂。
*当程序太大的时候
程序太大时，必须将代码规范起来，利于后期的维护和修改。
*当一段代码的生命周期过长时
我们有可能会遇到这种情况：写了一段代码，然后过相当一段长的时间后才会对这段代码进行下一步的coding，就得规范命名让我们即使很长时间没看这段代码还是能很快的上手。
*一些不常见的术语用在程序中
如果一些不常见的术语用在了代码中并且我们没有进行相关的规范命名，那么就会发现这些术语在程序中会显得格外别扭。

综上，采用命名规则让代码的可读性增加，可以程序员在代码后期的修改和维护中节省不少的时间。

====11.4非正式命名规则（甘建伟）====
*命名规则是为了区分变量，对象和类型，统一整洁的命名规则能提高程序的可读性。
如：在一个项目中有几个集合，如果只是随便命名为list1，list2，可读性不高。若以userList，employeeList命名，可读性提高。

*命名规则标识一些重要的点，如标识出全局变量，防止滥用，出现问题。

*Java的部分命名原则
常量全部大写并以下划线分隔（ALL_USER_SQL）;变量名和方法名第一个单词首字母小写后续单词首字母大写且不以下划线分（variableOrRoutineName);访问子程序使用get与set前缀

*命名规则没有绝对的，但是规范起来可以让它变得更好。

====11.5标准前缀（甘建伟）====
*标准前缀是对具有通用含义的前缀标准化，为数据命名提供简洁，一致，可读性好的方法。通常由用户自定义类型的缩写和语义前缀组成。
用户自定义类型缩写用于标识被命名对象或变量的数据类型。
语义前缀是描述变量或对象是如何使用的。如‘c’表示数量，‘g’表示全局变量
*标准前缀的优点：由于很多名字都已经标准化，因此程序或类内需要记忆的名字更少了。
*标准前缀的缺陷：在使用标准前缀的同时忽略了给变量起有意义的名字，可读性降低。

====11.6创建具备可读性的短名字（李勇）====
*因环境的需求要你创建简短的名字，应注意其方法：可以通过消除冗余的单词，或使用简短的同义词等策略来创建。
*以下有几种缩写的一般指导原则
 使用标准的缩写方式，使用每个单词的第一个或前几个字母
 去掉虚词（and，or,the）等，去掉非前置元音。（computer变成cmptr，screen变成scrn）等
 应使用每个单词的前几个字母，并保留每个单词的第一个和最后一个字母
 保留每个音节中最引人注意的发音。，并确保不改变变量的含义

*创建缩写中的避免犯错的规则
 缩写得一致并能读出的名字，并且不在每个单词中删除一个字符的方式来缩写
 在代码中缩写对照表解释极短的名字的含义

*本原则的核心问题，是方便代码同方便阅读代码两种理念的差异。正确用好了它，可提高阅读
代码的方便性。

====11.6创建具备可读性的短名字（甘建伟）====

*不要从每个单词中删除一个字符的方式来缩写，键入一个字符不会有什么额外的工作，而节省一个字符的却可能造成可读性的损失。
*创建的名字的缩写应该自己能够读出来。
*避免会有误读的名字缩写。如表示以B结尾，用ENDB比BEND更好。
*名字对于代码读者的意义比对作者更重要。
*创建能够在极短时间了解名字的含义的名字。

====11.7应该避免的名字（李勇）====
1.变量名避免的指导原则
*避免使用令人误解的名字。
*避免使用具有相似含义的名字。
*避免使用发音相近的，又有使用数字的名字。
*避免使用标准类型，变量和子程序的名字。
*避免在名字中包含易混淆的字符。
2.要点
*好的变量名是提高程序可读性的一项关键要素。
*名字要尽可能具体，采用变量的命名规则。
*确保所取名更侧重阅读而不是编写。

====11.7应该避免的名字（工号C6442 甘建伟）====
*名字的含义或者字形相似应该避免使用。（工号C6442 甘建伟）
如：fileNumber与fileIndex这样含义相近易混淆；clientRecs与clientReps只有一个单词不同，易弄错；
*避免在某些名字后面加数字做区分的名字，避免使用易拼写错误的单词做名字。（工号C6442 甘建伟）
如：使用文件名时避免使用file1或file2来对不同文件进行命名；如calendar，concieve等易拼写错误的单词也应避免使用。
*尽量使用与变量等含义相关的名字，增加可读性，避免使用过于随意的名字。（工号C6442 甘建伟）
若为地址则用address命名，邮箱地址可加前缀以emailAddress命名。避免使用如file1与file2随意的名字，之后阅读难度大。
*可以在项目中建立单独的变量名对应的页面来说明。（工号C6442 甘建伟）
如：totalPage：某某的总的页数；pageSize：某某页面的大小

===第12章 基本的数据类型（徐钰颖 钟红飞 邵志超 闫玲玲 李勇）===
====12.1数值概论 （徐钰颖）====
1使用数的时候要避免使用“神秘数值",就是没有经过定义的数字。
*它会使修改变得更可靠，就是不会让你漏掉某个数值。
*会让修改变得容易，当你修改数字时如果你用了神秘数值你就需要把它全部找出来，如果你用了具名常量，只需要改一下该常量的定义即可。
2预防除零错误，就是写代码的时候要考虑分母是否可能为0，防止错误的发生。<br>
3避免混合类型的比较（比如浮点数和整数),要自己手动进行类型转换，你也会准确的知道比较的是什么了。<br>
4最后还要注意编译器的警告，当你写代码的时候出错时，通过编译器警告来发现问题要比你自己找容易的多。

====12.1数值概论 （李勇）====
*"神秘数值"少使用
*需要的话，使用硬编码0和1 
*除零错误的预防，考虑分母是否为零
*类型转换变得更明显，混合类型比较。
*警惕编译器的警告

====12.4字符和字符串（钟红飞）====
*避免使用“神秘数值(magic number）
**神秘数值是在程序中出现的并且没有经过解释的数值文字量。如果你使用的编程语言支持具名常量，那么就用它来代替神秘数值，如果你无法使用具名常量，在可行的情况下应该使用全局变量。避免使用神秘数值，可以增强代码的可读性，并且使修改变得更容易，更可靠。
*Java中读取字符和读取字符串的差别？
**FileInputstream.read()读取的是单个字符,是ASCII码表所能表示的字符,要是要读取像有汉字等其他ASCII不能表示的，就要用FileReader,它读取的是java支持的字符集。另外，像要是读取图片,pdf,psd等这些东西的话，就要用FileInputStream,即文件字节流。应为存在计算机中的就是二进制，是ASCII表示的。要是读取有汉字的.txt,.就用FileReader。其实用的较*多的是BuffereReader,进行逐行读取。
*避免使用字面形式的字符串的原因？
**对于程序的名字、命令名称、报表标题等常常出现的字符串，有时可能需要修改它们的内容。
**在翻译使存放在字符串资源文件中字符串要比翻译存在于代码中的字符串容易得多。
**字符串的字面表示形式通常都会占用较多的存储空间。
**字符和字符串的字面表示形式的含义是模糊的。
*字符串指针和字符数组之间的差异？
**字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘\0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。
**每个元素的值都可以改变。而字符串指针指向的是一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变。
*字符串的初始化：
**如果只需要支持一种文字语言，考虑使用ISO8859字符集；如果需要支持多种语言，使用unicode。
**为避免忘记空结束符，把c-style字符串的长度声明为CONSTANT+1
**用null初始化字符串以避免无结束符的字符串。
**首先，在声明字符数组是初始化为0：char EventName[Max+1] = {0};
**其次，使用calloc()而不是malloc()，calloc()负责分配内存并初始化。
*JAVA中怎样去除字符串尾部的空格？
**String.trim() 
    trim()是去掉首尾空格。
**str.replace(" ", ""); 去掉所有空格，包括首尾、中间 
    代码如下:
    String str = " hell o ";
    String str2 = str.replaceAll(" ", "");
    System.out.println(str2);
**replaceAll(" +",""); 去掉所有空格。  
*Java中char数组(字符数组)与字符串String类型的转换方法？(工号C6440 钟红飞)
**String类的toCharArray()方法，将字符串转换为字符数组。
**String类的valueOf()方法，将char类型的数组转换为字符串。
**在Java语言编程时，使用“口令字段“jPasswordField组件时，如果要获得密码值，就需要使用该组件的getPassword()方法。jPasswordField的getPassword()方法返回一个char类型的数组，我们经常需要将这个数组转换为String类型，以便进行诸如口令匹配或口令赋值等操作。这时，就需要将char类型的数组进行转换。当然也经常会遇到将String类型转换为char数组的情况。
  代码如下:
  String strStringType="my string"; //创建一个字符串变量
  strStringType char[] chrCharArray; //创建一个字符数组
  chrCharArray chrCharArray = strStringType.toCharArray(); //将字符串变量转换为字符数组
  strStringType= String.valueOf(chrCharArray ); //将字符数组转换为字符串

====12.5布尔变量（钟红飞）====
*如何将布尔变量转换为字符串变量？(工号C6440 钟红飞)
   第一种方法是：
   boolean bool = true;
   String s = new Boolean(bool).toString();//将bool利用对象封装器转化为对象
   s.equals("true");
   其中，toString方法是一个继承方法。java中所有的类都是object的继承，object的一个重要方法就是toString，用于将对象转化为字符串。
   第二种方法是：
   boolean bool = true;
   String s = String.valueOf( bool );
*strcmp返回值布尔类型的判断?(工号C6440 钟红飞)
   strcmp: 用于比较两个字符串，原型如下：
   int strcmp ( char const *s1, char const *s2）；
   如果s1小于s2，strcmp函数返回一个小于零的值。如果s1大于s2，函数返回一个大于零的值。如果两个字符串相等，函数就返回零。

====12.2整数 （徐钰颖）====
在用整数的时候要注意以下三点。
*检查整数除法，当你使用整数的时候，其结果会随语言的不同而不同，比如10*（9/10）=（10*9）/10=9。但在整数运算是10*（9/10）=0，因为整数除法9/10等于0。此类问题的解决方法就是重新安排表达式的数序。
*检查整数溢出，在做整数的乘法和加法时，要考虑最大整数，每个整数类型的取值范围不同，32位的计算机和64位的也是不同的。
*检查中间结果的溢出，就是检查每个整数的最大值，就比如A*B/C,如果A和B都是最大值，A*B的结果就已经溢出了，从而导致结果也是错误的。



====12.3浮点数 （徐钰颖）====
使用浮点数时应遵循的指导原则
*避免数量级相差巨大的数之间的加减运算。32位浮点数，1000000.00+0.1可能会得到1000000.00，因为32位不能给你足够的有效位数包容。怎么解决呢，就是先从最小值开始相加，这样做并不能消除舍入问题，但是能使影响减少到最低。
*避免等量判断。很多相等的浮点数值并不一定相等，用不同方法求同一数值结果不一定相同。
坏代码
  double nominal =1.0；//变量nominal是个64位实数
  double sum =0.0；
  for （int i =0；i <10；i++ ） {
  sum +=0.1；//sum是10*0.1，应当等于1.0
  }
  if（nomainal == sum）{//这是错误的比较
  System.out.println(“Numbers are the same.”）；
  }
  else{
  System.out.println(“Numbers are different.”）；
  }
结果是Numbers are different.
好代码
  final double ACCEPTABLE_DELTA =0.00001；
  boolean Equals(double Term1,double Term2){
  if (Math.abs(Term1-Term2)<ACCEPTABLE_DELTA){
  return true;
  }
  else{
  return false；
  }
  }
结果是Numbers are the same.
*处理舍入误差问题。
1换用精准度更高的变量类型。<br>
2换用二进制编码的十进制变量。<br>
3把浮点变量变成整型变量。

====12.3浮点数 (李勇)====

*在浮点数中要尽可能数量级相差之大或者等量的情况下加减判断。 (工号C6441 李勇)
如：1000000.00+0.1可能会得到1000000.00 它不能给你有效位数来包容这么大的区间。
可以表达的十进制数值中，真正有效的数字不高于 8 位。
例子：
1. 1000000000000000000000001          16777217f 
2. 1.00000000000000000000000 1        不能准确表示。先试着进位 
3. 1.00000000000000000000001          由于进位后，结果的最末们不是0，所以直接舍掉 
4. 1.00000000000000000000000          到这里结果就是16777216f 
*下面看一段Java代码    (工号C6441 李勇)
   1. // 34.6-34.0=0.5999985  
   2. System.out.print("34.6-34.0=" + (34.6f-34.0f));  

// 34.6-34.0=0.5999985 
System.out.print("34.6-34.0=" + (34.6f-34.0f)); 

产生这个误差的原因是 34.6 无法精确的表达为相应的浮点数，而只能保存为经过舍入的近似值。这个近似值与 34.0 之间的运算自然无法产生精确的结果。

====12.4字符和字符串 （李勇)====
*用字符串常量来初始化字符数组： (工号C6441 李勇)
char str[ ]={"I am happy"};       可以省略花括号，如下所示
char str[ ]="I am happy";
注意：上述这种字符数组的整体赋值只能在字符数组初始化时使用，不能用于字符数组的赋值，字符数组的赋值只能对其元素一一赋值 

*字符串的表示形式 (工号C6441 李勇)
在C语言中，可以用两种方法表示和存放字符串：
（1）用字符数组存放一个字符串
          char str[ ]="I love China";
（2）用字符指针指向一个字符串
          char* str="I love China";
对于第二种表示方法，有人认为str是一个字符串变量，以为定义时把字符串常量"I love China"直接赋给该字符串变量，这是不对的。


====12.5布尔变量 (李勇)====
*布尔型（Boolean）是一种数据的类型，只有两种值，即"真"与"假".它们只用于存放布尔值（ture或false） 例如，VAR A，B：BOOLEAN (工号C6441 李勇)
*你在创建了布尔变量之后，可在判断语句中得到简化，明了。对于复杂的命题，我们可以用布尔表达式来表示。例如，命题："m,n都是偶数或都是奇数"可表示为"(m mod 2=0)and(n mod 2=0) or (m mod 2=1)and(n mod 2=1)"。
另外，需要的话，可以创建自己的布尔类型。如：变量声明为BOOLEAN而非int，可以直观的体现出你的程序用意。 (工号C6441 李勇)

====12.5 布尔变量 （邵志超）====
布尔变量一般使用时都是周围存在判断的时候，换言之将逻辑判断的结果以更加直观可找的某个字段来展现。
//复杂的
if(（document.add()） and ( not input()) and -((min _avg<=Count)and(Count<=min_max)) 
then 
do.....
//简化之后
 file=(document.add()) and (not input())
leCount=(min_avg<=Count)and(Count<=min_max)
then
do....
当然再具体某些情况也可以定义自己的boolean类型，然别人能更直接的看明白你设定这个字段的意义。

====12.5布尔变量（葛川川）====
	布尔判断要使目的明确	<br/>
	'''目的不明确的布尔判断'''
	  	<nowiki>if（（elementIndex<0）丨丨（MAX_ELEMENTS<elementIndex）丨丨（elementIndex==lastElementIndex））{。。。}		</nowiki><br/>
	'''目的明确的布尔判断'''
 	<nowiki>finished=（（elementIndex<0）丨丨（MAX_ELEMENTS<elementIndex）丨丨（elementIndex==lastElementIndex））;	<br/>
	 if(finished丨丨repeatedEntry){。。。}</nowiki>
 	<br/>
	 目的明确的布尔判断使得if判断的对象更加明确了<br/>
	
	*程序中布尔类型的使用心得
	**java 有一种表示逻辑值的简单类型，称为布尔型。它的值只能是真或假这两个值中的一个。
	'''示例'''
 	<br/>
 <nowiki>	class BoolTest { 
	    public static void main(String args[]) { 
	    boolean b; 
	    b = false; 
	    System.out.println(""b is "" + b); 
	    b = true; 
	    System.out.println(""b is "" + b); 
	    一个布尔值可以控制if语句
	    if(b) System.out.println(""This is executed.""); 
	    b = false; 
    if(b) System.out.println(""This is not executed.""); 
	    关系操作符的结果是一个布尔值
	    System.out.println(""10 > 9 is "" + (10 > 9)); 
	    } 
	   }</nowiki><br/>

'''这个程序的运行结果如下所示''' 
 b is false 
 b is true 
 This is executed. 
 10 > 9 is true 
*当用方法println ( ) 输出布尔的值时，显示的是“true ”或“false”。
*布尔变量的值本身就足以用来控制if语句。没有必要将if语句写成像下面这样： if(b == true) 
*关系运算符（例如<）的结果是布尔值。这就是为什么表达式10>9 的显示值是“true”。此外，在表达式10>9 的两边额外的加上括号是因为加号“+”运算符比运算符“>”的优先级要高。
*JAVA布尔类型进行逻辑运算和按位运算的区别

从结果上，2种运算结果都是一样，但逻辑运算会有“短路”现象，按位的没有，而按位又比逻辑运算多了“异或”功能。

'''短路现象'''
 class br {
   static boolean f1() {
     return false;
   }
   static boolean f2() {
     return true;
  }
   static boolean f3() {
     return true;
   }
 }
<br/> 
boolean f_1 = br.f1()&&br.f2()&&br.f3();<br/>
结果为false,当因为f1()就为false，那么后面的&&运算不用进行都知道结果了，JAVA就会发生“短路”对后面的运算乎略，性能提高。<br/>
boolean f_2 = br.f2()||br.f1()||br.f3();<br/>
结果true，同样f2()为true，后面一样不用再运算了。<br/>
好像很方便又高效，但还是有缺点。<br/>
boolean f_3 = br.f2()||br.f3()&&br.f1();<br/>
结果就变成true,正确应该是false，这就是“短路”造成的错误了，想获得正确的答案就需要加括号：<br/>
f_3=( br.f2()||br.f3())&&br.f1(); <br/>
*按位运算提供逻辑没有的异或功能：
 boolean f = true^true;
 结果f = false;

====12.6 枚举类型 （邵志超）====
枚举类型适用于定义一类对象中每一个成员参数的数据类型。
提高程序的可读性：
//如下例
boolean flg=www.getClId(int,true,data,false);
这种函数调用里的参数让人看得茫然不知所指，所以才有了枚举类型的应用
// boolean flg=www.getClId(
   userCd,
   work,
   data,
   house  
);
枚举类型的应用也可以让代码的修改变得条理清晰可见，枚举类型也可以用于某些循环的遍历输出结果
将枚举类型的第一个元素留作非法值的意义在于确定那些没有合理初始化的变量（一般可能是为0的情况）。

====12.6 枚举类型 （李勇）====
*枚举的定义枚举类型定义的一般形式为：
::enum 枚举名{ 枚举值表 }; 在枚举值表中应罗列出所有可用值。这些值也称为枚举元素。
::例如： 该枚举名为weekday，枚举值共有7个，即一周中的七天。凡被说明为weekday类型变量的取值只能是七天中的某一天
*枚举变量的说明 如同结构和联合一样，枚举变量也可用不同的方式说明，即先定义后说明，同时定义说明或直接说明。
::设有变量a,b,c被说明为上述的weekday，可采用下述任一种方式：
enum weekday{ sun,mou,tue,wed,thu,fri,sat };
enum weekday a,b,c;

====12.6 枚举类型 （工号C6428 葛川川）====
枚举常量是枚举类型中的值，即枚举值。枚举类型是一种用户定义的类型，只有用户在程序中定义它后才能被使用。用户通常利用枚举类型定义程序中需要使用的一组相关的符号常量。
*枚举类型的定义格式（工号C6428 葛川川）
enum   <枚举类型名>   {<枚举表>};
它是一条枚举类型定义语句，该语句以enum保留字开始，接着为枚举类型名，它是用户命名的一个标识符，以后就直接使用它表示该类型，枚举类型名后为该类型的定义体，它是由一对花括号和其中的枚举表所组成，枚举表为一组用逗号分开的由用户命名的符号常量，每个符号常量又称为枚举常量或枚举值。如：
**  enum   color{red,   yellow,   blue};
**   enum   day{Sun,   Mon,   Tues,   Wed,   Thur,   Fri,   Sat};
第一条语句定义了一个枚举类型color，用来表示颜色，它包含三个枚举值red，yellow和blue，分别代表红色、黄色和兰色。
第二条语句定义了一个枚举类型day，用来表示日期，它包含7个枚举值，分别表示星期日、星期一至星期六。
*一种枚举类型被定义后，可以像整型等预定义类型一样使用在允许出现数据类型的任何地方。（工号C6428 葛川川）
如：可以利用它定义变量。
**    ①enum   color   c1,   c2,c3;
**    ②enum   day   today,   workday;
**    ③c1=red;
**    ④workday=Wed;
**①语句开始的保留字enum和类型标识符color表示上述定义的枚举类型color,其中enum可以省略不写，后面的三个标识符c1，c2和c3表示该类型的三个变量，每一个变量用来表示该枚举表中列出的任一个值。
**②语句开始的两个成分（成分之间的空格除外）表示上述定义的枚举类型day,同样enum可以省略不写，后面的两个标识符today和workday表示该类型的两个变量，每一个变量用来表示该枚举表中列出的七个值中的任一个值。
**③语句把枚举值red赋给变量c1。
**④语句把枚举值Wed赋给变量workday。
*在一个枚举类型的枚举表中列出的每一个枚举常量都对应着一个整数值，该整数值可以由系统自动确认，也可以由用户指定。（工号C6428 葛川川）
若用户在枚举表中一个枚举常量后加上赋值号和一个整型常量，则就表示枚举常量被赋予了这个整型常量的值。
如：enum   day{Sun=7,   Mon=0,   Tues,   Wed,   Thur,   Fri,   Sat};
用户指定了Sun的值为7，Mon的值为0。
若用户没有给一个枚举常量赋初值，则系统给它赋予的值是它前一项枚举常量的值加1，若它本身就是首项，则被自动赋予整数0。如对于上述定义的color类型，red，yellow和blue的值分别为0,1和2；对于刚被修改定义的day类型，各枚举常量的值依次为7,0,1,2,3,4,5,6。由于各枚举常量的值是一个整数，所以可把它同一般整数一样看待，参与整数的各种运算。又由于它本身是一个符号常量，所以当作为输出数据项时，输出的是它的整数值，
而不是它的标识符，这一点同输出其他类型的符号常量是一致的。


====12.7 具名常量 （邵志超）====
具名常量，即给某一个或是某一类变量起别名。一般用于程序代码中的某一个可能会变化的参数的修改与调用。
采用具名化变量后只需要修改定义时的参数值即可，不需要在程序中每个调用该参数的地方修改数值。
具名变量的使用可以提高程序的可读性和维护性。
//如下例中字符串的拼接输出
String s = "吃葡萄不吐葡萄皮";
String a = "不吃葡萄倒吐葡萄皮";
System.out.println(s+a);
想要改变控制台的输出内容，只需要在s和a的定义出修改即可。

====12.8 数组（Arrays）闫玲玲====

*最简单和最常用的结构化数据类型。（使用数据提出的建议）
::确认所有数组没有超出数组的边界。
::考虑由容器来取代数组。
::检查数组的边界点。
::若是多维数组，则确认下标使用顺序正确。
::提防下标串话。
====12.9 创建你自己的类型（类型别名）闫玲玲====
*创建你自己的类型（类型别名）
::是语言所能赋予自己一种最强有力的、最有助于澄清你对程序的理解的功能之一。
::能很好地隐藏信息，把客户所要求创建的类型和尽量避免输错可能的隐藏信息结合起来。
:*创建自定义数据类型的指导原则：
:::给所创建的类型取功能导向的名字
:::避免使用预定义类型
:::不要重定义一个预定义类型
:::定义替类型以便于移植
:::考虑创建有个累而不是使用typedef
*为什么创建自己的类型的示例用pascal和ada写的
:: Ada申明如下：
::CurrentTemperature： INTEGER range 0..212;
:包含了下列语句不具备的重要语句信息：
::int temperature；
总结：写一行代码到创建的一个简单数据类型，到创建一个类，是很大的一步，要付出更多努力创建这个类。
*单精度float 和双精度double的区别?
::单精度实数在内存中占32bit 有效数字为6~7位
::双精度实数占内存单元为64bit 有效数字为15~16位
::没有说明时,实型常量是作为双精度处理的,若要使用单精度需在后面加上字母f或F,如123.45f
*常犯错误：
::在运用数组中，大多数人常常随机使用数组。
:::其解决方法可以用集合、栈、和队列来等按顺序存取元素的数组结构来取代数组。
::定义类型的时候容易定义成被预定义的类型。
:::解决方案是使用能表现现实世界问题的类型名。
::所有的数组下标都没有超出数组的边界吗？
:::组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。数组是在程序设计中使用前，要先对数组元素的多少进行定义，也就是确定数组维度和下标的界限，当引用数组时，下标超过定义的范围或维度错误时，就会出现“错误的数组下标或者数组下标维度超出界限”的错误
*array() 创建数组
静态创建 ：String[] array = {"a", "b", "c"}; 
静态创建 ：String[] array = new String[] {"a", "b", "c"};
*字符串比较函数strcmp
:格式：strcmp（字符数组名1，字符数组名2）
:功能：按照ASCII码顺序比较两个数组中的字符串，并由函数返回值返回比较结果。
:字符串1=字符串2，返回值=0；
:(strcmp：比较两个字符串
:若str1=str2，则返回零；
:若str1<str2，则返回负数；
:若str1>str2，则返回正数。)
*strcat （字符数组名1，字符数组名2）
:功能：把字符数组2中的字符串连接到字符数组1 中字符串的后面，并删去字符串1后的串标志“”。本函数返回
:int a[3][4]
:说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。该数组的下标变量共有3×4个值是字符数组1的首地址，而且需要字符串处理函数:的包含头文件 #include"string.h" 
*二维数组的类型说明符数组名[常量表达式1][常量表达式2]…
:其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。
:int a[3][4]; 说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。该数组的下标变量共有3×4个
:a[0][0],a[0][1],a[0][2],a[0][3]
:a[1][0],a[1][1],a[1][2],a[1][3]
:a[2][0],a[2][1],a[2][2],a[2][3]
16章的延伸（使用数组和使用循环的相似之处）
*循环的种类：
:计数循环
:连需求值的循环
:无限循环
:迭代器循环
:（以上在灵活度上有差异，将循环放在循环的中间，开始，结尾可以告诉你该循环会不会至少执行一次）
:灵活的循环种类：
:Vidusal:For-Next,While,Do-Loop-While
:C,C++,C#,Java:for,while,do-while
*for,foreach,while循环的优劣：
:for循环可用来执行那些不需要循环内部控制的简单操作，若某一容器的元素进行迭代的时候或者崔仔一个必须执行从循环中跳出的条件那就用for循环:。
:foreach循环很适用于对于数组或者其他容器的各项元素执行操作，优势在意消除了循环内务处理算术，也消除了出错的可能性。
:while其实很灵活，他的主要事项是决定在循环开始处还是末尾处做一些检查。
*代码进入循环的一些原则：
:只从一个位置进入循环
:把初始化代码放在循环前面
:用while（true）表示无限循环（无限循环的的标准写法更倾向于for（； ；））
:在适当的情况下使用for循环
:在while循环更试用的时候，不要用for循环（内务语句不控制循环进度）
*处理循环体：
:用“{”“}”把循环中的语句括起来（增加可读性，防止修改代码时出错，很好的预防性编程实践）
:避免空循环
:把循环内务操作要么放在循环的开始，要么放在循环的末尾（内务操作指i=i+1或者j++类似的表达式，目的是控制循环）
:一个循环只做一件事
*退出循环
:设法确认循环能够终止
:使循环终止看起来很明显（关键在于把控制语句放在一个地方）
:不要为了终止循环为胡乱改动for循环的下标（在循环体内某个适当的地方把这一最终取值赋给某个变量）
:避免出现依赖于循环下标最终取值的代码
:考虑使用安全计数器（确保所有的循环都终止了，他会增加复杂度并可能引起其他错误）

===第13章 不常见的数据类型（王西亚 范子高）===

====13.1 结构体（王西亚）====
=====结构体类型===== 
*C/C++中允许用户定义一组包含若干个类型不同（或相同）的数据项的数据类型，称之为结构体。
=====结构体的作用=====
*用结构体来明确数据关系。结构体把相关联的一组数据项聚集在一起。
::坏代码
 //下面一组变量很难看懂
 name=inputName
 address=inputAddress
 phone=inputPhone
 title=inputTitle
 department=inputDepartment
 bonus=inputBonus

::好代码
 //下面代码引入结构体使得数据关系变得更加清晰
 employee.name=inputName  //雇员信息
 employee.address=inputAddress //雇员信息
 employee.phone=inputPhone  //雇员信息

 supervisor.title=inputTitle  //主管信息
 supervisor.department=inputDepartment //主管信息
 supervisor.bonus=inputBonus //主管信息
*拥结构体简化对数据块的操作。对结构体执行操作要比对各个元素执行同样的操作容易的多。
*用结构体来简化参数列表。我们可以将相关的元素组织到一个结构体中，把他当做一个整体传递出去。
::坏代码
 HardWayRoutine(name,address,phone,ssn) //笨拙的子程序调用，容易犯错
::好代码
 EasyWayRoutine(employee) //优雅的子程序调用，降低犯错概率
*用结构体减少维护。对结构体的修改只会导致对程序做很小的修改，减少错误。
=====定义结构体变量的方法=====
*struct 结构体类型名{成员列表}
*其中“结构体类型名”用来作结构类型的标志。
*每个“成员”也称为一个域，成员表又叫做“域表”。
例如：
struct stu / *定义学生结构体类型* /
{
    char name[20]; / * 学生姓名* /
    char sex; / * 性别* /
    long num; / *学号* /
    float score[3]; / * 三科考试成绩* /
 };
=====其它重要说明=====
*声明结构体类型的位置一般放在文件开头，在所有函数之前，是一种良好的编程风格。
*类型与变量是不同的概念：只能对结构体中的成员赋值，不能对结构体类型赋值。
*结构体变量中的成员（即“域”）可以单独使用，它的作用与地位相当于同类型的普通变量。

====13.2 指针（工号C6428 葛川川）====
*指针是一个地址，指向的是个类型：（工号C6428 葛川川）
c语言中的类型有int，char，bool（这个不常用），一般使用int，char就可以满足一般的类型需求的，如果对于变量的长度过大，就是用long ，float，double，关于各个类型使用的的长度问题，可以使用sizeof（int）或者sizeof（long）来查看各个类型，在系统中的大小。而指针就是一个8个字节（64系统）。

*指针指向的是地址，地址指向的是内容：（工号C6428 葛川川）
我们需要一个变量，来存储地址，这个变量的值是地址，但是我们可以通过修改变量的值，来不断的改变地址，但是，我们如果需要改变该个地址的值的话，就需要，对地址的值进行修改，而不改变地址。<br/>
 int a = 10；
 int *p ； 
 p = &a； 
 *p =11；
 a=?
p 是一个变量，使用p来存储变量a的地址，使用*p对于这个变量进行赋值，a的值是11，因为使用了*p赋值，就相当于a=11，赋值效果一样的。

*指针的指针，是面对于指针的变量：（工号C6428 葛川川）
指针的指针,如何区分指针和指针的指针。<br/>
char *p； 
char **pr； 
pr = &p；<br/>
char *（*pr）； *pr是一个存储的值为指针的变量，pr就是存储上个变量地址的变量。整合起来就是，pr是一个存储的值为指针的地址的变量。


====13.2 指针（王西亚）====

=====指针变量声明的注意事项=====
*int*和int * (注意空格的位置) 两种声明方式效果相同。对于单变量声明，即一条语句中只声明一个指针的情况下没有区别，原因是C语言允许形式的自由性。
::上面的声明相当于：
 int*a;
 int *a;

*int* a,b,c;
::错误的理解：认为声明了三个指针变量。
::正确的理解：只是a是指针型变量，b和c都是普通的整数。
::上面的声明相当于：
 int *a;
 int b;
 int c;
=====指针的类型、指针所指向的类型的判断方法=====
*只要把指针声明语句中的指针名去掉，剩下的部分就是指针的类型
*只要把指针声明语句中的指针名和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型
::例子
 int *ptr;      //指针类型:int *      指针所指向的类型:int
 char *ptr;     //指针类型:char *     指针所指向的类型:char
 int (*ptr)[3]; //指针类型:int (*)[3] 指针所指向的类型:int ()[3]
 int **ptr;     //指针类型:int**	     指针所指向的类型:int *
 int *(*ptr)[4];//指针类型:int *(*)[4]指针所指向的类型:int *()[4]
=====指针存储的数值是内存的一个地址=====
*指针的值是指指针本身存储的数值，这个值会被编译器当做一个地址进行编译
*指针本身的大小是一个字长（32位机是4字节，64位机是8字节
*指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度是sizeof(指针所指向的类型)的一片连续内存区域
**说一个指针的值是X，就是说该指针指向了以X为首地址的一片内存区域
**说一个指针指向了某块内存区域，相当于说该指针的值是这块内存区域的首地址
*指针所指向的内存区和指针所指向的类型是两个完全不同的概念
**指针光声明但不初始化时，它所指向的内存区域是不存在的
====13.3 全局数据(范子高)====
全局数据区别于类中的全局变量。
=====全局数据的常用问题=====
*在对数据进行操作时会无意间进行全局数据的操作，但是以为全局数据不会改变。
*在使用别名时，实际上全局数据和别名所指向的使用一个数据。在例子中输入为全局变量进行输出时，inputVar被初始化为0，操作后赋值给全局数据globalVar，所以在输出前两个值均为5。原因在于你是用的别名和输入的全局数据名一样。
*在多线程程序大量出现的情况下，出现了全局数据如果在多个子程序中进行使用，那么一旦对数据进行了更改，那么原来的程序所要表达的方法将会改变。
*全局数据将会加大代码重写的难度，在你重写程序时，会出现是否依旧使用全局数据的难题，如果选择继续使用，那么在你以后每一次对这个程序进行重写的过程中你都需要使用全局数据，另一种方法就是把需要的数据以不适用全局数据的方式表示出来。
*全局数据的加载实在程序开始运行时就进行加载了，那么就出现了问题，如果在一个程序中使用了其他程序中的全局数据，那么如何决定全局数据加载的顺序。
*全局数据破坏了代码的模块化设计，在模块化设计中就是要减少代码的耦合，而全局数据的使用与这个思想相违背。
=====全局数据的缺点=====
*用于保存全局数值，在整个程序中都不进行修改操作，只对其数值进行读取。
*用于模拟具名常量，类似于java中用final修饰的常量。
*用于模拟枚举类型，将一个对象中的所有数据逗列举出来。
*可以简化对于一个常用数据的使用，在对于一个数据频繁使用的时候，把它定义为全局数据，将它为数不多的使用子程序集中在一起，可以方便进行维护。
*用于消除流浪数据，我的理解是类似与java中的exception message，在所有的方法中都可能出现message，但是不一定在每一个都会抛出exception，所以将它定义为全局数据，在所有的子程序中都可以使用，不会因为不使用而没有意义。
=====使用全局数据的条件=====
*首先将变量设为局部变量，在你需要时先将其转换为protected或者private修饰符修饰的变量，最后在别无选择的情况下在转换为全局变量。
*如果一个变量需要被整个程序访问，那么它是真的全局变量。如果他只是在一组特定的子程序中被频繁使用，那么它只是类变量。
*使用访问子程序来取代全局数据。
=====代替使用全局数据的方法=====
通过访问子程序的方式来代替使用全局数据。
使用子程序的优势：
*可以获得对于数据的集中控制，方便后期维护和修改。
*可以确保对变量所有的引用都得到了保护。
*信息进行了隐藏。
*访问子程序可以转变成为抽象数据类型。
使用子程序的过程：
*所有的代码都通过调用方法来获取数据而不是直接使用全局数据。
*将数据按照一定的规则进行分类，不要讲所有数据都放在一处，这样依旧不便于维护和修改。
*在多线程访问的时候，应该对子程序进行锁定，防止多处都是用此程序。
*在访问的子程序中构建一个抽象层，这样方便阅读。
=====降低全局数据的风险=====
*在必须使用全局数据的时候必须注意的问题。
*使用命名规则对全局数据命名，通过不同的类或者包来进行命名。
*为全局数据准备一份注释详细的清单来进行全局数据的统计。
*不要用全局数据来存放中间值，需要改变值时，在修改后重新赋值给全局数据。
*不要通过大对象存储全局数据的方式来进行传递，浪费内存空间。