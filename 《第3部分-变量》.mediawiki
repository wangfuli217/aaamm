=== 参加人员 ===
邵志超  王西亚  徐超  段宗超  闫玲玲  徐钰颖  范子高  肖秀丽  葛川川  钟红飞  李勇  甘建伟  赵明月

=== 第10章 使用变量的一般事项（邵志超）===
====10.3变量初始化原则心得（邵志超）====
*变量初始化原则的详细说明：变量的初始化在之后的逻辑代码中有关数据的操作时起着很关键的作用，一般的代码编写时都是在定义声明变量的同时赋予其初始值：如下列举的几种类型变量的初始化；
    String s={"a","abc"," ","实践"}; 
    int[]a={1,23,42};
    （double）float b=3.14d;//有可能在某些工具中默认是double类型的精度要求
  //code using s,a,b....
理想情况下是：声明初始化的变量最好是满足就近原则（java代码为例）
*也存在关键字 final ，static，所修饰的常量，这种类型的变量的初始化一般是某些公有固定属性或是成员的固定私有属性的定义。
*具名常量的初始化 
const blue =3;
const red =4;
Type prefix
be (blue) as String;
rd (red) as int ;
End Type
将对应的变量值赋予别名，在之后的方法中调用时可以根据别名找到对应的变量值，更改变量值时也很方便，只需要在定义时修改对应要求的数值即可。


====10.4 作用域（徐超）====

=====变量引用局部化的好处=====
衡量变量不同的引用点的靠近程度的一个概念是“跨度”
'''''java示例：'''''
a = 0;
b = 0;
c = 0;
a = b + c;

在上例中，对a的第一次引用和第二次引用之间存在两行代码，因此a的跨度是2；以此类推，b的跨度是1，c的跨度是0。当变量集中在一起时，使得代码阅读者每次只关注一部分代码；反之当变量的距离比较远，就要来回翻阅，如果在其中有新代码加入，很容易使阅读代码的人忘记了该变量的值。
所以把变量引用点集中起来主要好处就是提高了程序的可读性。

=====缩短变量“存活”时间的好处
*减小攻击窗口
存活时间是指一个变量存在期间所跨越的语句总数，开始于引用该变量的第一条语句，结束于引用其的最后一条语句。保持变量短的存活时间的好处是减小攻击窗口，当你修改一个变量位置之间的区域，该变量发生错误的可能性大大降低。

*减少初始化错误
修改程序时，经常会把直线型代码改为循环，这时把初始化的代码和循环部分放在一起，可以减少因修改代码而导致初始化错误的可能性。

*降低代码的理解难度
假设一个变量在第1行被赋值，到第50行才再次引用，那么该变量在第1-45行范围内一直被使用；如果该变量在第1行被赋值后，第2行就引用了，那么在关注这个变量时，只需关注很少的一部分代码，阅读者也更容易理解代码。

*易拆分
当变量的多次引用靠的非常近，那么把相关代码拆分重构成子程序时，难度大大降低。



=== 第11章 变量名的力量===

====11.4非正式命名规则（甘建伟）====
*命名规则是为了区分变量，对象和类型，统一整洁的命名规则能提高程序的可读性。
如：在一个项目中有几个集合，如果只是随便命名为list1，list2，可读性不高。若以userList，employeeList命名，可读性提高。

*命名规则标识一些重要的点，如标识出全局变量，防止滥用，出现问题。

*Java的部分命名原则
常量全部大写并以下划线分隔（ALL_USER_SQL）;变量名和方法名第一个单词首字母小写后续单词首字母大写且不以下划线分（variableOrRoutineName);访问子程序使用get与set前缀

*命名规则没有绝对的，但是规范起来可以让它变得更好。
====xxxxxx心得2====
心得2的详细说明YYYYYYYYYYYYYYYYYYYY



===第12章 基本的数据类型 （徐钰颖）===
====数值概论心得====
1使用数的时候要避免使用“神秘数值",就是没有经过定义的数字。
*它会使修改变得更可靠，就是不会让你漏掉某个数值。
*会让修改变得容易，当你修改数字时如果你用了神秘数值你就需要把它全部找出来，如果你用了具名常量，只需要改一下该常量的定义即可。
2预防除零错误，就是写代码的时候要考虑分母是否可能为0，防止错误的发生。<br>
3避免混合类型的比较（比如浮点数和整数),要自己手动进行类型转换，你也会准确的知道比较的是什么了。<br>
4最后还要注意编译器的警告，当你写代码的时候出错时，通过编译器警告来发现问题要比你自己找容易的多。
====整数心得====
在用整数的时候要注意以下三点。
*检查整数除法，当你使用整数的时候，其结果会随语言的不同而不同，比如10*（9/10）=（10*9）/10=9。但在整数运算是10*（9/10）=0，因为整数除法9/10等于0。此类问题的解决方法就是重新安排表达式的数序。
*检查整数溢出，在做整数的乘法和加法时，要考虑最大整数，每个整数类型的取值范围不同，32位的计算机和64位的也是不同的。
*检查中间结果的溢出，就是检查每个整数的最大值，就比如A*B/C,如果A和B都是最大值，A*B的结果就已经溢出了，从而导致结果也是错误的。

====12.4字符和字符串（钟红飞）====
1.避免使用“神秘数值(magic number）
    神秘数值是在程序中出现的并且没有经过解释的数值文字量。如果你使用的编程语言支持具名常量，那么就用它来代替神秘数值，如果你无法使用具名常量，在可行的情况下应该使用全局变量。避免使用神秘数值，可以增强代码的可读性，并且使修改变得更容易，更可靠。
2.Java中读取字符和读取字符串的差别?
    FileInputstream.read()读取的是单个字符,是ASCII码表所能表示的字符,要是要读取像有汉字等其他ASCII不能表示的，就要用FileReader,它读取的是java支持的字符集。另外，像要是读取图片,pdf,psd等这些东西的话，就要用FileInputStream,即文件字节流。应为存在计算机中的就是二进制，是ASCII表示的。要是读取有汉字的.txt,.就用FileReader。其实用的较多的是BuffereReader,进行逐行读取。



===第13章 不常见的数据类型===

====13.1 结构体（王西亚）====

1 结构体类型： C/C++中允许用户定义一组包含若干个类型不同（或相同）的数据项的数据类型，称之为结构体。

2 结构体的作用:
*用结构体来明确数据关系。结构体把相关联的一组数据项聚集在一起。例如，可以把学号，姓名，性别，班级，成绩等与学生有关的变量定义在一个结构体中。
*拥结构体简化对数据块的操作。对结构体执行操作要比对各个元素执行同样的操作容易的多。
*用结构体来简化参数列表。我们可以将相关的元素组织到一个结构体中，把他当做一个整体传递出去。
*用结构体减少维护。对结构体的修改只会导致对程序做很小的修改，减少错误。
3 声明符号：通过 struct 关键字。

4 一般形式：struct 结构体类型名{成员列表}
*其中“结构体类型名”用来作结构类型的标志。
*每个“成员”也称为一个域，成员表又叫做“域表”。
例如：
struct stu / *定义学生结构体类型* /
{
    char name[20]; / * 学生姓名* /
    char sex; / * 性别* /
    long num; / *学号* /
    float score[3]; / * 三科考试成绩* /
 };

====13.3 全局数据(范子高)====
全局数据区别于类中的全局变量。
=====全局数据的常用问题=====
*在对数据进行操作时会无意间进行全局数据的操作，但是以为全局数据不会改变。
*在使用别名时，实际上全局数据和别名所指向的使用一个数据。在例子中输入为全局变量进行输出时，inputVar被初始化为0，操作后赋值给全局数据globalVar，所以在输出前两个值均为5。原因在于你是用的别名和输入的全局数据名一样。
*在多线程程序大量出现的情况下，出现了全局数据如果在多个子程序中进行使用，那么一旦对数据进行了更改，那么原来的程序所要表达的方法将会改变。
*全局数据将会加大代码重写的难度，在你重写程序时，会出现是否依旧使用全局数据的难题，如果选择继续使用，那么在你以后每一次对这个程序进行重写的过程中你都需要使用全局数据，另一种方法就是把需要的数据以不适用全局数据的方式表示出来。
*全局数据的加载实在程序开始运行时就进行加载了，那么就出现了问题，如果在一个程序中使用了其他程序中的全局数据，那么如何决定全局数据加载的顺序。
*全局数据破坏了代码的模块化设计，在模块化设计中就是要减少代码的耦合，而全局数据的使用与这个思想相违背。
=====全局数据的缺点=====
*用于保存全局数值，在整个程序中都不进行修改操作，只对其数值进行读取。
*用于模拟具名常量，类似于java中用final修饰的常量。
*用于模拟枚举类型，将一个对象中的所有数据逗列举出来。
*可以简化对于一个常用数据的使用，在对于一个数据频繁使用的时候，把它定义为全局数据，将它为数不多的使用子程序集中在一起，可以方便进行维护。
*用于消除流浪数据，我的理解是类似与java中的exception message，在所有的方法中都可能出现message，但是不一定在每一个都会抛出exception，所以将它定义为全局数据，在所有的子程序中都可以使用，不会因为不使用而没有意义。