=== 参加人员 ===
邵志超  王西亚  徐超  段宗超  闫玲玲  徐钰颖  范子高  肖秀丽  葛川川  钟红飞  李勇  甘建伟  宋文喆

=== 第10章 使用变量的一般事项（葛川川 徐超 宋文喆 肖秀丽）===
====10.1数据认知（葛川川）====
=====积累数据类型的必要性=====
*1数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。
*2如果知道变量确实总是存储特定类型的数据，声明了这种特定类型的变量，以更高的效率处理这个数据。例如，存储人名的变量最好表示成 String 数据类型，因为名字总是由字符组成。
充分利用内存并提高处理效率
====10.2轻松掌握变量定义（葛川川）====
=====使隐式声明不出错=====
隐式声明:当你使用一个未声明的变量的时候，编译器会自动为你声明该变量（1取决于你的编译器设置2编程语言支持隐式声明）
*1关闭隐式声明
*2声明全部变量
*3遵循某种命名规则
*4检查变量名

====10.3变量初始化原则心得（邵志超）====
*变量初始化原则的详细说明：变量的初始化在之后的逻辑代码中有关数据的操作时起着很关键的作用，一般的代码编写时都是在定义声明变量的同时赋予其初始值：如下列举的几种类型变量的初始化；
    String s={"a","abc"," ","实践"}; 
    int[]a={1,23,42};
    （double）float b=3.14d;//有可能在某些工具中默认是double类型的精度要求
  //code using s,a,b....
理想情况下是：声明初始化的变量最好是满足就近原则（java代码为例）
*也存在关键字 final ，static，所修饰的常量，这种类型的变量的初始化一般是某些公有固定属性或是成员的固定私有属性的定义。
*具名常量的初始化 
const blue =3;
const red =4;
Type prefix
be (blue) as String;
rd (red) as int ;
End Type
将对应的变量值赋予别名，在之后的方法中调用时可以根据别名找到对应的变量值，更改变量值时也很方便，只需要在定义时修改对应要求的数值即可。


====10.4 作用域（徐超）====

=====变量引用局部化的好处=====
*衡量变量不同的引用点的靠近程度的一个概念是“跨度”
'''''java示例：'''''

 a = 0;
 b = 0;
 c = 0;
 a = b + c;

在上例中，对a的第一次引用和第二次引用之间存在两行代码，因此a的跨度是2；以此类推，b的跨度是1，c的跨度是0。当变量集中在一起时，使得代码阅读者每次只关注一部分代码；反之当变量的距离比较远，就要来回翻阅，如果在其中有新代码加入，很容易使阅读代码的人忘记了该变量的值。
所以把变量引用点集中起来主要好处就是提高了程序的可读性。

=====缩短变量“存活”时间的好处=====
*减小攻击窗口
存活时间是指一个变量存在期间所跨越的语句总数，开始于引用该变量的第一条语句，结束于引用其的最后一条语句。保持变量短的存活时间的好处是减小攻击窗口，当你修改一个变量位置之间的区域，该变量发生错误的可能性大大降低。

*减少初始化错误
修改程序时，经常会把直线型代码改为循环，这时把初始化的代码和循环部分放在一起，可以减少因修改代码而导致初始化错误的可能性。

*降低代码的理解难度
假设一个变量在第1行被赋值，到第50行才再次引用，那么该变量在第1-45行范围内一直被使用；如果该变量在第1行被赋值后，第2行就引用了，那么在关注这个变量时，只需关注很少的一部分代码，阅读者也更容易理解代码。

*易拆分
当变量的多次引用靠的非常近，那么把相关代码拆分重构成子程序时，难度大大降低。

=====减小作用域的做法=====
*在循环开始前就对变量进行初始化
这种做法的好处是，在你修改循环时，会很容易记住要对循环的初始化代码进行修改，并且当需要在循环之外再加一层循环时，这样的初始化对循环的每一个执行都是有效的。

*在变量即将使用时为其赋值
这种做法的好处是，很方便就找出这个变量的赋值处。
 C++良好示例：良好的变量声明与初始化
 int receiptIndex = 0;
 float dailyReceipts = TodaysReceipts();
 double totalReceipts = TotalReceipts( dailyReceipts );

*相关的语句集中到一起
这样做的好处是，更容易方便的寻找它们。
 C++坏例子：使用两套变量——让人困惑的做法
 void SummarizeData( ... ) {
  ...
  GetOldData( oldData, &numOldData );
  GetNewData( newData, &numNewData );
  totalOldData = Sum( oldData, numOldData );
  totalNewData = Sum( newData, numNewData );
  PrintOldDataSummary( oldData, totalOldData, numOldData );
  PrintNewDataSummary( newData, totalNewData, numNewData );
  SavaOldDataSummary( totalOldData, numOldData );
  SavaNewDataSummary( totalNewData, numNewData );
 }
在上例中，需同时关注6个变量。

 C++好例子：使用两套变量——更容易理解的做法
  void SummarizeData( ... ) {
  GetOldData( oldData, &numOldData );
  totalOldData = Sum( oldData, numOldData );
  PrintOldDataSummary( oldData, totalOldData, numOldData);
  SaveOldDataSummary( totalOldData, numOldData );
  ...
  GetNewData( newData, &numNewData );
  totalNewData = Sum( newData, numNewData );
  PrintNewDataSummary( newData, totalNewData, numNewData);
  SaveNewDataSummary( totalNewData, numNewData ); 
  ...
 }
这段代码就更容易理解。

*相关语句拆分、提取组成成单独的子程序
其他条件相同，一个较短子程序中的变量通常比较长子程序中变量的跨度和存活时间要短，那么把一组相关语句拆分组成小的子程序，自然作用域也会缩小。

*变量的作用域由小变大
减少作用域的方法之一就是尽量将变量局部化。但是与扩充变量的作用域相比，减少变量的作用域是非常困难的。所以在一开始考虑变量的作用域时，先将其局限于某个特定循环，然后是某个子程序，其次成为某个类的private变量，protected变量，再其次对package可见，最后才是全局变量。

====10.5持续性（葛川川）====
=====避免数据持续性出错=====
*1加入调试代码或直接检查关键变量的合理取值，如果变量未合理取值，程序发警告信息告知。
 2自己测试，准备抛弃变量时给他赋上不合理的值，判断结果。
 3当数据没有持续性，去编写代码。
 4使用数据之间声明和初始化。

====10.7数据类型和控制结构之间的关系（肖秀丽）====
=====复杂数据类型的简单表述=====
*三类数据（序列型数据、选择型数据、迭代型数据），控制结构（顺序语句、if和case、循环结构）将其变成简单的构造块后，组合起来。

====10.8为变量指定单一用途（肖秀丽）====
=====数据，变量规范=====
*每个变量只用于单一用途
 避免让代码具有隐含含义
 确保使用了所以已声明的变量

=== 第11章 变量名的力量（段宗超 甘建伟 李勇）===
====11.1选择好变量名的注意事项（段宗超）====
如何建议一个好的变量名
*一个好的变量名是可读的，易记的和恰如其分的。
*为变量命名时最重要的是该名字要完全，准确地描述出该变量所代表的事物。
就如同“当前日期”这一变量，用currentDate或todayDate就比用date要好，我们可以直接读出前两个变量名所表示出来的意思，而date所表示出来的意思不够准确。
*用最适合的名字长度。
太短的变量名无法传递足够的信息，太长的变量名如numberOfPeopleOnTheChinaOlympicTeam，虽然我们可以很明白的读出这个变量名所代表的意思，但是这样的变量名太长不易书写和记录，同时也会使程序的视觉结构变得模糊不清。

====11.2为特定类型的数据命名（段宗超）====
本节主要介绍了循环变量、状态变量、临时变量、布尔变量、枚举类型和具名常量的命名细节。
*循环变量
在计算机语言中，循环会被用到很多，如果这个循环变量只在当前循环中使用，就可以使用i,j和k这些约定俗成的变量名。当这个变量要在循环外使用或者这个循环不只几行，我们就得取一
个比更i有意义的变量名。
*状态变量
状态变量用于描述程序的状态，将标记（flag）看作为一个状态变量，被标记的名字中不应该含有flag。
*临时变量
临时变量用于储存计算的中间结果，常被赋予temp，x等一些模糊的名字，当我们程序中有多个临时变量时，就得警惕我们是否懂得了这个变量所代表的含义。
*布尔变量
布尔变量是有两种逻辑状态的变量，它包含两个值：真和假。所以在给布尔变量命名的时候，就得考虑到变量名的准确性。以下是一些经典的布尔变量名：done、error、found、success和ok。
*枚举变量
使用枚举类型时，通过使用组前缀来明确表示该类型的成员都属于一个组，例如plant_Earth和plant_Mars，我们就可以很清晰的明白这两个变量名都是星球。
*常量
为常量命名时，应该根据该常量所表示的具体含义来命名。
====11.4非正式命名规则（甘建伟）====
*命名规则是为了区分变量，对象和类型，统一整洁的命名规则能提高程序的可读性。
如：在一个项目中有几个集合，如果只是随便命名为list1，list2，可读性不高。若以userList，employeeList命名，可读性提高。

*命名规则标识一些重要的点，如标识出全局变量，防止滥用，出现问题。

*Java的部分命名原则
常量全部大写并以下划线分隔（ALL_USER_SQL）;变量名和方法名第一个单词首字母小写后续单词首字母大写且不以下划线分（variableOrRoutineName);访问子程序使用get与set前缀

*命名规则没有绝对的，但是规范起来可以让它变得更好。

====11.5标准前缀（甘建伟）====
*标准前缀是对具有通用含义的前缀标准化，为数据命名提供简洁，一致，可读性好的方法。通常由用户自定义类型的缩写和语义前缀组成。
用户自定义类型缩写用于标识被命名对象或变量的数据类型。
语义前缀是描述变量或对象是如何使用的。如‘c’表示数量，‘g’表示全局变量
*标准前缀的优点：由于很多名字都已经标准化，因此程序或类内需要记忆的名字更少了。
*标准前缀的缺陷：在使用标准前缀的同时忽略了给变量起有意义的名字，可读性降低。

====11.6创建具备可读性的短名字（李勇）====
*因环境的需求要你创建简短的名字，应注意其方法：可以通过消除冗余的单词，或使用简短的同义词等策略来创建。
*以下有几种缩写的一般指导原则
 使用标准的缩写方式，使用每个单词的第一个或前几个字母
 去掉虚词（and，or,the）等，去掉非前置元音。（computer变成cmptr，screen变成scrn）等
 应使用每个单词的前几个字母，并保留每个单词的第一个和最后一个字母
 保留每个音节中最引人注意的发音。，并确保不改变变量的含义

*创建缩写中的避免犯错的规则
 缩写得一致并能读出的名字，并且不在每个单词中删除一个字符的方式来缩写
 在代码中缩写对照表解释极短的名字的含义

*本原则的核心问题，是方便代码同方便阅读代码两种理念的差异。正确用好了它，可提高阅读
代码的方便性。


====11.7应该避免的名字（李勇）====
1.变量名避免的指导原则
*避免使用令人误解的名字。
*避免使用具有相似含义的名字。
*避免使用发音相近的，又有使用数字的名字。
*避免使用标准类型，变量和子程序的名字。
*避免在名字中包含易混淆的字符。
2.要点
*好的变量名是提高程序可读性的一项关键要素。
*名字要尽可能具体，采用变量的命名规则。
*确保所取名更侧重阅读而不是编写。

===第12章 基本的数据类型（徐钰颖 钟红飞 邵志超 闫玲玲）===
====12.1数值概论 （徐钰颖）====
1使用数的时候要避免使用“神秘数值",就是没有经过定义的数字。
*它会使修改变得更可靠，就是不会让你漏掉某个数值。
*会让修改变得容易，当你修改数字时如果你用了神秘数值你就需要把它全部找出来，如果你用了具名常量，只需要改一下该常量的定义即可。
2预防除零错误，就是写代码的时候要考虑分母是否可能为0，防止错误的发生。<br>
3避免混合类型的比较（比如浮点数和整数),要自己手动进行类型转换，你也会准确的知道比较的是什么了。<br>
4最后还要注意编译器的警告，当你写代码的时候出错时，通过编译器警告来发现问题要比你自己找容易的多。
====12.2整数 （徐钰颖）====
在用整数的时候要注意以下三点。
*检查整数除法，当你使用整数的时候，其结果会随语言的不同而不同，比如10*（9/10）=（10*9）/10=9。但在整数运算是10*（9/10）=0，因为整数除法9/10等于0。此类问题的解决方法就是重新安排表达式的数序。
*检查整数溢出，在做整数的乘法和加法时，要考虑最大整数，每个整数类型的取值范围不同，32位的计算机和64位的也是不同的。
*检查中间结果的溢出，就是检查每个整数的最大值，就比如A*B/C,如果A和B都是最大值，A*B的结果就已经溢出了，从而导致结果也是错误的。
====12.3浮点数 （徐钰颖）====
使用浮点数时应遵循的指导原则
*避免数量级相差巨大的数之间的加减运算。32位浮点数，1000000.00+0.1可能会得到1000000.00，因为32位不能给你足够的有效位数包容。怎么解决呢，就是先从最小值开始相加，这样做并不能消除舍入问题，但是能使影响减少到最低。
*避免等量判断。很多相等的浮点数值并不一定相等，用不同方法求同一数值结果不一定相同。
坏代码
  double nominal =1.0；//变量nominal是个64位实数
  double sum =0.0；
  for （int i =0；i <10；i++ ） {
  sum +=0.1；//sum是10*0.1，应当等于1.0
  }
  if（nomainal == sum）{//这是错误的比较
  System.out.println(“Numbers are the same.”）；
  }
  else{
  System.out.println(“Numbers are different.”）；
  }
结果是Numbers are different.
好代码
  final double ACCEPTABLE_DELTA =0.00001；
  boolean Equals(double Term1,double Term2){
  if (Math.abs(Term1-Term2)<ACCEPTABLE_DELTA){
  return true;
  }
  else{
  return false；
  }
  }
结果是Numbers are the same.
*处理舍入误差问题。
1换用精准度更高的变量类型。<br>
2换用二进制编码的十进制变量。<br>
3把浮点变量变成整型变量。

====12.4字符和字符串（钟红飞）====
  *避免使用“神秘数值(magic number）
    神秘数值是在程序中出现的并且没有经过解释的数值文字量。如果你使用的编程语言支持具名常量，那么就用它来代替神秘数值，如果你无法使用具名常量，在可行的情况下应该使用全局变量。避免使用神秘数值，可以增强代码的可读性，并且使修改变得更容易，更可靠。
Java中读取字符和读取字符串的差别？
   *FileInputstream.read()读取的是单个字符,是ASCII码表所能表示的字符,要是要读取像有汉字等其他ASCII不能表示的，就要用FileReader,它读取的是java支持的字符集。另外，像要是读取图片,pdf,psd等这些东西的话，就要用FileInputStream,即文件字节流。应为存在计算机中的就是二进制，是ASCII表示的。要是读取有汉字的.txt,.就用FileReader。其实用的较多的是BuffereReader,进行逐行读取。
避免使用字面形式的字符串的原因？
  *1对于程序的名字、命令名称、报表标题等常常出现的字符串，有时可能需要修改它们的内容。
  *2在翻译使存放在字符串资源文件中字符串要比翻译存在于代码中的字符串容易得多。
  *3字符串的字面表示形式通常都会占用较多的存储空间。
  *4字符和字符串的字面表示形式的含义是模糊的。
字符串指针和字符数组之间的差异？
  *1字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘\0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。
  *2每个元素的值都可以改变。而字符串指针指向的是一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变。


====12.8 数组（Arrays）闫玲玲====

*最简单和最常用的结构化数据类型。（使用数据提出的建议）
::确认所有数组没有超出数组的边界。
::考虑由容器来取代数组。
::检查数组的边界点。
::若是多维数组，则确认下标使用顺序正确。
::提防下标串话。
====12.9 创建你自己的类型（类型别名）闫玲玲====
*创建你自己的类型（类型别名）
::是语言所能赋予自己一种最强有力的、最有助于澄清你对程序的理解的功能之一。
::能很好地隐藏信息，把客户所要求创建的类型和尽量避免输错可能的隐藏信息结合起来。
:*创建自定义数据类型的指导原则：
:::给所创建的类型取功能导向的名字
:::避免使用预定义类型
:::不要重定义一个预定义类型
:::定义替类型以便于移植
:::考虑创建有个累而不是使用typedef
*常犯错误：
::在运用数组中，大多数人常常随机使用数组。
:::其解决方法可以用集合、栈、和队列来等按顺序存取元素的数组结构来取代数组。
::定义类型的时候容易定义成被预定义的类型。
:::解决方案是使用能表现现实世界问题的类型名。

===第13章 不常见的数据类型（王西亚 范子高）===

====13.1 结构体（王西亚）====

1 结构体类型： C/C++中允许用户定义一组包含若干个类型不同（或相同）的数据项的数据类型，称之为结构体。

2 结构体的作用:
*用结构体来明确数据关系。结构体把相关联的一组数据项聚集在一起。
::坏代码
 //下面一组变量很难看懂
 name=inputName
 address=inputAddress
 phone=inputPhone
 title=inputTitle
 department=inputDepartment
 bonus=inputBonus

::好代码
 //下面代码引入结构体使得数据关系变得更加清晰
 employee.name=inputName  //雇员信息
 employee.address=inputAddress //雇员信息
 employee.phone=inputPhone  //雇员信息

 supervisor.title=inputTitle  //主管信息
 supervisor.department=inputDepartment //主管信息
 supervisor.bonus=inputBonus //主管信息
*拥结构体简化对数据块的操作。对结构体执行操作要比对各个元素执行同样的操作容易的多。
*用结构体来简化参数列表。我们可以将相关的元素组织到一个结构体中，把他当做一个整体传递出去。
::坏代码
 HardWayRoutine(name,address,phone,ssn) //笨拙的子程序调用，容易犯错
::好代码
 EasyWayRoutine(employee) //优雅的子程序调用，降低犯错概率
*用结构体减少维护。对结构体的修改只会导致对程序做很小的修改，减少错误。
3声明符号：通过 struct 关键字。

4定义结构体变量的方法：struct 结构体类型名{成员列表}
*其中“结构体类型名”用来作结构类型的标志。
*每个“成员”也称为一个域，成员表又叫做“域表”。
例如：
struct stu / *定义学生结构体类型* /
{
    char name[20]; / * 学生姓名* /
    char sex; / * 性别* /
    long num; / *学号* /
    float score[3]; / * 三科考试成绩* /
 };
5声明结构体类型的位置一般放在文件开头，在所有函数之前，是一种良好的编程风格。

6类型与变量是不同的概念：只能对结构体中的成员赋值，不能对结构体类型赋值。

7结构体变量中的成员（即“域”）可以单独使用，它的作用与地位相当于同类型的普通变量。
====13.3 全局数据(范子高)====
全局数据区别于类中的全局变量。
=====全局数据的常用问题=====
*在对数据进行操作时会无意间进行全局数据的操作，但是以为全局数据不会改变。
*在使用别名时，实际上全局数据和别名所指向的使用一个数据。在例子中输入为全局变量进行输出时，inputVar被初始化为0，操作后赋值给全局数据globalVar，所以在输出前两个值均为5。原因在于你是用的别名和输入的全局数据名一样。
*在多线程程序大量出现的情况下，出现了全局数据如果在多个子程序中进行使用，那么一旦对数据进行了更改，那么原来的程序所要表达的方法将会改变。
*全局数据将会加大代码重写的难度，在你重写程序时，会出现是否依旧使用全局数据的难题，如果选择继续使用，那么在你以后每一次对这个程序进行重写的过程中你都需要使用全局数据，另一种方法就是把需要的数据以不适用全局数据的方式表示出来。
*全局数据的加载实在程序开始运行时就进行加载了，那么就出现了问题，如果在一个程序中使用了其他程序中的全局数据，那么如何决定全局数据加载的顺序。
*全局数据破坏了代码的模块化设计，在模块化设计中就是要减少代码的耦合，而全局数据的使用与这个思想相违背。
=====全局数据的缺点=====
*用于保存全局数值，在整个程序中都不进行修改操作，只对其数值进行读取。
*用于模拟具名常量，类似于java中用final修饰的常量。
*用于模拟枚举类型，将一个对象中的所有数据逗列举出来。
*可以简化对于一个常用数据的使用，在对于一个数据频繁使用的时候，把它定义为全局数据，将它为数不多的使用子程序集中在一起，可以方便进行维护。
*用于消除流浪数据，我的理解是类似与java中的exception message，在所有的方法中都可能出现message，但是不一定在每一个都会抛出exception，所以将它定义为全局数据，在所有的子程序中都可以使用，不会因为不使用而没有意义。