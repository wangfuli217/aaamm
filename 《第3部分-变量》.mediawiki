=== 参加人员 ===
邵志超  王西亚  徐超  段宗超  闫玲玲  徐钰颖  范子高  肖秀丽  葛川川  钟红飞  李勇  甘建伟  宋文喆

=== 第10章 使用变量的一般事项（葛川川 徐超 宋文喆 肖秀丽）===
====10.1数据认知（葛川川）====
=====积累数据类型的必要性=====
*1数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。
*2如果知道变量确实总是存储特定类型的数据，声明了这种特定类型的变量，以更高的效率处理这个数据。例如，存储人名的变量最好表示成 String 数据类型，因为名字总是由字符组成。
充分利用内存并提高处理效率
====10.1数据认知心得（宋文喆）====
=====能提高安全性的数据变量=====
*1我们常用的private和static，private只有在定义类的时候才能在类中引用，其他类不能直接访问，而static修饰的对象数据在全局是唯一的，一改都改。所以在实际开发中可以活用这些变量来提高代码的安全性。
*2以下有个static容易出错的例子：
   static int a;
   public static void main (String[]args){
   static int a;
   System.out.println(a);
   }
这里把a设为了全局变量，在main()函数中 static int a;然后调用时，a对象的内存空间已存在了，所以就会在这报错，staic 作用是共享同一块内存空间。
====10.2轻松掌握变量定义（葛川川）====
=====使隐式声明不出错=====
隐式声明:当你使用一个未声明的变量的时候，编译器会自动为你声明该变量（1取决于你的编译器设置2编程语言支持隐式声明）
*1关闭隐式声明
*2声明全部变量
*3遵循某种命名规则
*4检查变量名
=====隐式声明心得（宋文喆）=====
*如果在函数中隐式声明了某个变量，那该变量将成为全局变量
例如JScript中：
    function foo1(){
    for(i=0;i<10;i++) ;   //i隐式声明
    }
    function foo2(){
    alert(i);
    }
    foo1();
    foo2();   //最后的输出结果是10
*在写JScript时虽然系统允许隐式变量声明使用，但我们还是应该进行显式的变量声明，尤其是对习惯的循环变量等，以保证它的使用范围。
*隐式声明带来了些许的方便，但却被认为有损于程序的可读性，因为它可能会带来隐藏的错误，Bug。


====10.2轻松掌握变量定义心得（李勇）====
*隐式变量声明是个危险的特性之一，那么避免该现象的发生，可关闭隐式声明，即强迫在使用前先做出声明。
*要声明全部的变量，可以预防一些错误。
*遵循建立有规则的命名，并检查变量名。有助于你声明了的但还没使用的变量。

====10.3变量初始化原则心得（邵志超）====
*变量初始化原则的详细说明：变量的初始化在之后的逻辑代码中有关数据的操作时起着很关键的作用，一般的代码编写时都是在定义声明变量的同时赋予其初始值：如下列举的几种类型变量的初始化；
    String s={"a","abc"," ","实践"}; 
    int[]a={1,23,42};
    （double）float b=3.14d;//有可能在某些工具中默认是double类型的精度要求
  //code using s,a,b....
理想情况下是：声明初始化的变量最好是满足就近原则（java代码为例）
*也存在关键字 final ，static，所修饰的常量，这种类型的变量的初始化一般是某些公有固定属性或是成员的固定私有属性的定义。
*具名常量的初始化 
const blue =3;
const red =4;
Type prefix
be (blue) as String;
rd (red) as int ;
End Type
将对应的变量值赋予别名，在之后的方法中调用时可以根据别名找到对应的变量值，更改变量值时也很方便，只需要在定义时修改对应要求的数值即可。

====10.3变量初始化原则心得（宋文喆）====
=====初始化变量应养成的习惯=====
*1在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量。（何桑举过的例子，可以减少内存的使用）
*2直到变量即将被使用时再为其赋值。
*3把相关语句放在一起。
*4把相关语句组提取成单独的子程序。
*'''''坏代码'''''
   int a = 0;
   double b = 0;
   boolean c = false;
   // other code 
   // code using a
   ...
   // code using b
   ...
   // code using c
   ...      //此时c有可能已经被修改了
   while(!c)   
   ...
*'''''好代码'''''
   int a = 0; 
   // code using a
   ...
   double b= 0;
   // code using b
   ...
   boolean c= false;
   // code using c
   while (!c)
   ...         //符合就近原则的初始化

====10.4 作用域（徐超）====

=====变量引用局部化的好处=====
*衡量变量不同的引用点的靠近程度的一个概念是“跨度”
'''''java示例：'''''

 a = 0;
 b = 0;
 c = 0;
 a = b + c;

在上例中，对a的第一次引用和第二次引用之间存在两行代码，因此a的跨度是2；以此类推，b的跨度是1，c的跨度是0。当变量集中在一起时，使得代码阅读者每次只关注一部分代码；反之当变量的距离比较远，就要来回翻阅，如果在其中有新代码加入，很容易使阅读代码的人忘记了该变量的值。
所以把变量引用点集中起来主要好处就是提高了程序的可读性。

=====缩短变量“存活”时间的好处=====
*减小攻击窗口
存活时间是指一个变量存在期间所跨越的语句总数，开始于引用该变量的第一条语句，结束于引用其的最后一条语句。保持变量短的存活时间的好处是减小攻击窗口，当你修改一个变量位置之间的区域，该变量发生错误的可能性大大降低。

*减少初始化错误
修改程序时，经常会把直线型代码改为循环，这时把初始化的代码和循环部分放在一起，可以减少因修改代码而导致初始化错误的可能性。

*降低代码的理解难度
假设一个变量在第1行被赋值，到第50行才再次引用，那么该变量在第1-45行范围内一直被使用；如果该变量在第1行被赋值后，第2行就引用了，那么在关注这个变量时，只需关注很少的一部分代码，阅读者也更容易理解代码。

*易拆分
当变量的多次引用靠的非常近，那么把相关代码拆分重构成子程序时，难度大大降低。

=====减小作用域的做法=====
*在循环开始前就对变量进行初始化
这种做法的好处是，在你修改循环时，会很容易记住要对循环的初始化代码进行修改，并且当需要在循环之外再加一层循环时，这样的初始化对循环的每一个执行都是有效的。

*在变量即将使用时为其赋值
这种做法的好处是，很方便就找出这个变量的赋值处。
 C++良好示例：良好的变量声明与初始化
 int receiptIndex = 0;
 float dailyReceipts = TodaysReceipts();
 double totalReceipts = TotalReceipts( dailyReceipts );

*相关的语句集中到一起
这样做的好处是，更容易方便的寻找它们。
 C++坏例子：使用两套变量——让人困惑的做法
 void SummarizeData( ... ) {
  ...
  GetOldData( oldData, &numOldData );
  GetNewData( newData, &numNewData );
  totalOldData = Sum( oldData, numOldData );
  totalNewData = Sum( newData, numNewData );
  PrintOldDataSummary( oldData, totalOldData, numOldData );
  PrintNewDataSummary( newData, totalNewData, numNewData );
  SavaOldDataSummary( totalOldData, numOldData );
  SavaNewDataSummary( totalNewData, numNewData );
 }
在上例中，需同时关注6个变量。

 C++好例子：使用两套变量——更容易理解的做法
  void SummarizeData( ... ) {
  GetOldData( oldData, &numOldData );
  totalOldData = Sum( oldData, numOldData );
  PrintOldDataSummary( oldData, totalOldData, numOldData);
  SaveOldDataSummary( totalOldData, numOldData );
  ...
  GetNewData( newData, &numNewData );
  totalNewData = Sum( newData, numNewData );
  PrintNewDataSummary( newData, totalNewData, numNewData);
  SaveNewDataSummary( totalNewData, numNewData ); 
  ...
 }
这段代码就更容易理解。

*相关语句拆分、提取组成成单独的子程序
其他条件相同，一个较短子程序中的变量通常比较长子程序中变量的跨度和存活时间要短，那么把一组相关语句拆分组成小的子程序，自然作用域也会缩小。

*变量的作用域由小变大
减少作用域的方法之一就是尽量将变量局部化。但是与扩充变量的作用域相比，减少变量的作用域是非常困难的。所以在一开始考虑变量的作用域时，先将其局限于某个特定循环，然后是某个子程序，其次成为某个类的private变量，protected变量，再其次对package可见，最后才是全局变量。

====10.5 持续性（徐超）====

=====持续性的多种形态=====

*特定代码段或子程序的生命周期
:;例：某一个for循环中声明的变量

*只要你允许，它就会持续下去
:;例：Java中，用new创建的变量会持续到被垃圾站回收

*程序的生命周期
:;例：大多数的全局变量

*永远持续
:;例：储存在数据库中，程序多次执行后仍然存在的数据

=====持续性的相关问题=====

变量的生命周期具有难以预料性，有时候变量过期，但有时候又会有旧的值存在变量中。解决上述问题，有如下好的做法：
*程序中加入调试代码或断言
:这样如果变量取值不合理，就会发出警告信息。

*准备抛弃变量时给它们赋“不合理的数值”
:例：在删除指针后，可以给它赋值为null。

*编写代码时要假设数据不具有持续性
:例：某个变量在你退出子程序时具有某个特定值，那当你下次进入该子程序时，就不要假定该变量仍具有该值。该例不适用于某些语言中确保变量在子程序多次调用间维持其值的特性，例如C++和Java中的static。

*在使用数据之前给予其声明和初始化
:当发现某项数据与初始化位置相距较远，就需要格外注意该数据。


====10.5持续性（葛川川）====
=====避免数据持续性出错=====
*1加入调试代码或直接检查关键变量的合理取值，如果变量未合理取值，程序发警告信息告知。
 2自己测试，准备抛弃变量时给他赋上不合理的值，判断结果。
 3当数据没有持续性，去编写代码。
 4使用数据之间声明和初始化。

====10.6绑定时间（葛川川）====
=====降低复杂度并满足软件需求=====
*绑定时间↑ 灵活性↑ 代码复杂度↑ 出错率↑
合理利用具名常量，引入足够的灵活性来满足软件需求，不增加需求范围以外的任何灵活性及相应的复杂度
绑定时间三种如下：
1在编写代码时绑定其值的变量
2在编译时绑定其值的变量
3在运行时绑定其值的变量

====10.6 绑定时间（徐超）====
*绑定时间的定义
**变量与其值绑定在一起的时间
*绑定时间对灵活性和复杂性的影响
**一般情况下，绑定时间越晚，代码的灵活性越高
 绑定时间最早的Java示例：在编写代码时，变量绑定值
 titleBar.color = 0xFF;//0xFF is hex value for color blue

 绑定时间稍后的Java示例：在编译时，变量绑定值
 private static final int COLOR_BLUE = 0xFF;
 private static final int TITLE_BAR_COLOR = COLOR_BLUE;
 ...
 titleBar.color = TITLE_BAR_COLOR;

 绑定时期较晚的Java示例：在运行时，变量绑定值
 titleBar.color = ReadTitleBarColor();

第一个例子中，0xFF是硬编码程序中的值，在编写代码时就会被绑定到变量上。硬编码技术较差，如果要对该值进行修改，那么新值无法与那些必须和它一样的值保持一致；第二个例子中，TITLE_BAR_COLOR是一个具名常量，在编译时，它会被替换为一个数值，它比0xFF反映出的信息要多，可读性强，并且对其一处的改动能对所有位置都生效，同时在运行期，还不会影响性能；第三个例子中，ReadTitleBarColor()能在运行期间读取数值，而且只需通过修改ReadTitleBarColor()子程序读取数据的原内容，就可以改变titleBar.color，该代码可读性与灵活性更强。

*绑定时间越早，复杂性越低，反之复杂性越高
**一般来说，绑定时间越早灵活性越差，但复杂度也会越低；代码灵活性越强，代码也会越复杂，相应的出错几率也会增加。成功软件的开发需要代码的复杂程度降到最低，对程序员也就有相应的要求。一个程序高手，会根据代码需求，相应的来改变代码的灵活性，同时，不会有需求之外的任何操作。

====10.7数据类型和控制结构之间的关系（肖秀丽）====
=====复杂数据类型的简单表述=====
*三类数据（序列型数据、选择型数据、迭代型数据），控制结构（顺序语句、if和case、循环结构）将其变成简单的构造块后，组合起来。

====10.8为变量指定单一用途（肖秀丽）====
=====数据，变量规范=====
*每个变量只用于单一用途
 避免让代码具有隐含含义
 确保使用了所以已声明的变量

=== 第11章 变量名的力量（段宗超 甘建伟 李勇）===
====11.1选择好变量名的注意事项（段宗超）====
如何建议一个好的变量名
*一个好的变量名是可读的，易记的和恰如其分的。
*为变量命名时最重要的是该名字要完全，准确地描述出该变量所代表的事物。
就如同“当前日期”这一变量，用currentDate或todayDate就比用date要好，我们可以直接读出前两个变量名所表示出来的意思，而date所表示出来的意思不够准确。
*用最适合的名字长度。
太短的变量名无法传递足够的信息，太长的变量名如numberOfPeopleOnTheChinaOlympicTeam，虽然我们可以很明白的读出这个变量名所代表的意思，但是这样的变量名太长不易书写和记录，同时也会使程序的视觉结构变得模糊不清。

====11.2为特定类型的数据命名（段宗超）====
本节主要介绍了循环变量、状态变量、临时变量、布尔变量、枚举类型和具名常量的命名细节。
*循环变量
在计算机语言中，循环会被用到很多，如果这个循环变量只在当前循环中使用，就可以使用i,j和k这些约定俗成的变量名。当这个变量要在循环外使用或者这个循环不只几行，我们就得取一
个比更i有意义的变量名。
*状态变量
状态变量用于描述程序的状态，将标记（flag）看作为一个状态变量，被标记的名字中不应该含有flag。
*临时变量
临时变量用于储存计算的中间结果，常被赋予temp，x等一些模糊的名字，当我们程序中有多个临时变量时，就得警惕我们是否懂得了这个变量所代表的含义。
*布尔变量
布尔变量是有两种逻辑状态的变量，它包含两个值：真和假。所以在给布尔变量命名的时候，就得考虑到变量名的准确性。以下是一些经典的布尔变量名：done、error、found、success和ok。
*枚举变量
使用枚举类型时，通过使用组前缀来明确表示该类型的成员都属于一个组，例如plant_Earth和plant_Mars，我们就可以很清晰的明白这两个变量名都是星球。
*常量
为常量命名时，应该根据该常量所表示的具体含义来命名。
====1.3命名规则的力量（段宗超）====
命名规则有何好处：
*要求你更多地按规矩行事
*有助于在项目之间传递知识
*有助于在新项目中更快速地学习代码
*有助于减少名字更生
*弥补程序语言的不足之处
*强调变量相关之间的关系

何时采用命名规则：
*多个程序员合作开发一个项目时
当多个程序员开发一个项目时，建立命名规则让合作更加轻松，有利于提高代码质量。
*将一个程序转交给另一位程序员进行维护和修改的时候
就目前来说，上述事件是不可避免的，为了让自己的代码能够为其他人读懂，建立命名规则是很有必要的。
*leader评估所写代码的时候
当我们所coding的代码需要交由上级review的时候，好的命名规则让代码清晰易懂。
*当程序太大的时候
程序太大时，必须将代码规范起来，利于后期的维护和修改。
*当一段代码的生命周期过长时
我们有可能会遇到这种情况：写了一段代码，然后过相当一段长的时间后才会对这段代码进行下一步的coding，就得规范命名让我们及时很长时间没看这段代码还是能很快的上手。
*一些不常见的术语用在程序中
如果一些不常见的术语用在了代码中并且我们没有进行相关的规范命名，那么就会发现这些术语在程序中会显得格外别扭。

综上，采用命名规则让代码的可读性增加，可以程序员在代码后期的修改和维护中节省不少的时间。

====11.4非正式命名规则（甘建伟）====
*命名规则是为了区分变量，对象和类型，统一整洁的命名规则能提高程序的可读性。
如：在一个项目中有几个集合，如果只是随便命名为list1，list2，可读性不高。若以userList，employeeList命名，可读性提高。

*命名规则标识一些重要的点，如标识出全局变量，防止滥用，出现问题。

*Java的部分命名原则
常量全部大写并以下划线分隔（ALL_USER_SQL）;变量名和方法名第一个单词首字母小写后续单词首字母大写且不以下划线分（variableOrRoutineName);访问子程序使用get与set前缀

*命名规则没有绝对的，但是规范起来可以让它变得更好。

====11.5标准前缀（甘建伟）====
*标准前缀是对具有通用含义的前缀标准化，为数据命名提供简洁，一致，可读性好的方法。通常由用户自定义类型的缩写和语义前缀组成。
用户自定义类型缩写用于标识被命名对象或变量的数据类型。
语义前缀是描述变量或对象是如何使用的。如‘c’表示数量，‘g’表示全局变量
*标准前缀的优点：由于很多名字都已经标准化，因此程序或类内需要记忆的名字更少了。
*标准前缀的缺陷：在使用标准前缀的同时忽略了给变量起有意义的名字，可读性降低。

====11.6创建具备可读性的短名字（李勇）====
*因环境的需求要你创建简短的名字，应注意其方法：可以通过消除冗余的单词，或使用简短的同义词等策略来创建。
*以下有几种缩写的一般指导原则
 使用标准的缩写方式，使用每个单词的第一个或前几个字母
 去掉虚词（and，or,the）等，去掉非前置元音。（computer变成cmptr，screen变成scrn）等
 应使用每个单词的前几个字母，并保留每个单词的第一个和最后一个字母
 保留每个音节中最引人注意的发音。，并确保不改变变量的含义

*创建缩写中的避免犯错的规则
 缩写得一致并能读出的名字，并且不在每个单词中删除一个字符的方式来缩写
 在代码中缩写对照表解释极短的名字的含义

*本原则的核心问题，是方便代码同方便阅读代码两种理念的差异。正确用好了它，可提高阅读
代码的方便性。

====11.6创建具备可读性的短名字（甘建伟）====

*不要从每个单词中删除一个字符的方式来缩写，键入一个字符不会有什么额外的工作，而节省一个字符的却可能造成可读性的损失。
*创建的名字的缩写应该自己能够读出来。
*避免会有误读的名字缩写。如表示以B结尾，用ENDB比BEND更好。
*名字对于代码读者的意义比对作者更重要。
*创建能够在极短时间了解名字的含义的名字。

====11.7应该避免的名字（李勇）====
1.变量名避免的指导原则
*避免使用令人误解的名字。
*避免使用具有相似含义的名字。
*避免使用发音相近的，又有使用数字的名字。
*避免使用标准类型，变量和子程序的名字。
*避免在名字中包含易混淆的字符。
2.要点
*好的变量名是提高程序可读性的一项关键要素。
*名字要尽可能具体，采用变量的命名规则。
*确保所取名更侧重阅读而不是编写。

====11.7应该避免的名字（甘建伟）====
*名字的含义或者字形相似应该避免使用。
如：fileNumber与fileIndex；clientRecs与clientReps；

*避免在某些名字后面加数字做区分的名字（如file1或file2），避免使用易拼写错误的单词做名字。
*尽量使用与变量等含义相关的名字，增加可读性，避免使用过于随意的名字。

===第12章 基本的数据类型（徐钰颖 钟红飞 邵志超 闫玲玲 李勇）===
====12.1数值概论 （徐钰颖）====
1使用数的时候要避免使用“神秘数值",就是没有经过定义的数字。
*它会使修改变得更可靠，就是不会让你漏掉某个数值。
*会让修改变得容易，当你修改数字时如果你用了神秘数值你就需要把它全部找出来，如果你用了具名常量，只需要改一下该常量的定义即可。
2预防除零错误，就是写代码的时候要考虑分母是否可能为0，防止错误的发生。<br>
3避免混合类型的比较（比如浮点数和整数),要自己手动进行类型转换，你也会准确的知道比较的是什么了。<br>
4最后还要注意编译器的警告，当你写代码的时候出错时，通过编译器警告来发现问题要比你自己找容易的多。

====12.1数值概论 （李勇）====
*"神秘数值"少使用
*需要的话，使用硬编码0和1 
*除零错误的预防，考虑分母是否为零
*类型转换变得更明显，混合类型比较。
*警惕编译器的警告
====12.2整数 （徐钰颖）====
在用整数的时候要注意以下三点。
*检查整数除法，当你使用整数的时候，其结果会随语言的不同而不同，比如10*（9/10）=（10*9）/10=9。但在整数运算是10*（9/10）=0，因为整数除法9/10等于0。此类问题的解决方法就是重新安排表达式的数序。
*检查整数溢出，在做整数的乘法和加法时，要考虑最大整数，每个整数类型的取值范围不同，32位的计算机和64位的也是不同的。
*检查中间结果的溢出，就是检查每个整数的最大值，就比如A*B/C,如果A和B都是最大值，A*B的结果就已经溢出了，从而导致结果也是错误的。
====12.3浮点数 （徐钰颖）====
使用浮点数时应遵循的指导原则
*避免数量级相差巨大的数之间的加减运算。32位浮点数，1000000.00+0.1可能会得到1000000.00，因为32位不能给你足够的有效位数包容。怎么解决呢，就是先从最小值开始相加，这样做并不能消除舍入问题，但是能使影响减少到最低。
*避免等量判断。很多相等的浮点数值并不一定相等，用不同方法求同一数值结果不一定相同。
坏代码
  double nominal =1.0；//变量nominal是个64位实数
  double sum =0.0；
  for （int i =0；i <10；i++ ） {
  sum +=0.1；//sum是10*0.1，应当等于1.0
  }
  if（nomainal == sum）{//这是错误的比较
  System.out.println(“Numbers are the same.”）；
  }
  else{
  System.out.println(“Numbers are different.”）；
  }
结果是Numbers are different.
好代码
  final double ACCEPTABLE_DELTA =0.00001；
  boolean Equals(double Term1,double Term2){
  if (Math.abs(Term1-Term2)<ACCEPTABLE_DELTA){
  return true;
  }
  else{
  return false；
  }
  }
结果是Numbers are the same.
*处理舍入误差问题。
1换用精准度更高的变量类型。<br>
2换用二进制编码的十进制变量。<br>
3把浮点变量变成整型变量。

====12.4字符和字符串（钟红飞）====
  *避免使用“神秘数值(magic number）
     神秘数值是在程序中出现的并且没有经过解释的数值文字量。如果你使用的编程语言支持具名常量，那么就用它来代替神秘数值，如果你无法使用具名常量，在可行的情况下应该使用全局变量。避免使用神秘数值，可以增强代码的可读性，并且使修改变得更容易，更可靠。
  *Java中读取字符和读取字符串的差别？
     FileInputstream.read()读取的是单个字符,是ASCII码表所能表示的字符,要是要读取像有汉字等其他ASCII不能表示的，就要用FileReader,它读取的是java支持的字符集。另外，像要是读取图片,pdf,psd等这些东西的话，就要用FileInputStream,即文件字节流。应为存在计算机中的就是二进制，是ASCII表示的。要是读取有汉字的.txt,.就用FileReader。其实用的较多的是BuffereReader,进行逐行读取。
避免使用字面形式的字符串的原因？
*对于程序的名字、命令名称、报表标题等常常出现的字符串，有时可能需要修改它们的内容。
*在翻译使存放在字符串资源文件中字符串要比翻译存在于代码中的字符串容易得多。
*字符串的字面表示形式通常都会占用较多的存储空间。
*字符和字符串的字面表示形式的含义是模糊的。
*字符串指针和字符数组之间的差异？
*字符串指针变量本身是一个变量，用于存放字符串的首地址。而字符串本身是存放在以该首地址为首的一块连续的内存空间中并以‘\0’作为串的结束。字符数组是由于若干个数组元素组成的，它可用来存放整个字符串。
*每个元素的值都可以改变。而字符串指针指向的是一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变。
  *在使用字符串一些注意点：
*如果只需要支持一种文字语言，考虑使用ISO8859字符集；如果需要支持多种语言，使用unicode。
*为避免忘记空结束符，把c-style字符串的长度声明为CONSTANT+1
*用null初始化字符串以避免无结束符的字符串。
*首先，在声明字符数组是初始化为0：char EventName[Max+1] = {0};
*其次，使用calloc()而不是malloc()，calloc()负责分配内存并初始化。
====12.5布尔变量（钟红飞）====
*如何将布尔变量转换为字符串变量？
*第一种方法是：
boolean bool = true;
String s = new Boolean(bool).toString();//将bool利用对象封装器转化为对象
s.equals("true");
其中，toString方法是一个继承方法。java中所有的类都是object的继承，object的一个重要方法就是toString，用于将对象转化为字符串。
*第二种方法是：
boolean bool = true;
String s = String.valueOf( bool );


====12.5 布尔变量 （邵志超）====
布尔变量一般使用时都是周围存在判断的时候，换言之将逻辑判断的结果以更加直观可找的某个字段来展现。
//复杂的
if(（document.add()） and ( not input()) and -((min _avg<=Count)and(Count<=min_max)) 
then 
do.....
//简化之后
 file=(document.add()) and (not input())
leCount=(min_avg<=Count)and(Count<=min_max)
then
do....
当然再具体某些情况也可以定义自己的boolean类型，然别人能更直接的看明白你设定这个字段的意义。

====12.6 枚举类型 （邵志超）====
枚举类型适用于定义一类对象中每一个成员参数的数据类型。
提高程序的可读性：
//如下例
boolean flg=www.getClId(int,true,data,false);
这种函数调用里的参数让人看得茫然不知所指，所以才有了枚举类型的应用
// boolean flg=www.getClId(
   userCd,
   work,
   data,
   house  
);
枚举类型的应用也可以让代码的修改变得条理清晰可见，枚举类型也可以用于某些循环的遍历输出结果
将枚举类型的第一个元素留作非法值的意义在于确定那些没有合理初始化的变量（一般可能是为0的情况）。

====12.7 具名常量 （邵志超）====
具名常量，即给某一个或是某一类变量起别名。一般用于程序代码中的某一个可能会变化的参数的修改与调用。
采用具名化变量后只需要修改定义时的参数值即可，不需要在程序中每个调用该参数的地方修改数值。
具名变量的使用可以提高程序的可读性和维护性。
//如下例中字符串的拼接输出
String s = "吃葡萄不吐葡萄皮";
String a = "不吃葡萄倒吐葡萄皮";
System.out.println(s+a);
想要改变控制台的输出内容，只需要在s和a的定义出修改即可。

====12.8 数组（Arrays）闫玲玲====

*最简单和最常用的结构化数据类型。（使用数据提出的建议）
::确认所有数组没有超出数组的边界。
::考虑由容器来取代数组。
::检查数组的边界点。
::若是多维数组，则确认下标使用顺序正确。
::提防下标串话。
====12.9 创建你自己的类型（类型别名）闫玲玲====
*创建你自己的类型（类型别名）
::是语言所能赋予自己一种最强有力的、最有助于澄清你对程序的理解的功能之一。
::能很好地隐藏信息，把客户所要求创建的类型和尽量避免输错可能的隐藏信息结合起来。
:*创建自定义数据类型的指导原则：
:::给所创建的类型取功能导向的名字
:::避免使用预定义类型
:::不要重定义一个预定义类型
:::定义替类型以便于移植
:::考虑创建有个累而不是使用typedef
*为什么创建自己的类型的示例用pascal和ada写的
:: Ada申明如下：
::CurrentTemperature： INTEGER range 0..212;
:包含了下列语句不具备的重要语句信息：
::int temperature；
总结：写一行代码到创建的一个简单数据类型，到创建一个类，是很大的一步，要付出更多努力创建这个类。
*单精度float 和双精度double的区别?
::单精度实数在内存中占32bit 有效数字为6~7位
::双精度实数占内存单元为64bit 有效数字为15~16位
::没有说明时,实型常量是作为双精度处理的,若要使用单精度需在后面加上字母f或F,如123.45f
*常犯错误：
::在运用数组中，大多数人常常随机使用数组。
:::其解决方法可以用集合、栈、和队列来等按顺序存取元素的数组结构来取代数组。
::定义类型的时候容易定义成被预定义的类型。
:::解决方案是使用能表现现实世界问题的类型名。
::所有的数组下标都没有超出数组的边界吗？
:::组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。数组是在程序设计中使用前，要先对数组元素的多少进行定义，也就是确定数组维度和下标的界限，当引用数组时，下标超过定义的范围或维度错误时，就会出现“错误的数组下标或者数组下标维度超出界限”的错误

===第13章 不常见的数据类型（王西亚 范子高）===

====13.1 结构体（王西亚）====

1 结构体类型： C/C++中允许用户定义一组包含若干个类型不同（或相同）的数据项的数据类型，称之为结构体。

2 结构体的作用:
*用结构体来明确数据关系。结构体把相关联的一组数据项聚集在一起。
::坏代码
 //下面一组变量很难看懂
 name=inputName
 address=inputAddress
 phone=inputPhone
 title=inputTitle
 department=inputDepartment
 bonus=inputBonus

::好代码
 //下面代码引入结构体使得数据关系变得更加清晰
 employee.name=inputName  //雇员信息
 employee.address=inputAddress //雇员信息
 employee.phone=inputPhone  //雇员信息

 supervisor.title=inputTitle  //主管信息
 supervisor.department=inputDepartment //主管信息
 supervisor.bonus=inputBonus //主管信息
*拥结构体简化对数据块的操作。对结构体执行操作要比对各个元素执行同样的操作容易的多。
*用结构体来简化参数列表。我们可以将相关的元素组织到一个结构体中，把他当做一个整体传递出去。
::坏代码
 HardWayRoutine(name,address,phone,ssn) //笨拙的子程序调用，容易犯错
::好代码
 EasyWayRoutine(employee) //优雅的子程序调用，降低犯错概率
*用结构体减少维护。对结构体的修改只会导致对程序做很小的修改，减少错误。
3声明符号：通过 struct 关键字。

4定义结构体变量的方法：struct 结构体类型名{成员列表}
*其中“结构体类型名”用来作结构类型的标志。
*每个“成员”也称为一个域，成员表又叫做“域表”。
例如：
struct stu / *定义学生结构体类型* /
{
    char name[20]; / * 学生姓名* /
    char sex; / * 性别* /
    long num; / *学号* /
    float score[3]; / * 三科考试成绩* /
 };
5声明结构体类型的位置一般放在文件开头，在所有函数之前，是一种良好的编程风格。

6类型与变量是不同的概念：只能对结构体中的成员赋值，不能对结构体类型赋值。

7结构体变量中的成员（即“域”）可以单独使用，它的作用与地位相当于同类型的普通变量。
====13.2 指针（王西亚）====

1 指针是一种数据类型。

2 int*和int * (注意空格的位置) 两种声明方式效果相同。对于单变量声明，即一条语句中只声明一个指针的情况下没有区别，原因是C语言允许形式的自由性。
::上面的声明相当于：
 int*a;
 int *a;

3 int* a,b,c;
::错误的理解：认为声明了三个指针变量。
::正确的理解：只是a是指针型变量，b和c都是普通的整数。
::上面的声明相当于：
 int *a;
 int b;
 int c;
4指针的类型、指针所指向的类型
*指针存储的数值是内存的一个地址
*只要把指针声明语句中的指针名去掉，剩下的部分就是指针的类型
*只要把指针声明语句中的指针名和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型
5指针的值
*指针的值是指指针本身存储的数值，这个值会被编译器当做一个地址进行编译
*指针本身的大小是一个字长（32位机是4字节，64位机是8字节
*指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度是sizeof(指针所指向的类型)的一片连续内存区域
**说一个指针的值是X，就是说该指针指向了以X为首地址的一片内存区域
**说一个指针指向了某块内存区域，相当于说该指针的值是这块内存区域的首地址
*指针所指向的内存区和指针所指向的类型是两个完全不同的概念
**指针光声明但不初始化时，它所指向的内存区域是不存在的
====13.3 全局数据(范子高)====
全局数据区别于类中的全局变量。
=====全局数据的常用问题=====
*在对数据进行操作时会无意间进行全局数据的操作，但是以为全局数据不会改变。
*在使用别名时，实际上全局数据和别名所指向的使用一个数据。在例子中输入为全局变量进行输出时，inputVar被初始化为0，操作后赋值给全局数据globalVar，所以在输出前两个值均为5。原因在于你是用的别名和输入的全局数据名一样。
*在多线程程序大量出现的情况下，出现了全局数据如果在多个子程序中进行使用，那么一旦对数据进行了更改，那么原来的程序所要表达的方法将会改变。
*全局数据将会加大代码重写的难度，在你重写程序时，会出现是否依旧使用全局数据的难题，如果选择继续使用，那么在你以后每一次对这个程序进行重写的过程中你都需要使用全局数据，另一种方法就是把需要的数据以不适用全局数据的方式表示出来。
*全局数据的加载实在程序开始运行时就进行加载了，那么就出现了问题，如果在一个程序中使用了其他程序中的全局数据，那么如何决定全局数据加载的顺序。
*全局数据破坏了代码的模块化设计，在模块化设计中就是要减少代码的耦合，而全局数据的使用与这个思想相违背。
=====全局数据的缺点=====
*用于保存全局数值，在整个程序中都不进行修改操作，只对其数值进行读取。
*用于模拟具名常量，类似于java中用final修饰的常量。
*用于模拟枚举类型，将一个对象中的所有数据逗列举出来。
*可以简化对于一个常用数据的使用，在对于一个数据频繁使用的时候，把它定义为全局数据，将它为数不多的使用子程序集中在一起，可以方便进行维护。
*用于消除流浪数据，我的理解是类似与java中的exception message，在所有的方法中都可能出现message，但是不一定在每一个都会抛出exception，所以将它定义为全局数据，在所有的子程序中都可以使用，不会因为不使用而没有意义。
=====使用全局数据的条件=====
*首先将变量设为局部变量，在你需要时先将其转换为protected或者private修饰符修饰的变量，最后在别无选择的情况下在转换为全局变量。
*如果一个变量需要被整个程序访问，那么它是真的全局变量。如果他只是在一组特定的子程序中被频繁使用，那么它只是类变量。
*使用访问子程序来取代全局数据。
=====代替使用全局数据的方法=====
通过访问子程序的方式来代替使用全局数据。
使用子程序的优势：
*可以获得对于数据的集中控制，方便后期维护和修改。
*可以确保对变量所有的引用都得到了保护。
*信息进行了隐藏。
*访问子程序可以转变成为抽象数据类型。
使用子程序的过程：
*所有的代码都通过调用方法来获取数据而不是直接使用全局数据。
*将数据按照一定的规则进行分类，不要讲所有数据都放在一处，这样依旧不便于维护和修改。
*在多线程访问的时候，应该对子程序进行锁定，防止多处都是用此程序。
*在访问的子程序中构建一个抽象层，这样方便阅读。
=====降低全局数据的风险=====
*在必须使用全局数据的时候必须注意的问题。
*使用命名规则对全局数据命名，通过不同的类或者包来进行命名。
*为全局数据准备一份注释详细的清单来进行全局数据的统计。
*不要用全局数据来存放中间值，需要改变值时，在修改后重新赋值给全局数据。
*不要通过大对象存储全局数据的方式来进行传递，浪费内存空间。